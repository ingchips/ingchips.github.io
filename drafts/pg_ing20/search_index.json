[["index.html", "ING20XX 系列芯片外设开发者手册 1 版本历史", " ING20XX 系列芯片外设开发者手册 Ingchips Technology Co., Ltd. 1 版本历史 版本 信息 日期 0.0 初始版本 2025-07-8 "],["ch-overview.html", "2 概览 2.1 缩略语及术语 2.2 参考文档", " 2 概览 欢迎使用 INGCHIPS 918xx/916xx/20XX 软件开发工具包 （SDK）. ING20XX 系列芯片支持蓝牙 5.4 规范，内置高性能 32bit RISC MCU（支持 DSP 和 FPU）、Flash、低功耗 PMU， 以及丰富的外设、高性能低功耗 BLE RF 收发机。 本文介绍 SoC 外设及其开发方法。每个章节介绍一种外设，各种外设与芯片数据手册之外设一一对应， 基于 API 的兼容性、避免误解等因素，存在以下例外： PINCTRL 对应于数据手册之 IOMUX PCAP 对应于数据手册之 PCM SYSCTRL 是一个“虚拟”外设，负责管理各种 SoC 功能，组合了几种相关的硬件模块 SDK 外设驱动的源代码开放，其中包含很多常数，而且几乎没有注释 —— 这是有意为之，开发者只需要关注头文件，而不要尝试修改源代码。 2.1 缩略语及术语 表 2.1: 缩略语 缩略语 说明 ADC 模数转换器（Analog-to-Digital Converter） DMA 直接存储器访问（Direct Memory Access） FIFO 先进先出队列（First In First Out） FOTA 固件空中升级（Firmware Over-The-Air） GPIO 通用输入输出（General-Purpose Input/Output） I2C 集成电路间总线（Inter-Integrated Circuit） I2S 集成电路音频总线（Inter-IC Sound） IR 红外线（Infrared） PCAP 脉冲捕捉（Pulse CAPture） PDM 脉冲密度调制（Pulse Density Modulation） PLL 锁相环（Phase Locked Loop） PTE 外设触发引擎（Peripheral Trigger Engine） PWM 脉宽调制信号（Pulse Width Modulation） QDEC 正交解码器（Quadrature Decoder） RTC 实时时钟（Real-time Clock） SPI 串行外设接口（Serial Peripheral Interface） UART 通用异步收发器（Universal Asynchronous Receiver/Transmitter） USB 通用串行总线（Universal Serial Bus） 2.2 参考文档 Bluetooth SIG1 https://www.bluetooth.com/↩︎ "],["ch-adc.html", "3 ADC简介 3.1 功能描述 3.2 使用方法 3.3 编程指南", " 3 ADC简介 ADC全称Analog-to-Digital Converter，即模数转换器。 其主要作用是通过PIN测量电压，并将采集到的电压模拟信号转换成数字信号。 3.1 功能描述 3.1.1 特点 最多12个单端输入通道 12位分辨率 电压输入范围（0~VBAT） 支持APB总线 采样频率可编程 支持单一转换模式和连续转换模式 3.1.2 ADC模式 校准模式（calibration）：用于校准精度。 转换模式（conversion）：用于正常工作状态下的模数转换。 根据ADC输入模式完成对应的模式校准，之后在转换模式下进行正常模数转换。 3.1.3 ADC输入模式 单端输入（single-ended）：使用单个输入引脚，采样ADC内部的参考电压； 3.1.4 ADC转换模式 单次转换（single）：ADC完成单次转换后，ADC将停止，数据将被拉入 FIFO； 连续转换（continuous）：ADC经过 loop-delay 时间后循环进行转换，直到手动关闭。 3.1.5 ADC通道 ADC共12个channel，即ch0-ch11。 其中ch0-ch9为通用通道。 具体通道的输入连接引脚如下： 表 3.1: ADC输入连接引脚 通道 连接引脚 ch0 GPIO7 ch1 GPIO8 ch2 GPIO9 ch3 GPIO10 ch4 GPIO30 ch5 GPIO31 ch6 GPIO34 ch7 GPIO35 ch8 GPIO15 ch9 GPIO20 通道输入模式配置规则： 1. 通用通道ch0-ch9 以下是关于ADC通道对于开发者的几点使用建议： 1. 在使能通道前请先配置ADC输入模式； 2. 如需切换ADC输入模式，建议调用ADC_DisableAllChannels关闭之前模式下所有已使能通道，重新使能新的通道； 3.1.6 采样率 采样率和时钟、loop-delay大小以及使能通道个数有关，其计算关系如下： 当loop-delay=0时：\\[SAMPLERATE = \\frac{ADC\\_CLK}{16\\times{CH\\_NUM}}\\] 当loop-delay&gt;0时：\\[SAMPLERATE = \\frac{ADC\\_CLK}{loop\\_delay+16\\times{CH\\_NUM}+5}\\] 3.2 使用方法 3.2.1 时钟配置 当前ADC所用时钟源为 clock slow 经过分频得到的ADC工作时钟。 当前ADC工作时钟可以配置范围为500K-8M。 3.2.2 ADC参数配置 ADC参数配置接口的函数声明如下： void ADC_ConvCfg(SADC_adcCtrlMode ctrlMode, SADC_channelId ch, uint8_t enNum, uint8_t dmaEnNum, uint32_t loopDelay); 涉及参数有：ADC转换模式、采样通道、data触发中断数、data触发DMA搬运数、ADC输入模式和 loop-delay。 具体的参数取值范围请参考ADC头文件里对应的枚举定义或参数说明。 data触发中断数和data触发DMA搬运数决定了搬运ADC数据的方式。前者用触发中断的方式，后者用触发DMA搬运的方式。 注意： data触发中断数和data触发DMA搬运数应该一个为0，一个非0,。如果两值都非0则默认选择触发中断的方式，DMA配置不生效； 关于搬运方式的建议： 一般在小数据量情况下，如定时采集温度、电池电压，建议采用触发中断并CPU读数的方式。 一般大数据量连续采样，如模拟麦克风采样，建议采用DMA搬运方式（乒乓搬运），可以大大提高数据搬运处理效率。 注意： 多次调用ADC_ConvCfg则以最后一次调用为准（除通道使能，不会自动关闭之前已使能的通道），如只需使能（关闭）ADC通道可以通过ADC_EnableChannel接口完成。 3.2.3 ADC数据处理 ADC数据处理的推荐步骤为： 1. 调用ADC_PopFifoData（或DMA搬运buff）读取FIFO中的ADC原始数据； 2. 调用ADC_GetDataChannel得到原始数据中的数据所属通道（如需要）； 3. 调用ADC_GetData得到原始数据中的ADC数据； 4. 调用ADC_GetVol通过ADC数据计算得到其对应的电压值（如需要）。 也可以通过调用ADC_ReadChannelData接口直接得到指定通道的ADC数据，但这样会丢弃其他通道数据，请谨慎使用。其可以作为辅助接口使用，非主要方式。 对于单个数据的读取我们建议采用取若干数据求其平均值的方式，可以明显提高数据稳定性。 我们提供了方便开发者移植的求平均值程序，如有需求请参考SDK例程peripheral_battery。 3.3 编程指南 3.3.1 驱动接口 ADC控制： ADC_Reset：ADC复位 ADC_Start：ADC使能 ADC_AdcClose：ADC关闭 ADC配置： ADC_ConvCfg：ADC转换参数配置 ADC_EnableChannel：通道使能 ADC_DisableAllChannels：关闭所有通道 数据处理相关： ADC_GetFifoEmpty：读取FIFO是否为空 ADC_PopFifoData：读取FIFO原始数据 ADC_GetDataChannel：读取原始数据中通道号 ADC_GetData：读取原始数据中ADC数据 ADC_ReadChannelData：读取特定通道ADC数据（注意：该接口会丢弃其他通道数据） ADC_GetVol：读取ADC数据对应电压值 ADC_ClrFifo：清空FIFO 以上是ADC常用接口，还有部分接口不推荐直接使用，在此不进行罗列，详见头文件声明。 3.3.2 代码示例 下面展示ADC的基本用法： （注：以下ADC参数设置仅供参考，具体参数请结合实际需要进行配置） // TODO ： ADC模板未量产前校准参数不可用，仅限于获取原始adc数据测试使用 3.3.2.1 单次中断搬运 #define ADC_CHANNEL ADC_CH_0 #define ADC_CLK_MHZ 6 static uint32_t ADC_cb_isr(void *user_data) { uint32_t data = ADC_PopFifoData(); SADC_channelId channel = ADC_GetDataChannel(data); if (channel == ADC_CHANNEL) { uint16_t sample = ADC_GetData(data); // do something with &#39;sample&#39; } return 0; } void test(void) { SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_ADC); SYSCTRL_SetAdcClkDiv(24 / ADC_CLK_MHZ); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_ADC); ADC_Reset(); ADC_ConvCfg(SINGLE_MODE, ADC_CHANNEL, 0, 0, 0); platform_set_irq_callback(PLATFORM_CB_IRQ_SADC, ADC_cb_isr, 0); ADC_Start(1); } "],["ch-asdm.html", "4 ASDM简介 4.1 功能描述 4.2 使用方法 4.3 编程指南", " 4 ASDM简介 ASDM全称，Sigma-Delta-Analog-to-Digital Converter，即Sigma-Delta模拟数字转换器。 集成一个Sigma-Delta ADC模块，通过PIN测量电压，并将采集到的电压模拟信号转换成数字信号。相较于普通ADC模块，转换精度更高，抗干扰能力更强，功耗更低。 专为数字音频采样设计，内置数字处理单元，包含AGC和HPF等数字信号处理功能，支持硬件滤波，集成音量控制，音量淡入淡出。支持DMIC输出PDM信号采样处理。 4.1 功能描述 4.1.1 特点 单端输入或全差分输入 支持1MIC通道，模拟电压- 20dB ~ 40dB，增益0 / 16 / 12 / 20dB 16位分辨率 电压输入范围（0~VBAT） 支持APB总线 采样频率可编程 可产生2.2 V到2.7 V的麦克风偏置电压， 最高输出电流2MA， 电流过载保护 DMIC支持PDM信号采样处理，支持128和64bit两种采样类型 支持带淡入和淡出的独立音量控制 可编程时钟，支持六种典型采样频率：8/12/16/24/32/48kHz 支持DC阻塞的高通滤波器 4.1.2 性能 温度：- 40 ~ 125℃ 电源电压( Analog )：从2.7 V到3.6 V SNR: &gt; 92dB （需要使用内部偏置电压，内置参考电压需单独外接滤波电容） THD: &lt;-84dB 最高输出电流2MA: &lt;2mA 4.1.3 引脚定义 ASDM模块包含一对差分输入引脚ASDM_P和ASDM_N，以及一个偏置电压输出引脚MicBias，一个内置参考电压输出ASDM_Vref. 其中MicBias引脚用于输出麦克风偏置电压，用于驱动麦克风，偏置电压可以根据需求进行调整，ASDM_Vref引脚用于输出内置参考电压，如果需要获得更好的采样效果，内置参考电压需要从引脚输出并单独外接滤波电容，ASDM_P和ASDM_N引脚用于输入麦克风信号。 引脚的映射关系如表 4.1所示。 注意：如果不考虑增加电容对内置参考电压滤波，请不要打开内置参考电压输出，否则会影响系统采样，电路错误甚至会损坏芯片 表 4.1: ASDM引脚定义 引脚名称 连接引脚 连接引脚 ASDM_Vref 11 参考电压输出 MicBias 12 麦克风偏置电压输出 ASDM_P 13 差分输入P(单端输入) ASDM_N 14 差分输入N DMIC_CLK 查看PINCTRL章节 DMIC时钟输入 DMIC_DATA 查看PINCTRL章节 DMIC数据输入 4.1.4 采样率 模块的采样率和模块使用的输入时钟频率和内部时钟分频相关，支持的音频采样频率如表 4.1所示 表 4.1: ASDM支持的采样率 采样率(kHz) 外设输入时钟频率(MHz) 模拟AMIC时钟采样频率/数字DMIC时钟采样频率（128*fs） 数字DMIC时钟采样频率（64*fs） 48 12.288 6.144 3.072 32 12.288 3.072 1.536 24 12.288 2.448 1.224 16 12.288 1.536 0.768 8 12.288 0.768 0.384 外设的输入时钟频率由fast_clk分频而来，因此实现标准的声音采样需要调整对应的PLL输出和ASDM的DIV实现，推荐使用cube工具生成对应的时钟分频参数。 4.1.5 模块功能简述 上图为ASDM的整体功能框图，包含数字和模拟两个信号输入，后端集成数字信号处理。 模拟采样部分由PGA模块和Sigma-Delta ADC模块组成，PGA模块用于放大输入信号，Sigma-Delta ADC模块用于将模拟信号转换为数字信号。采样更加精确，采样结果可选经过硬件数字滤波输出或直接输出采样结果。 DMIC输入接口可以采样DMIC输入的PDM信号，可以直接输出获取DMIC的数字输出或经硬件数字处理后输出滤波后的音频结果。 内置SINC 和 HPF硬件数字滤波器，可以对输入数字信号进行滤波。 AGC（自动增益控制）位于信号处理链的中间环节，可选是否开启，解决输入音频信号电平不均衡的问题。AGC通过自动动态地调整增益，使输出电平保持稳定 ，从而维持后续处理模块输入信号的级别。 音量控制模块VolCtrl位于信号处理链的末端，用于调节输出信号的音量，通过调节增益值来控制输出信号的音量大小，可实现音量的淡入淡出控制。 输出的结果可以直接通过FIFO输出，同时支持DMA数据搬运和PTE任务触发。 4.2 使用方法 4.2.1 时钟配置 当前ASDM的时钟源来自于FAST_CLK，通过PLL进行分频后输出到ASDM_CLK，推荐使用CUBE工具生成分频系数，这里提供一组可选的CLK配置参数，PLL时钟源来自于RF24M时钟，PRE分频设置为5，LOOP倍频设置为64，OUT分频设置为1，ASDM分频设置为25，可获得12.288M的输出时钟。PLL输出为307.2M。由于需要调整PLL时钟源，开发者需要注意对应的时钟规划，防止外设出现时钟冲突的问题。 例如： SYSCTRL_SelectSlowClk(SYSCTRL_SLOW_CLK_24M_RF); SYSCTRL_SelectHClk(SYSCTRL_CLK_SLOW); SYSCTRL_SelectFlashClk(SYSCTRL_CLK_SLOW); SYSCTRL_ConfigPLLClk(5,64,1); SYSCTRL_EnablePLL(1); SYSCTRL_SelectHClk(SYSCTRL_CLK_PLL_DIV_1); SYSCTRL_SelectFlashClk(SYSCTRL_CLK_PLL_DIV_2); SYSCTRL_UpdateAsdmClk(25); 4.2.2 设置电压偏置和Vref输出滤波 ASDM模块可以输出单独的偏置电压用来驱动MIC输出，对应接口存在于peripheral_sysctrl.c,接口如下： void SYSCTRL_SetAdcVrefSel(uint8_t vref); 为了获得更好的收音效果，通常推荐打开内部VREF输出，外接单独的硬件滤波。不外接硬件滤波一定不要使能参考电压输出，否则可能导致底噪变大。打开VREF输出的接口如下： void SYSCTRL_EnableAsdmVrefOutput(uint8_t enable); 使用ASDM模块，需要使用内置的参考电压对外部信号进行采样，因此一定要打开内部电压参考否则可能会工作不正常。接口如下： void SYSCTRL_EnableInternalVref(uint8_t enable); 注意：使能引脚偏置电压输出或参考电压输出，一定要将引脚设置为模拟输入输出模式，详细实现参考PINCTRL 4.2.3 初始化配置 对于AMIC和DMIC的数据采样应用，由于ASDM内部集成了数字信号处理逻辑，可以极大的简化数字信号处理. 通过配置对应的AGC、HPF、SINC、VOL等参数，可以快速实现数字信号处理。对比使用CPU进行数字信号滤波，降低了处理难度，加快了处理速度. 对于想要快速使用ING20系列芯片进行语音采集应用测试和加快开发速度，调整AGC参数整定选择高通滤波器参数，电压偏置调整较为复杂，不方便初学者入手. 因此在综合考虑芯片的易用性和灵活性下，初始化接口根据VOICE和MUSIC场景封装了典型的滤波参数和AGC增益参数，用户可以使用初始化接口快速初始化外设，或根据自身需求调用指定接口整定对应滤波器和其他数字信号处理单元参数。 ASDM 初始化接口配置如下： int ASDM_Config(ASDM_TypeDef *base, ASDM_ConfigTypeDef* pParam); 用户需要传入ASDM模块宏APB_ASDM，和需要用户配置的结构体参数内容pParam。 结构体如下： typedef struct { uint32_t volume; uint8_t Asdm_Mode; ASDM_SampleRate Sample_rate; ASDM_AgcMode Agc_mode; ASDM_AgcConfigTypeDef *Agc_config; uint8_t Fifo_Enable; uint8_t Fifo_DmaTrigNum; uint8_t FifoIntMask; } ASDM_ConfigTypeDef; 涉及参数： volume：控制系统音量 注意：volume设置为0时，系统会静音输出数值为0 Asdm_Mode： 选择ASDM模块输入模式，0 选择AMIC， 1选择DMIC。 Sample_rate： 可选对应采样率。 Agc_mode： 封装了常用的AGC模式配置，可以通过模式选择载入不同的AGC默认参数配置或关闭AGC。 Agc_config： 用户选择ASDM_AgcOff时AGC参数无效。 当用户选择ASDM_AgcVoice或ASDM_AgcMusic模式时，用户可以通过该结构体获取默认的AGC参数信息（传入NULL指针无效），当用户选择ASDM_AgcCustom模式时，用户可以通过该结构体传入自定义的AGC参数信息. 具体参数如下： typedef struct { uint8_t Agc_MaxLevel; //最大增益 uint8_t Agc_NoiseThreshold; //噪声阈值 uint8_t Agc_NoiseEn; //噪声检测使能 uint8_t Agc_NoiseHold; //噪声检测保持时间 uint16_t Agc_NoiseFramTime; //噪声检测帧时间 uint16_t Agc_PgaGate; //PGA门限 } ASDM_AgcConfigTypeDef; Fifo_Enable： 使能FIFO功能，0关闭，1打开。 Fifo_DmaTrigNum： FIFO触发DMA传输的阈值，当FIFO内数据量大于该值时，DMA会自动传输数据。（仅用于DMA传输） FifoIntMask： FIFO中断使能，打开对应的中断，可使用的中断类型参考 ASDM_FifoMask 注意，当FIFO关闭时 仅可开启ASDM_RX_FLG_EN中断 4.3 编程指南 4.3.1 驱动接口 ASDM模块控制： ASDM_Config ：配置ASDM模块工作参数。 ASDM_Enable ：使能ASDM模块。 内部参数调整： ASDM_SetEdgeSample ：设置pdm模块采样的边沿。 ASDM_InvertInput ：设置pdm模块输入信号是否反向。 ASDM_SelMic ：选择输入类型，模拟输入 pdm输入。 ASDM_SelDownSample ： PDM模块降采样（设置128 64采样率） ASDM_SetSampleRate ： 根据采样类型设置采样频率和高通滤波器参数 ASDM_SetHpfCoef ： 单独设置高通滤波器参数 ASDM_SetAgcMode ：设置AGC模式，和AGC参数 ASDM_Reset ： 重置ASDM模块 ASDM_MuteEn ： 设置静音使能 ASDM_SetPgaGain ： 设置pga增益 ADSM_VolZeroState ： 获取系统静音状态 ASDM_SetVol ： 设置系统输出音量步进 ASDM_GetAGCMute ： 获取AGC静音状态 数据处理： ASDM_GetOutData ： 获取ASDM模块输出数据 ASDM模块输出数据格式说明： 模块通过32位宽FIFO输出采样数据，每次输出包含两个16位采样值： 高16位（bit[31:16]）：当前最新采样数据（时间上较新） 低16位（bit[15:0]）：上一拍历史采样数据（时间上较旧） 即：每次从FIFO读取的32位数据 = {当前采样, 历史采样}，按时间顺序从新到旧排列。 ASDM_ClrOverflowError ： 清除FIFO溢出错误标志位 ASDM_ClrFifo ： 清除FIFO ASDM_FifoEn ： 使能FIFO ASDM_GetFifoCount ： 获取FIFO内数据量 ASDM_IntMask ： 使能ASDM中断 ASDM_GetIntStatus ： 获取ASDM中断状态 ASDM_SetDMATrig ： 设置DMA触发条件 以上是ASDM模块的驱动接口，详细描述可以参考头文件声明。 4.3.2 代码示例 下面展示ASDM模块的基本用法，实际使用需要根据情况调整，对于大数据采样推荐使用DMA进行数据搬运减小中断频率。 注意输入时钟的PLL和DIV配置不在此表述可参考sysctrl接口,SYSCTRL_UpdateAsdmClk用来设置ASDM模块基于fast_clk的输入分频，以下代码示例中假设调整PLL和调用SYSCTRL_UpdateAsdmClk设置分频后时钟为12.288Mhz。 4.3.2.1 DMIC中断获取MIC数据输出 static uint32_t ASDM_cb_isr(void *user_data) { while (ASDM_GetFifoCount(APB_ASDM)) { uint32_t DataGet = ASDM_GetOutData(APB_ASDM); uint16_t next_data = (DataGet)&gt;&gt;16; uint16_t data = (DataGet)&amp;0xffff; } } ASDM_ConfigTypeDef AsdmConfig = { .Agc_config = 0, .Asdm_Mode = 1, .Agc_mode = ASDM_AgcVoice, .Sample_rate = ASDM_SR_16k, .Fifo_Enable = 1, .volume = 0x3fff, .FifoIntMask = ASDM_FIFO_FULL_EN, }; void ASDM_InitPre(void) { int ret; SYSCTRL_ClearClkGate(SYSCTRL_ClkGate_APB_GPIO0); SYSCTRL_ClearClkGate(SYSCTRL_ClkGate_APB_PinCtrl); SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_ASDM); PINCTRL_SelAsdm(GIO_GPIO_13,GIO_GPIO_14); ret = ASDM_Config(APB_ASDM, &amp;AsdmConfig); if (ret) printf(&quot;ASDM_Config error %d\\n&quot;, ret); platform_set_irq_callback(PLATFORM_CB_IRQ_ASDM, ASDM_cb_isr, 0); ASDM_Enable(APB_ASDM,1); } 4.3.2.2 AMIC中断获取MIC数据输出 static uint32_t ASDM_cb_isr(void *user_data) { while (ASDM_GetFifoCount(APB_ASDM)) { uint32_t DataGet = ASDM_GetOutData(APB_ASDM); uint16_t next_data = (DataGet)&gt;&gt;16; uint16_t data = (DataGet)&amp;0xffff; } } ASDM_ConfigTypeDef AsdmConfig = { .Agc_config = 0, .Asdm_Mode = 0, .Agc_mode = ASDM_AgcVoice, .Sample_rate = ASDM_SR_16k, .Fifo_Enable = 1, .volume = 0x3fff, .FifoIntMask = ASDM_FIFO_FULL_EN, }; void ASDM_InitPre(void) { int ret; SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_ASDM); SYSCTRL_ClearClkGate(SYSCTRL_ClkGate_APB_GPIO0);//gpio0 SYSCTRL_ClearClkGate(SYSCTRL_ClkGate_APB_PinCtrl); PINCTRL_EnableAnalog(GIO_GPIO_11); // vref pad PINCTRL_EnableAnalog(GIO_GPIO_12); // mic bias pad PINCTRL_EnableAnalog(GIO_GPIO_13); // mic in p PINCTRL_EnableAnalog(GIO_GPIO_14); // mic in n SYSCTRL_SetAdcVrefSel(0x1); SYSCTRL_EnableAsdmVrefOutput(1); SYSCTRL_EnableInternalVref(1); ret = ASDM_Config(APB_ASDM, &amp;AsdmConfig); if (ret) printf(&quot;ASDM_Config error %d\\n&quot;, ret); platform_set_irq_callback(PLATFORM_CB_IRQ_ASDM, ASDM_cb_isr, 0); ASDM_Enable(APB_ASDM,1); } 4.3.2.3 AMIC DMA 配置 #include &quot;pingpong.h&quot; #define DMA_CHANNEL 0 static DMA_PingPong_t PingPong; ASDM_ConfigTypeDef AsdmConfig = { .Agc_config = 0, .Asdm_Mode = 0, .Agc_mode = ASDM_AgcVoice, .Sample_rate = ASDM_SR_16k, .Fifo_Enable = 1, .volume = 0x3fff, .FifoIntMask = 0, .Fifo_DmaTrigNum = 4, }; static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(DMA_CHANNEL); DMA_ClearChannelIntState(DMA_CHANNEL, state); uint32_t *buff = DMA_PingPongIntProc(&amp;PingPong, DMA_CHANNEL); uint32_t tranSize = DMA_PingPongGetTransSize(&amp;PingPong); return 0; } void test(void) { int ret; SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_ASDM); SYSCTRL_ClearClkGate(SYSCTRL_ClkGate_APB_GPIO0);//gpio0 SYSCTRL_ClearClkGate(SYSCTRL_ClkGate_APB_PinCtrl); PINCTRL_EnableAnalog(GIO_GPIO_11); // vref pad PINCTRL_EnableAnalog(GIO_GPIO_12); // mic bias pad PINCTRL_EnableAnalog(GIO_GPIO_13); // mic in p PINCTRL_EnableAnalog(GIO_GPIO_14); // mic in n SYSCTRL_SetAdcVrefSel(0x1); SYSCTRL_EnableAsdmVrefOutput(1); SYSCTRL_EnableInternalVref(1); ret = ASDM_Config(APB_ASDM, &amp;AsdmConfig); if (ret) printf(&quot;ASDM_Config error %d\\n&quot;, ret); SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ITEM_APB_DMA)); SYSCTRL_SelectUsedDmaItems(1 &lt;&lt; SYSCTRL_DMA_ASDM_RX); DMA_PingPongSetup(&amp;PingPong, SYSCTRL_DMA_ASDM_RX, 80, 8); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); DMA_PingPongEnable(&amp;PingPong, DMA_CHANNEL); ASDM_Enable(APB_ASDM,1); } "],["ch-dma.html", "5 DMA简介 5.1 功能描述 5.2 使用方法 5.3 编程指南", " 5 DMA简介 DMA全称direct memory access，即直接存储器访问。 其主要作用是不占用CPU大量资源，在AMBA AHB总线上的设备之间以硬件方式高速有效地传输数据。 5.1 功能描述 5.1.1 特点 最多8个DMA通道 最多16个硬件握手请求/确认配对 支持8/16/32/64位宽的数据传输 支持24-64位地址宽度 支持成链传输数据 5.1.2 搬运方式 单次数据块搬运：DMA使用单个通道，一次使能将数据从SRC到DST位置搬运一次 成串多数据块搬运：DMA使用单个通道，一次使能按照DMA链表信息依次将数据从SRC到DST位置搬运多次或循环搬运。 其根本区别是有无注册有效的DMA链表。 5.1.3 搬运类型 memory到memory搬运 memory到peripheral搬运 peripheral到memory搬运 peripheral到peripheral搬运 5.1.4 中断类型 IntErr：错误中断表示DMA传输发生了错误而触发中断，主要包括总线错误、地址没对齐和传输数据宽度没对齐等。 IntAbt：终止传输中断会在终止DMA通道传输时产生。 IntTC：TC中断会在没有产生IntErr和IntAbt的情况下完成一次传输时产生。 注意： 当DMA传输链表有效时，TC中断只会在传输完成时产生，不会在传输过程中产生。 IntEachDesc：链转换结束中断。当DMA传输链表有效时，每当一个描述符传输完成时产生。 注意： 中断触发时会停止DMA传输，需要在中断重新使能通道才会继续进行链式DMA传输。 5.1.5 数据地址类型 Increment address Decrement address Fixed address 如果Increment则DMA从地址由小到大搬运数据，相反的Decrement则由大到小搬运。fixed地址适用于外设FIFO的寄存器搬运数据。 5.1.6 数据方式 normal mode handshake mode DMA搬运前需要对数据源和数据目的地址的数据方式进行配置。 数据方式的选择有如下建议： 1. 从内存搬运数据选择normal mode； 2. 从外设FIFO搬运数据选择handshake mode，同时要和外设协商好BurstSize，支持2^n(n = 0-7)大小的BurstSize。 5.1.7 数据位宽 DMA传输要求传输两端的数据类型一致，支持数据类型有： Byte transfer Half-word transfer Word transfer Double word transfer 覆盖所有常见数据类型。 5.1.8 总线仲裁 DMA支持总线仲裁，即多个DMA通道共享总线，互不干扰。当使能多个DMA通道时，DMA会自动进行总线仲裁，使得总线上同时只有一个DMA通道在工作。 为了防止总线单通道阻塞，DMA会根据每个传输的burstSize大小，自动切换通道数据传输，即通道每传输一个burstSize的数据，切换到下一个通道继续传输。 5.2 使用方法 5.2.1 方法概述 首先确认数据搬运需求是单次搬运还是成串搬运，以及搬运类型，即memory和peripheral的关系。 5.2.1.1 单次搬运 1. 注册DMA中断 2. 定义一个DMA_Descriptor变量用来配置DMA通道寄存器 3. 根据数据搬运类型选择DMA寄存器配置接口，正确调用驱动接口配置DMA寄存器 4. 使能DMA通道开始搬运 5.2.1.2 成串搬运 1. 注册一个或多个DMA中断 2. 定义多个DMA_Descriptor变量用来配置DMA通道寄存器 3. 根据数据搬运类型选择DMA寄存器配置接口，正确调用驱动接口配置DMA寄存器 4. 将多个DMA_Descriptor变量首尾相连成串，类似链表 5. 使能DMA通道开始搬运 5.2.2 注意点 定义DMA_Descriptor变量需要8字节对齐，否则DMA搬运不成功 成串搬运如果配置多个DMA中断则需要在每个中断里使能DMA，直到最后一次搬运完成 对于从外设搬运需要确认外设是否支持DMA 建议从外设搬运选择握手方式，并与外设正确协商burstSize burstSize尽量取较大值，有利于减少DMA中断次数提高单次中断处理效率。但burstSize太大可能最后一次不能搬运丢弃较多数据 建议设置从外设搬运总数据量为burstSize的整数倍或采用乒乓搬运的方式 在DMA从外设搬运的情况下，正确的操作顺序是先配置并使能好DMA，再使能外设开始产生数据 5.2.3 握手请求 握手请求：DMA请求握手信号，请求对方传输数据。当进行外设到内存数据传输，内存到外设数据传输以及外设到外设数据传输时，都需要进行握手请求。 握手请求的触发条件： DMA用作到外设到FIFO搬运数据时，当FIFO内数据计数增加waterlevel时，外设会发出数据请求，DMA开始将数据从外设FIFO搬运到内存。 DMA用作FIFO到外设数据传输时，当FIFO内数据计数减小到waterlevel时，DMA会发出数据请求，DMA开始将数据从内存搬运到外设FIFO。 例如 ： 使用DMA将RX接收数据搬运到内存： UART设置RX FIFO waterlevel为4，当接收到4个字节数据时，UART会发出数据请求，DMA开始将数据从外设FIFO搬运到内存。 使用DMA将内存搬运到外设触发TX发送：UART设置TX FIFO waterlevel为4，当fifo内的数据计数到达4时，UART会发出数据请求，DMA开始将数据从内存搬运到外设FIFO。 握手请求的配置： 通常情况无需关心，使用默认配置。 当需要使能的DMA搬运配置为pdm,adc,pwm_channel0,pwm_channel2,qdec_req2外设时，需要手动重新配置握手请求表，再使用对应接口初始化DMA. 详情请参照SYSCTRL DMA规划章节。 5.3 编程指南 5.3.1 驱动接口 DMA_PrepareMem2Mem：memory到memory搬运标准DMA寄存器配置接口 DMA_PreparePeripheral2Mem：Peripheral到memory搬运标准DMA寄存器配置接口 DMA_PrepareMem2Peripheral：memory到Peripheral搬运标准DMA寄存器配置接口 DMA_PreparePeripheral2Peripheral：Peripheral到Peripheral搬运标准DMA寄存器配置接口 DMA_Reset：DMA复位接口 DMA_GetChannelIntState：DMA通道中断状态获取接口 DMA_ClearChannelIntState：DMA通道清中断接口 DMA_EnableChannel：DMA通道使能接口 DMA_AbortChannel：DMA通道终止接口 DMA_ConfigSrcBurstSize： DMA配置通道burstSize接口 5.3.2 代码示例 5.3.2.1 单次搬运 下面以memory到memory单次搬运展示DMA的基本用法： #define CHANNEL_ID 0 char src[] = &quot;hello world!&quot;; char dst[20]; DMA_Descriptor test __attribute__((aligned (8))); static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); printf(&quot;dst = %s\\n&quot;, dst); return 0; } void DMA_Test(void) { DMA_Reset(); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); DMA_PrepareMem2Mem(&amp;test[0], dst, src, strlen(src), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_EnableChannel(CHANNEL_ID, &amp;test); } 最终会在DMA中断程序里面将搬运到dst中的“hello world!”字符串打印出来。 5.3.2.2 成串搬运 下面以memory到memory两块数据搬运拼接字符串展示DMA成串搬运的基本用法： #define CHANNEL_ID 0 char src[] = &quot;hello world!&quot;; char src1[] = &quot;I am ING20.&quot;; char dst[100]; DMA_Descriptor test[2] __attribute__((aligned (8))); static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); printf(&quot;dst = %s\\n&quot;, dst); return 0; } void DMA_Test(void) { DMA_Reset(); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); test[0].Next = &amp;test[1]; // make a DMA link chain test[1].Next = NULL; DMA_PrepareMem2Mem(&amp;test[0], dst, src, strlen(src), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_PrepareMem2Mem(&amp;test[1], dst + strlen(src), src1, sizeof(src1), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_EnableChannel(CHANNEL_ID, &amp;test[0]); } 最终将会打印出“hello world!I am ING20.”字符串。 5.3.2.3 DMA乒乓搬运 DMA乒乓搬运是一种DMA搬运的特殊用法，其主要应用场景是将外设FIFO中数据循环搬运到memory中并处理。 可实现“搬运”和“数据处理”分离，从而大大提高程序处理数据的效率。 对于大量且连续的数据搬运，如音频，我们推荐选用DMA乒乓搬运的方式。 5.3.2.3.1 DMA乒乓搬运接口 在最新SDK中我们已将DMA乒乓搬运封装成标准接口，方便开发者调用，提高开发效率。 使用时请添加 pingpong.c文件，并包含 pingpong.h文件。 DMA_PingPongSetup：DMA乒乓搬运建立接口 DMA_PingPongIntProc：DMA乒乓搬运标准中断处理接口 DMA_PingPongGetTransSize：获取DMA乒乓搬运数据量接口 DMA_PingPongEnable：DMA乒乓搬运使能接口 DMA_PingPongDisable：DMA乒乓搬运去使能接口 更多程序开发者可以参考voice_remote_ctrl例程。 5.3.2.3.2 DMA乒乓搬运示例 下面将以最常见的DMA乒乓搬运I2s数据为例展示DMA乒乓搬运的用法。 I2s的相关配置不在本文的介绍范围内，默认I2s已经配置好，DMA和I2s协商burstSize=8。 #include &quot;pingpong.h&quot; #define CHANNEL_ID 0 DMA_PingPong_t PingPong; static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); // call &#39;DMA_PingPongIntProc&#39; to get the pointer of data-buff. uint32_t *rr = DMA_PingPongIntProc(&amp;PingPong, CHANNEL_ID); uint32_t i = 0; // call &#39;DMA_PingPongGetTransSize&#39; to kwon how much data in data-buff. uint32_t transSize = DMA_PingPongGetTransSize(&amp;PingPong); while (i &lt; transSize) { // do something with data &#39;rr[i]&#39; i++; } return 0; } void DMA_Test(void) { // call &#39;DMA_PingPongSetup&#39; to setup ping-pong DMA. DMA_PingPongSetup(&amp;PingPong, SYSCTRL_DMA_I2S_RX, 100, 8); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); // call &#39;DMA_PingPongEnable&#39; to start ping-pong DMA transmission. DMA_PingPongEnable(&amp;PingPong, CHANNEL_ID); I2S_ClearRxFIFO(APB_I2S); I2S_DMAEnable(APB_I2S, 1, 1); I2S_Enable(APB_I2S, 0, 1); // Enable I2s finally } 停止DMA乒乓搬运可以调用以下接口： void Stop(void) { // call &#39;DMA_PingPongEnable&#39; to disable ping-pong DMA transmission. DMA_PingPongDisable(&amp;PingPong, CHANNEL_ID); I2S_Enable(APB_I2S, 0, 0); I2S_DMAEnable(APB_I2S, 0, 0); } "],["ch-gpio.html", "6 通用输入输出（GPIO） 6.1 功能概述 6.2 使用说明", " 6 通用输入输出（GPIO） 6.1 功能概述 GPIO 模块常用于驱动 LED 或者其它指示器，控制片外设备，感知数字信号输入，检测信号边沿， 或者从低功耗状态唤醒系统。ING20XX 系列芯片内部支持最多 42 个 GPIO，通过 PINCTRL 可将 GPIO \\(n\\) 引出到芯片 IO 管脚 \\(n\\)。 特性： 每个 GPIO 都可单独配置为输入或输出 每个 GPIO 都可作为中断请求，中断触发方式支持边沿触发（上升、下降单沿触发，或者双沿触发） 和电平触发（高电平或低电平） 硬件去抖 在硬件上存在 两个 GPIO 模块，每个模块包含 21 个 GPIO，分为 GPIO0 {IO0-IO20} 和 GPIO1 {IO21-IO41}。 相应地定义了两个 SYSCTRL_Item： typedef enum { SYSCTRL_ITEM_APB_GPIO0 , SYSCTRL_ITEM_APB_GPIO1 , // ... } SYSCTRL_Item; 注意按照所使用的 GPIO 管脚打开对应的 GPIO 模块。 6.2 使用说明 6.2.1 设置 IO 方向 在使用 GPIO 之前先按需要配置 IO 方向： 需要用于输出信号时：配置为输出 需要用于读取信号时：配置为输入 需要用于生产中断请求时：配置为输入 需要高阻态时：配置为高阻态 使用 GIO_SetDirection 配置 GPIO 的方向。GPIO 支持四种方向： typedef enum { GIO_DIR_INPUT, // 输入 GIO_DIR_OUTPUT, // 输出 GIO_DIR_BOTH, // 同时支持输入、输出 GIO_DIR_NONE // 高阻态 } GIO_Direction_t; 如无必要，不要使用 GIO_DIR_BOTH。 6.2.2 读取输入 使用 GIO_ReadValue 读取某个 GPIO 当前输入的电平信号，例如读取 GPIO 0 的输入： uint8_t value = GIO_ReadValue(GIO_GPIO_0); 使用 GIO_ReadAll 可以同时读取所有 GPIO 当前输入的电平信号。其返回值的第 \\(n\\) 比特 （第 0 比特为最低比特）对应 GPIO \\(n\\) 的输入；如果 GPIO \\(n\\) 当前不支持输入，那么第 \\(n\\) 比特为 0： uint64_t GIO_ReadAll(void); 6.2.3 设置输出 设置单个输出 使用 GIO_WriteValue 设置某个 GPIO 输出的电平信号，例如使 GPIO 0 输出高电平（1）： GIO_WriteValue(GIO_GPIO_0, 1); 同时设置所有输出 通过 GIO_WriteAll 可同时设置所有 GPIO 输出的电平信号： void GIO_WriteAll(const uint64_t value); 将若干输出置为高电平 通过 GIO_SetBits 可同时将若干 GPIO 输出置为高电平： void GIO_SetBits(const uint64_t index_mask); 比如要将 GPIO 0、5 置为高电平，那么 index_mask 为 (1 &lt;&lt; 0) | (1 &lt;&lt; 5)。 将若干输出置为低电平 通过 GIO_ClearBits 可同时将若干 GPIO 输出置为低电平： void GIO_ClearBits(const uint64_t index_mask); index_mask 的使用与 GIO_SetBits 相同。 6.2.4 配置中断请求 使用 GIO_ConfigIntSource 配置 GPIO 生成中断请求。 void GIO_ConfigIntSource( const GIO_Index_t io_index, // GPIO 编号 const uint8_t enable, // 使能的边沿或者电平类型组合 const GIO_IntTriggerType_t type // 触发类型 ); 其中的 enable 为以下两个值的组合（0 表示禁止产生中断请求）： typedef enum { ...LOGIC_LOW_OR_FALLING_EDGE = ..., // 低电平或者下降沿 ...LOGIC_HIGH_OR_RISING_EDGE = ... // 高电平或者上升沿 } GIO_IntTriggerEnable_t; 触发类型有两种： typedef enum { GIO_INT_EDGE, // 边沿触发 GIO_INT_LOGIC // 电平触发 } GIO_IntTriggerType_t; 例如将 GPIO 0 配置为上升沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为双沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE | ..._HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为高电平触发 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_LOGIC); 6.2.5 处理中断状态 用 GIO_GetIntStatus 获取某个 GPIO 上的中断触发状态，返回非 0 值表示该 GPIO 上产生了中断请求；用 GIO_GetAllIntStatus 一次性获取所有 GPIO 的中断触发状态， 第 \\(n\\) 比特（第 0 比特为最低比特）对应 GPIO \\(n\\) 上的中断触发状态。 GPIO 产生中断后，需要消除中断状态方可再次触发。用 GIO_ClearIntStatus 消除某个 GPIO 上中断状态，用 GIO_ClearAllIntStatus 一次性清除所有 GPIO 上可能存在的中断触发状态。 6.2.6 输入去抖 使用 GIO_DebounceCtrl 配置输入去抖参数，每个 GPIO 硬件模块使用单独的参数： void GIO_DebounceCtrl( uint8_t group_mask, // 比特 0 为 1 时配置模块 0 // 比特 1 为 1 时配置模块 1 uint8_t clk_pre_scale, GIO_DbClk_t clk // 防抖时钟选择 ); 所谓去抖就是过滤掉长度小于 (clk_pre_scale + 1) 个防抖时钟周期的“毛刺”。 防抖时钟共有 2 种： typedef enum { GIO_DB_CLK_32K, // 使用 32k 时钟 GIO_DB_CLK_PCLK, // 使用快速 PCLK } GIO_DbClk_t; 快速 PCLK 的具体频率参考 SYSCTRL。 通过 GIO_DebounceEn 为单个 GPIO 使能去抖。例如要在 GPIO 0 上启用硬件去抖，忽略宽度小于 \\(5/32768 \\approx 0.15 (ms)\\) 的“毛刺”： GIO_DebounceCtrl(1, 4, GIO_DB_CLK_32K); GIO_DebounceEn(GIO_GPIO_0, 1); 6.2.7 低功耗保持状态 所有 GPIO 可以在芯片进入低功耗状态后保持状态。根据功能的不同，存在两种类型的 GPIO， 总结于表 6.1。 表 6.1: GPIO 的保持与唤醒功能 序号 分类 低功耗保持 DEEP 唤醒源 DEEPER 唤醒源 0 A Y Y Y 1 B Y Y 2 B Y Y 3 B Y Y 4 B Y Y 5 A Y Y Y 6 A Y Y Y 7 B Y Y 8 B Y Y 9 B Y Y 10 B Y Y 11 B Y Y 12 B Y Y 13 B Y Y 14 B Y Y 15 B Y Y 16 B Y Y 17 B Y Y 18 B Y Y 19 B Y Y 20 B Y Y 21 A Y Y Y 22 A Y Y Y 23 A Y Y Y 24 B Y Y 25 B Y Y 26 B Y Y 27 B Y Y 28 B Y Y 29 B Y Y 30 B Y Y 31 B Y Y 32 A Y Y Y 33 A Y Y Y 34 B Y Y 35 B Y Y 36 C Y 37 C Y 38 C Y 39 C Y 40 C Y 41 C Y 对于 A 型 GPIO 使用 GIO_EnableRetentionGroupA 使能或禁用 A 型 GPIO 的低功耗状态保持功能。 使能状态保持功能时，IOMUX 与之相关的所有配置都被锁存，即使处于各种低功耗状态下。使能后， 对这些 GPIO 的配置再做修改无法生效。只有禁用保持功能后，才会生效。 使能后，低功耗状态下这些 GPIO 不掉电。 void GIO_EnableRetentionGroupA(uint8_t enable); 对于 B 型 GPIO 使用 GIO_EnableRetentionGroupB 使能或禁用 B 型 GPIO 的低功耗状态保持功能。 使能状态保持功能时，与之相关的配置（输出值 —— 对于 IO 方向为输出的 GPIO、上下拉）都被锁存，即使处于各种低功耗状态下。 使能后，对这些 GPIO 的配置再做修改无法生效。只有禁用保持功能后，才会生效。 说明：对于 IO 方向为输入的 GPIO，使能低功耗状态保持功能并进入低功耗状态后，确实可以保持其 IO 输入功能， 但是并不能产生实际效果（产生中断或者唤醒系统）。 void GIO_EnableRetentionGroupB(uint8_t enable); 使用 GIO_EnableHighZGroupB 使能或禁用 B 型 GPIO 的低功耗高阻功能。使能该功能后， IO 方向为输出的 B 型 GPIO 处于高阻状态，对这些 GPIO 的配置再做修改无法生效。只有禁用保持功能后，才会生效。 void GIO_EnableHighZGroupB(uint8_t enable); 这两个功能是互斥的，比如先后调用这个两个函数，先使能保持再使能高阻，则只有高阻功能生效。 对于 C 型 GPIO 不支持低功耗保持。 这些功能只支持对所有 GPIO 同时使能或禁用，不能对单个 GPIO 分别控制。 6.2.8 睡眠唤醒源 一部分 GPIO 支持作为低功耗状态的唤醒源：出现指定的电平信号时，将系统从低功耗状态下唤醒。 对于深度睡眠（DEEP Sleep），这些 GPIO （\\(\\{0 ... 35\\}\\)）可作为唤醒源，包括所有的 A 型 GPIO 和部分 B 型 GPIO； 对于更深度的睡眠（DEEPER Sleep），所有的 A 型 GPIO 可作为唤醒源，参见表 6.1。 深度睡眠唤醒源 使用 GIO_EnableDeepSleepWakeupSource 使能（或停用）某个 GPIO 的唤醒功能。 其中，io_index 应该为支持该功能的 GPIO 的编号；mode 为唤醒方式；对于 A 型 GPIO， 忽略 pull 参数，其上下拉由 PINCTRL_Pull 控制。共支持以下 5 种唤醒方式： GIO_WAKEUP_MODE_LOW_LEVEL：通过低电平唤醒； GIO_WAKEUP_MODE_HIGH_LEVEL：通过高电平唤醒； GIO_WAKEUP_MODE_RISING_EDGE：通过上升沿唤醒； GIO_WAKEUP_MODE_FALLING_EDGE：通过下降沿唤醒； GIO_WAKEUP_MODE_ANY_EDGE： 通过任意边沿唤醒，即上升沿或下降沿皆可。 当使用电平唤醒时，电平与上下拉应该相互配合：高电平唤醒时，使用下拉；低电平唤醒时，使用上拉。 当使用边沿唤醒时，注意脉冲需要维持至少 100 \\(\\mu s\\)。 对于 B 型 GPIO，唤醒源与低功耗保持为两套独立的电路，因此： 1）上下拉独立于 PINCTRL_Pull ，而且一直生效 —— 无论是否处于低功耗状态， 所以，不要用 PINCTRL_Pull 配置相反的上下拉；2） 使能或禁用 B 型 GPIO 的低功耗保持或者高阻功能不影响这里的唤醒源设置；3）不要将某 IO 同时设为输出和唤醒源， 比如将某 IO 同时设为输出高电平、高电平唤醒，使能保持功能并进入低功耗时， 这个 IO 上保持电路所输出的高电平将传输到唤醒源电路并触发唤醒。 int GIO_EnableDeepSleepWakeupSource( GIO_Index_t io_index, // GPIO 编号 uint8_t enable, // 使能(1)/禁用(0) uint8_t mode , // 触发方式 pinctrl_pull_mode_t pull // 上下拉配置 ); 任意一个唤醒源检测到唤醒电平就会将系统从低功耗状态唤醒。 更深度睡眠唤醒源 使用 GIO_EnableDeeperSleepWakeupSourceGroupA 使能（或停用）A 型 GPIO 的更深度睡眠唤醒功能。 其中，level 为触发电平，1 为高电平唤醒，0 为低电平唤醒。 使能后，所有 IO 方向为输入的 A 型 GPIO 都将作为唤醒源。任意一个唤醒源检测到唤醒电平就会将系统从低功耗状态唤醒。 void GIO_EnableDeeperSleepWakeupSourceGroupA( uint8_t enable, // 使能(1)/禁用(0) uint8_t level // 触发唤醒的电平 ); "],["ch-iic.html", "7 I2C总线 7.1 功能概述 7.2 使用说明", " 7 I2C总线 I2C(Inter－Integrated Circuit)是一种通用的总线协议。 它是一种只需要两个IO并且支持多主多从的双向两线制总线协议标准。 7.1 功能概述 两个I2C模块 支持Master/Slave模式 支持7bit/10bit地址 支持速率调整 支持DMA 7.2 使用说明 I2C Master有两种使用方式可以选择： 方法1：以blocking的方式操作I2C（读写操作完成后API才会返回），针对I2C Master读取外设的单一场景。 方法2：使用I2C中断操作I2C，需要在中断中操作读写的数据。 I2C Slave 则需要使用方法2，以中断方式操作。 7.2.1 方法1（blocking） 7.2.1.1 IO 配置 IO选择，并非所有IO都可以映射成I2C，请查看对应datasheet获取可用IO。 操作模块之前需要打开对应模块的时钟。使用SYSCTRL_ClearClkGateMulti()打开时钟。请查看下述代码示例，需要注意的是： SYSCTRL_ITEM_APB_I2C0对应I2C0，如果使用I2C1需要对应修改。 I2C IO需要配置为默认上拉，芯片内置上拉可以通过PINCTRL_Pull()实现（已经包含在PINCTRL_SelI2cIn()中）。实际应用中建议在外部实现上拉（可以获得更快的响应速度和时钟）。 将选定IO映射到I2C模块，两个IO均需要配置为双向（输入+输出）。请参考下述代码实现（PINCTRL_SelI2cIn()中包含了输入+输出的配置）。 以下示例可以将指定IO映射成I2C引脚： #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 void setup_peripherals_i2c_pin(void) { SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl)); PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); } 7.2.1.2 模块配置 参考：\\ING_SDK\\sdk\\src\\BSP\\iic.c 包含API： /** * @brief Init an I2C peripheral * * @param[in] port I2C peripheral ID */ void i2c_init(const i2c_port_t port); /** * @brief Write data to an I2C slave * * @param[in] port I2C peripheral ID * @param[in] addr address of the slave * @param[in] byte_data data to be written * @param[in] length data length * @return 0 if success else non-0 (e.g. time out) */ int i2c_write(const i2c_port_t port, uint8_t addr, const uint8_t *byte_data, int16_t length); /** * @brief Read data from an I2C slave * * @param[in] port I2C peripheral ID * @param[in] addr address of the slave * @param[in] write_data data to be written before reading * @param[in] write_len data length to be written before reading * @param[in] byte_data data to be read * @param[in] length data length to be read * @return 0 if success else non-0 (e.g. time out) */ int i2c_read(const i2c_port_t port, uint8_t addr, const uint8_t *write_data, int16_t write_len, uint8_t *byte_data, int16_t length); 使用方法： 配置IO。 初始化I2C模块： i2c_init(I2C_PORT_0); 写数据： i2c_write(I2C_PORT_0, ADDRESS, write_data, DATA_CNT); 当读操作完成后API才会返回，为了避免长时间等待ACK等意外情况，使用I2C_HW_TIME_OUT来控制blocking的时间。 读数据： i2c_read(I2C_PORT_0, ADDRESS, write_data, DATA_CNT, read_data, DATA_CNT); 如果write_data不为空，则会首先执行写操作，然后再执行读操作。 7.2.2 方法2（Interrupt） I2C Slave 以及 I2C Master方法2需要使用Interrupt方式。 7.2.2.1 IO 配置 IO选择，并非所有IO都可以映射成I2C，请查看对应datasheet获取可用IO。 操作模块之前需要打开对应模块的时钟。使用SYSCTRL_ClearClkGateMulti()打开时钟。请查看下述代码示例，需要注意的是： SYSCTRL_ITEM_APB_I2C0对应I2C0，如果使用I2C1需要对应修改。 I2C IO需要配置为默认上拉，芯片内置上拉，可以通过PINCTRL_Pull()实现（已经包含在PINCTRL_SelI2cIn()中）。实际应用中建议在外部实现上拉（可以获得更快的响应速度和时钟）。 将选定IO映射到I2C模块，两个IO均需要配置为双向（输入+输出）。请参考下述代码实现（PINCTRL_SelI2cIn()中包含了输入+输出的配置）。 如果需要使用中断，使用platform_set_irq_callback()配置应用中断。 以下示例可以将指定IO映射成I2C引脚，并配置了中断回调函数： #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 void setup_peripherals_i2c_pin(void) { SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl)); PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.2.2.2 模块初始化 I2C模块初始化需要通过以下API来实现： 通过I2C_Config()选择Master/Slave角色，以及I2C地址。 使用I2C_ConfigClkFrequency()更改时钟配置。 根据使用场景打开相应的中断I2C_IntEnable()： I2C_INT_CMPL：该中断的触发代表传输结束。 I2C_INT_FIFO_FULL：代表RX FIFO中有数据。 I2C_INT_FIFO_EMPTY：TX FIFO空，需要填充发送数据。 I2C_INT_ADDR_HIT: 总线上检测到了匹配的地址。 使能I2C模块I2C_Enable()。 7.2.2.3 触发传输 调用I2C_CtrlUpdateDirection()设置传输方向。 I2C_TRANSACTION_SLAVE2MASTER：Slave发送数据，Master读取数据。 I2C_TRANSACTION_MASTER2SLAVE：Master发送数据，Slave读取数据。 通过I2C_CtrlUpdateDataCnt()设置该次传输的数据大小，最大8个bit（256字节），以字节为单位。 使用I2C_CommandWrite()触发I2C传输： I2C_COMMAND_ISSUE_DATA_TRANSACTION： Master有效，触发数据传输。 I2C_COMMAND_RESPOND_ACK：在接收到的字节后发送一个ACK。 I2C_COMMAND_RESPOND_NACK：在接收到的字节后发送一个NACK。 I2C_COMMAND_CLEAR_FIFO：清空FIFO。 I2C_COMMAND_RESET：reset I2C模块。 7.2.2.4 中断配置 数据的读写需要在中断中进行。 在中断触发后，通过I2C_GetIntState()来读取中断状态。不同状态需要参考I2C_STATUS_xxx定义。 I2C_STATUS_FIFO_FULL：读取数据，并通过I2C_FifoEmpty()判断FIFO状态。 I2C_STATUS_FIFO_EMPTY： 填充数据，并通过I2C_FifoFull()判断FIFO状态。 I2C_STATUS_CMPL：一次传输数据结束，判断FIFO中是否有剩余数据并读取。 I2C_STATUS_ADDRHIT：地址匹配，在该中断中通过I2C_GetTransactionDir()判断传输的方向。 I2C_TRANSACTION_MASTER2SLAVE：代表Master发送，Slave则需要读取数据。 I2C_TRANSACTION_SLAVE2MASTER：代表Slave需要发送，Master读取数据。 FIFO相关中断不需要清除标志，其余中断需要通过I2C_ClearIntState()来清除标志，避免中断重复触发。 7.2.2.5 编程指南 7.2.2.5.1 场景1：Master只读，Slave只写，不使用DMA 其中I2C配置为Master读操作，Slave收到地址后，将数据返回给Master，CPU操作读写，没有使用DMA。 配置之前需要决定使用的IO，请参考IO 配置。 7.2.2.5.1.1 Master配置 测试数据，每次传输10个字节（FIFO深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (10) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 初始化I2C模块 此处配置为Master, 7bit地址，并打开了传输结束中断和FIFO FULL中断。 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_FULL)); } Master中断实现 中断中通过I2C_STATUS_FIFO_FULL来读取接收到的数据。当I2C_STATUS_CMPL触发时，当前传输结束，需要判断FIFO中有没有剩余数据。 static uint32_t peripherals_i2c_isr(void *user_data) { uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){ break; } read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } } if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } Master触发传输 首先需要设置传输方向，此处是I2C_TRANSACTION_SLAVE2MASTER，即代表Slave发送数据，Master读取数据。 void peripheral_i2c_send_data(void) { I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_SLAVE2MASTER); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 在需要时候触发I2C读取，peripheral_i2c_send_data()。 检查中断状态。 7.2.2.5.1.2 Slave配置 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (10) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 初始化I2C模块 对于Slave，需要打开I2C_INT_ADDR_HIT，此中断的触发代表收到了匹配的地址。 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } Slave中断实现以及发送数据 首先需要等待I2C_STATUS_ADDRHIT中断，在该中断中通过I2C_GetTransactionDir()判断传输的方向。 I2C_TRANSACTION_MASTER2SLAVE：代表Slave需要读取数据，打开I2C_INT_FIFO_FULL中断。 I2C_TRANSACTION_SLAVE2MASTER：代表Slave需要发送，打开I2C_INT_FIFO_EMPTY。 如果是Slave写操作，则会触发I2C_STATUS_FIFO_EMPTY中断，此时填写需要发送的数据，直到FIFO满。 等待I2C_STATUS_CMPL中断，该中断的触发代表传输结束，在中断中关闭打开的FIFO中断。 static uint32_t peripherals_i2c_isr(void *user_data) { static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){ break; } I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } } if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 使用流程： 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 检查中断状态，在中断中发送数据，I2C_STATUS_CMPL中断代表传输结束。 7.2.2.5.2 场景2：Master只写，Slave只读，不使用DMA 其中I2C配置为Master写操作，Slave收到地址后，将从Master读取数据，CPU操作读写，没有使用DMA。 配置之前需要决定使用的IO，请参考IO 配置。 7.2.2.5.2.1 Master配置 测试数据，每次传输10个字节（FIFO深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (10) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 初始化I2C模块 此处配置为Master, 7bit地址，并打开了传输结束中断和FIFO EMPTY中断。 I2C_INT_FIFO_EMPTY中断用来发送数据。 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } Master中断实现 中断中通过I2C_STATUS_FIFO_EMPTY来发送数据。每次填充FIFO直到FIFO为满，当填充完最后一个数据后，需要关掉I2C_INT_FIFO_EMPTY，否则中断会继续触发。 当I2C_STATUS_CMPL触发时，当前传输结束。 static uint32_t peripherals_i2c_isr(void *user_data) { uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){ break; } I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } // if its the last, disable empty int if(write_data_cnt == DATA_CNT) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } Master触发传输 首先需要设置传输方向，I2C_TRANSACTION_MASTER2SLAVE，即代表Master发送数据，Slave读取数据。 注意！！！中断发送数据完成后关闭了I2C_INT_FIFO_EMPTY（FIFO空）中断，如果需要开始新一次传输需要打开中断。 打开I2C_INT_FIFO_EMPTY：I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); void peripheral_i2c_send_data(void) { I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_MASTER2SLAVE); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 在需要时候发送I2C数据，peripheral_i2c_send_data()。 检查中断状态。 7.2.2.5.2.2 Slave配置 测试数据，每次传输10个字节（FIFO深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (10) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 初始化I2C模块 对于Slave，需要打开I2C_INT_ADDR_HIT，此中断的触发代表收到了匹配的地址。 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } Slave中断实现以及接收数据 首先需要等待I2C_STATUS_ADDRHIT中断，在该中断中通过I2C_GetTransactionDir()判断传输的方向。 I2C_TRANSACTION_MASTER2SLAVE：代表Slave需要读取数据，打开I2C_INT_FIFO_FULL中断。 I2C_TRANSACTION_SLAVE2MASTER：代表Slave需要发送，打开I2C_INT_FIFO_EMPTY。 I2C_STATUS_FIFO_FULL的触发，代表FIFO中有接收到的数据，读取数据，直到FIFO变空。 I2C_STATUS_CMPL代表传输结束，检查FIFO中有没有剩余数据，并且关掉FIFO中断避免再次触发。 static uint32_t peripherals_i2c_isr(void *user_data) { static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){ break; } read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } } if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { for(;read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 检查中断状态，I2C_STATUS_CMPL中断代表传输结束。 7.2.2.5.3 场景3：Master只读，Slave只写，使用DMA 其中I2C配置为Master读操作，Slave收到地址后，将数据返回给Master，DMA操作读写。 配置之前需要决定使用的IO，请参考IO 配置。 7.2.2.5.3.1 Master配置 测试数据，每次传输23个字节（FIFO深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (23) uint8_t read_data[DATA_CNT] = {0,}; 初始化I2C模块 此处配置为Master, 7bit地址，并打开了传输结束中断，由于使用DMA传输，因此不需要打开FIFO相关中断。其余配置和场景1相同。 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)); } 初始化DMA模块 使用前需要配置DMA模块。 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } Master中断实现 等待I2C_STATUS_CMPL中断的触发，该中断代表传输结束。 static uint32_t peripherals_i2c_isr(void *user_data) { uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } Master DMA设置 该API实现了I2C0 RXFIFO到DMA的配置，细节请参考DMA文档。 void peripherals_i2c_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_I2C0, size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } Master触发传输 打开I2C模块的DMA功能。 设置传输方向I2C_TRANSACTION_SLAVE2MASTER，与场景1相同。 设置需要传输的数据大小。 配置DMA，并使用I2C_COMMAND_ISSUE_DATA_TRANSACTION触发I2C传输。 void peripheral_i2c_send_data(void) { I2C_DmaEnable(APB_I2C0,1); I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_SLAVE2MASTER); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); #define I2C_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_i2c_rxfifo_to_dma(I2C_DMA_RX_CHANNEL, read_data, sizeof(read_data)); I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 初始化DMA，setup_peripherals_dma_module()。 在需要时候触发I2C读取，peripheral_i2c_send_data()。 检查中断状态。 7.2.2.5.3.2 Slave配置 测试数据，每次传输23个字节（FIFO深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (23) uint8_t write_data[DATA_CNT] = {0,}; 初始化I2C模块 对于Slave，需要打开I2C_INT_ADDR_HIT，此中断的触发代表收到了匹配的地址。 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 初始化DMA模块 使用前需要配置DMA模块。 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } Slave中断实现以及发送数据 首先需要等待I2C_STATUS_ADDRHIT中断，在该中断中通过I2C_GetTransactionDir()判断传输的方向。 I2C_TRANSACTION_SLAVE2MASTER：代表Slave需要发送，设置DMA发送数据。 I2C_STATUS_CMPL代表传输结束，关闭I2C DMA功能。 static uint32_t peripherals_i2c_isr(void *user_data) { static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_SLAVE2MASTER) { peripherals_i2c_write_data_dma_setup(); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_DmaEnable(APB_I2C0,0); I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } Slave发送数据以及DMA设置 该API实现了DMA传输数据到I2C0 FIFO的配置，细节请参考DMA文档。 void peripherals_i2c_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_I2C0, src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 设置DMA并打开I2C DMA功能。 void peripherals_i2c_write_data_dma_setup(void) { #define I2C_DMA_TX_CHANNEL (0)//DMA channel 0 peripherals_i2c_dma_to_txfifo(I2C_DMA_TX_CHANNEL, write_data, sizeof(write_data)); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); I2C_DmaEnable(APB_I2C0,1); } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 初始化DMA，setup_peripherals_dma_module()。 检查中断状态，在中断中设置DMA发送数据，I2C_STATUS_CMPL中断代表传输结束。 7.2.2.5.4 场景4：Master只写，Slave只读，使用DMA 其中I2C配置为Master写操作，Slave收到地址后，读取Master发送的数据，DMA操作读写。 配置之前需要决定使用的IO，请参考IO 配置。 7.2.2.5.4.1 Master配置 测试数据，每次传输23个字节（FIFO深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (23) uint8_t write_data[DATA_CNT] = {0,}; 初始化I2C模块 请参考场景3中Master配置的初始化I2C模块。 初始化DMA模块 请参考场景3中Master配置的初始化DMA模块。 I2C中断实现 请参考场景3中Master配置的Master中断实现。 I2C Master DMA设置 该API实现了DMA传输数据到I2C0 FIFO的配置，细节请参考DMA文档。 void peripherals_i2c_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_I2C0, src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } I2C Master触发传输 打开I2C DMA 功能。 设置传输方向为I2C_TRANSACTION_MASTER2SLAVE，和场景2相同。 配置DMA，并使用I2C_COMMAND_ISSUE_DATA_TRANSACTION触发I2C传输。 void peripheral_i2c_send_data(void) { I2C_DmaEnable(APB_I2C0,1); I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_MASTER2SLAVE); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); #define I2C_DMA_TX_CHANNEL (0)//DMA channel 0 peripherals_i2c_dma_to_txfifo(I2C_DMA_TX_CHANNEL, write_data, sizeof(write_data)); I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 初始化DMA，setup_peripherals_dma_module()。 在需要时候触发I2C读取，peripheral_i2c_send_data()。 检查中断状态。 7.2.2.5.4.2 Slave配置 测试数据，每次传输23个字节（FIFO深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (23) uint8_t read_data[DATA_CNT] = {0,}; 初始化I2C模块 请参考场景3中Slave配置的初始化I2C模块。 初始化DMA模块 请参考场景3中Slave配置的初始化DMA模块。 Slave中断实现以及接收数据 首先需要等待I2C_STATUS_ADDRHIT中断，在该中断中通过I2C_GetTransactionDir()判断传输的方向。 I2C_TRANSACTION_MASTER2SLAVE：代表Slave需要接收，设置DMA接收数据。 I2C_STATUS_CMPL代表传输结束，关闭I2C DMA功能。 static uint32_t peripherals_i2c_isr(void *user_data) { static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { peripherals_i2c_read_data_dma_setup(); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_DmaEnable(APB_I2C0,0); I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } Slave 发送数据以及DMA设置 该API实现了I2C0 RXFIFO到DMA的配置，细节请参考DMA文档。 void peripherals_i2c_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_I2C0, size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 设置DMA并打开I2C DMA功能。 void peripherals_i2c_read_data_dma_setup(void) { #define I2C_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_i2c_rxfifo_to_dma(I2C_DMA_RX_CHANNEL, read_data, sizeof(read_data)); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); I2C_DmaEnable(APB_I2C0,1); } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 初始化DMA，setup_peripherals_dma_module()。 检查中断状态，在中断中设置DMA读取数据，I2C_STATUS_CMPL中断代表传输结束。 7.2.2.5.5 场景5：Master/Slave同时读写 其中I2C操作为，首先执行写操作然后再执行读操作，CPU操作读写，没有使用DMA。 配置之前需要决定使用的IO，请参考IO 配置。 7.2.2.5.5.1 Master配置 测试数据，每次传输8个字节（FIFO深度是8字节），每个传输单元必须是1字节。 #define DATA_CNT (8) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 初始化I2C模块 配置为Master, 7bit地址。 打开传输结束中断和ADDR_HIT中断。对于Master来说，如果有Slave响应了该地址，则会有I2C_INT_ADDR_HIT中断。 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1&lt;&lt;I2C_INT_ADDR_HIT)); } Master中断实现 I2C_STATUS_ADDRHIT，代表Slave响应了Master发送的地址: 如果Master执行写操作，需要打开I2C_INT_FIFO_EMPTY，用来发送数据。 如果Master执行读操作，需要打开I2C_INT_FIFO_FULL，用来接收数据。 如果Master执行写操作，I2C_STATUS_FIFO_EMPTY中断会出现，此时需要填充待发送的数据。如果数据发送完成，需要关闭I2C_STATUS_FIFO_EMPTY中断，避免重复触发。 如果Master执行读操作，I2C_STATUS_FIFO_FULL中断会出现，此时需要读取数据。 I2C_STATUS_CMPL，代表传输结束： 如果Master执行写操作，代表写成功。 如果Master执行读操作，需要读取FIFO中的剩余数据。 uint8_t master_write_flag = 0; static uint32_t peripherals_i2c_isr(void *user_data) { uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { if(master_write_flag) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } else { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_FULL)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { if(master_write_flag) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){ break; } I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } // if its the last, disable empty int if(write_data_cnt == DATA_CNT) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } } if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { if(!master_write_flag) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){ break; } read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } } } // 传输结束中断，代表DATA_CNT个字节接收或者发射完成 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { if(master_write_flag) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } else { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next } } return 0; } Master写传输 首先需要设置传输方向，I2C_TRANSACTION_MASTER2SLAVE，即代表Master发送数据，Slave读取数据。 void peripheral_i2c_write_data(void) { master_write_flag = 1; //write data use fifo empty Interrupt,so disable I2C_INT_FIFO_FULL,enable I2C_INT_FIFO_EMPTY. I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_MASTER2SLAVE); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } Master读传输 首先需要设置传输方向，此处是I2C_TRANSACTION_SLAVE2MASTER，即代表Slave发送数据，Master读取数据。 void peripheral_i2c_read_data(void) { master_write_flag = 0; //read data use fifo full Interrupt,so disable I2C_INT_FIFO_EMPTY,enable I2C_INT_FIFO_FULL. I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_SLAVE2MASTER); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 在需要时候触发I2C写数据，peripheral_i2c_write_data()。 当写结束后，可以触发I2C读取，peripheral_i2c_read_data()。 检查中断状态。 7.2.2.5.5.2 Slave配置 初始化I2C模块 配置为Slave, 7bit地址。 打开传输结束中断和ADDR_HIT中断。对于Slave来说，如果有匹配的地址，则会有I2C_INT_ADDR_HIT中断。 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } Slave中断实现 I2C_STATUS_ADDRHIT，在该中断中通过I2C_GetTransactionDir()判断传输的方向: I2C_TRANSACTION_MASTER2SLAVE：代表Slave需要读取数据，打开I2C_INT_FIFO_FULL中断。 I2C_TRANSACTION_SLAVE2MASTER：代表Slave需要发送，打开I2C_INT_FIFO_EMPTY。 如果Slave需要发送，I2C_STATUS_FIFO_EMPTY中断会出现，此时需要填充待发送的数据。 如果Slave需要读取数据，I2C_STATUS_FIFO_FULL中断会出现，此时需要读取数据。 I2C_STATUS_CMPL，代表传输结束： 如果Slave执行写操作，代表写成功，关闭I2C_STATUS_FIFO_EMPTY中断。 如果Slave执行读操作，需要读取FIFO中的剩余数据，关闭I2C_STATUS_FIFO_FULL中断。 static uint32_t peripherals_i2c_isr(void *user_data) { static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { master_write_flag = 1; I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { master_write_flag = 0; I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { // master read if(!master_write_flag) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){break;} I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } } } if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { // master write if(master_write_flag) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){break;} read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } } } if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { if(master_write_flag) { for(;read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } else { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 使用流程 设置IO，setup_peripherals_i2c_pin()。 初始化I2C，setup_peripherals_i2c_module()。 检查中断状态，在中断中发送数据，I2C_STATUS_CMPL中断代表传输结束。 如果是读操作，slave应该在master_write_flag=0之后准备好数据写到FIFO。 7.2.3 时钟配置 I2C时钟配置使用API： /** * @brief Set clk frequency for controller. * @param[in] I2C_BASE base address * @param[in] option see I2C_ClockFrequenyOptions */ void I2C_ConfigClkFrequency(I2C_TypeDef *I2C_BASE, I2C_ClockFrequenyOptions option); 其中option中定义了几个可选项（I2C时钟和系统时钟有关系，以下枚举可能需要根据实际时钟调整）: typedef enum { I2C_CLOCKFREQUENY_NULL, I2C_CLOCKFREQUENY_STANDARD,//up to 100kbit/s I2C_CLOCKFREQUENY_FASTMODE,//up to 400kbit/s I2C_CLOCKFREQUENY_FASTMODE_PLUS,//up to 1Mbit/s I2C_CLOCKFREQUENY_MANUAL } I2C_ClockFrequenyOptions; 如果选择MANUAL,需要手动配置相关寄存器来生成需要的时钟: I2C_BASE-&gt;TPM : 乘数因子, 位宽5bit, 所有I2C_BASE-&gt;Setup中的时间参数都会被乘以（TPM+1）。 I2C_BASE-&gt;Setup: 使用I2C_ConfigSCLTiming()配置该寄存器，参数如下： scl_hi：高电平持续时间，位宽 9bit，默认 0x10。 scl_ratio: 低电平持续时间因子，位宽 1bit，默认 1。 hddat：SCL拉低后SDA的保持时间，位宽 5bit，默认 5。 sp: 可以被过滤的脉冲毛刺宽度，位宽 3bit，默认 1。 sudat: 释放SCL之前的数据建立时间，位宽 5bit，默认 5。 每个参数和时钟的计算关系如下： 高电平持续时间计算： \\(SCL high period = (2\\times pclk)+(2+sp+sclhi)\\times pclk\\times(TPM+1)\\) 其中\\(pclk\\)为I2C模块的系统时钟，默认为24M，实际时钟可以从SYSCTRL_GetClk()获取。 如果\\(sp = 1, pclk = 42ns, TPM = 3, sclhi = 150\\) ，则： \\(SCL high period = (2\\times42)+(2+1+150)\\times42\\times(3+1) = 25788ns\\) 低电平持续时间计算： \\(SCL low period = (2\\times pclk)+(2+sp+sclhi\\times (sclratio+1))\\times pclk\\times (TPM+1)\\) 如果\\(sp = 1, pclk = 42ns, TPM = 3, sclhi = 150, sclratio = 0\\)，则： \\(SCL low period = (2\\times42)+(2+1+150\\times1)\\times42\\times(3 + 1) = 25788ns\\) 毛刺抑制宽度： \\(spike suppression width = sp\\times pclk\\times (TPM+1)\\) 如果\\(sp = 1, pclk = 42ns, TPM = 3\\)，则： \\(spike suppression width = 1\\times42\\times(3+1) = 168ns\\) SCL之前的数据建立时间： \\(setup time = (2\\times pclk)+(2+sp+sudat)\\times pclk\\times (TPM+1)\\) 如果\\(sp = 1, pclk = 42ns, TPM = 3, sudat = 5\\)，则： \\(setup time = (2\\times42)+(2+1+5)\\times42\\times(3+1) = 1428ns\\) 协议对SCL之前的数据建立时间要求为： - standard mode: 最小250ns。 - fast mode: 最小100ns。 - fast mode plus: 最小50ns。 SCL拉低后SDA的保持时间： \\(hold time = (2\\times pclk)+(2+sp+hddat)\\times pclk\\times (TPM+1)\\) 如果\\(sp = 1, pclk = 42ns, TPM = 3, hddat = 5\\)，则: \\(hold time = (2\\times 42)+(2+1+5)\\times 42\\times(3+1) = 1428ns\\) 协议对SCL拉低后SDA的保持时间要求为： - standard mode: 最小300ns。 - fast mode: 最小300ns。 - fast mode plus: 最小0ns。 "],["ch-I2S.html", "8 I2S简介 8.1 功能描述 8.2 使用方法 8.3 编程指南", " 8 I2S简介 I2S（inter-IC sound）总线是数字音频专用总线。它有四个引脚，两个数据引脚(DOUT和DIN)，一个位率时钟引脚(BCLK)和一个左右通道选择引脚(LRCLK)。 另外，通过ING20的MCLK输出，它可用于给外部 DAC/ADC 芯片提供时钟（可选）。 8.1 功能描述 8.1.1 特点 遵从 I2S 协议标准，支持12S标准模式和左对齐模式 支持PCM(脉冲编码调制)时序 可编程的主从模式 可配置的LRCLK和BCLK极性 可配置数据位宽 独立发送和接收FIFO TX和RX的FIFO深度分别为8*32bit 支持立体声和单声道模式 可配置的采样频率 TX和RX分别支持DMA搬运 8.1.2 I2S角色 在 I2S 总线上，提供时钟和通道选择信号的器件是 MASTER，另一方则为 SLAVER。 MASTER和SLAVE都可以进行数据收发。 8.1.3 I2S工作模式 I2S 有两种工作模式：一种是立体声音频模式，另外一种是话音模式。 8.1.4 串行数据 串行数据是以高位（MSB）在前，低位（LSB）在后的方式进行传送的。 如果音频codec发送的位数多于I2S控制器的接收位数，I2S控制器会将低位多余的位数忽略掉； 如果音频codec发送的位数小于I2S控制器接收位数，I2S控制器将后面的位补零。 8.1.5 时钟分频 20芯片可选用系统24MHz时钟或者PLL作为I2S时钟源。 位率时钟（BCLK）可以通过对功能时钟进行分频得到； 通道选择时钟（LRCLK）即音频数据的采样频率可以通过对BCLK进行分频得到。 音频 Codec 中对采样频率 LRCLK 要求精度比较高，我们在计算分频时应该首先根据不同的采样频率计算得到对应的 MCLK 和 BCLK。 8.1.5.1 时钟分频计算 计算示例： 假设当前codec采用16K采样频率，mic要求一帧64位（参考具体的mic使用手册）。 有以下关系： f_bclk = clk/(2*b_div) f_lrclk = f_bclk/(2*lr_div) 其中clk为codec时钟，f_bclk、f_lrclk分别为BCLK和LRCLK，b_div、lr_div分别为BCLK和LRCLK的分频系数。 BCLK和LRCLK之间的关系是可变的，但是BCLK必须大于等于LRCLK的48倍。即lr_div&gt;=24。 支持lr_div = 32，DATA_LEN = 32位的配置，其他情况下lr_div - DATA_LEN &gt; 3。 通过f_lrclk = 16000，lr_div = 32计算出f_bclk = 1.024MHz。也就是clk = 2.048*b_div。 clk通过时钟源分频得到必定是整数，b_div也同样是整数，通过计算得知在384MHz内只有当b_div = 125时clk = 256MHz为整数。 故需要将PLL时钟配置为256MHz，b_div = 125可以得到16K采样率。 8.1.6 I2S存储器 采用两个深度为8，宽度为32bit的FIFO分别存储接收、发送的音频数据。 有如下规则： 音频数据位宽为16bit时，每32bit存储两个音频数据，高16bit存储左声道数据，低16bit存储右声道数据。 音频数据位宽大于16bit时，每32bit存储一个音频数据，低地址存储左声道数据，高地址存储右声道数据。 8.2 使用方法 8.2.1 方法概述 I2S使用方法总结为：时钟配置，I2S配置（包括采样率）和数据处理。 数据发送： 1. I2S引脚GPIO配置 2. 配置外部 codec 芯片，使其处于工作模式 3. 写相应配置寄存器 4. 将数据写入TX_MEM 5. 使能I2S 6. 等待中断产生 7. 读取状态寄存器，将数据写入TX_MEM 8. 传输完毕，关闭 I2S 数据接收： 1. I2S引脚GPIO配置 2. 配置外部 codec 芯片，使其处于工作模式 3. 写相应配置寄存器 4. 使能I2S 5. 等待中断产生 6. 读取状态寄存器，读取 RX_MEM 中数据 7. 传输完毕，关闭 I2S I2S控制器操作流程图如下： 图 8.1: I2S控制器操作流程图 如果需要用到DMA搬运则需要在使能I2S之前配置DMA并使能。 8.2.2 注意点 I2S时钟源可以选择晶振24M时钟和PLL时钟，要注意是选择哪一个时钟源 I2S数据可能会进行采样，需要注意具体的数据结构以及对应的数据处理，如是否需要数据移位等 当前I2S支持的发送/接收数据位宽为16-32bit，需要查阅mic文档或其他使用手册来确定数据位宽，否则不能正常工作 配置DMA要在使能I2S之前完成，使能I2S一定是最后一步 建议采用DMA乒乓搬运的方式来传输I2S数据 8.3 编程指南 8.3.1 驱动接口 I2S_ConfigClk：I2S时钟配置接口 I2S_Config：I2S配置接口 I2S_ConfigIRQ：I2S中断配置接口 I2S_DMAEnable：I2S DMA使能接口 I2S_Enable：I2S使能接口 I2S_PopRxFIFO、I2S_PushTxFIFO：I2S FIFO读写接口 I2S_ClearRxFIFO、I2S_ClearTxFIFO：I2S清FIFO接口 I2S_GetIntState、I2S_ClearIntState：I2S获取中断、清中断接口 I2S_GetRxFIFOCount、I2S_GetTxFIFOCount：I2S获取FIFO数据数量接口 I2S_DataFromPDM：I2S获取PDM数据接口 8.3.2 代码示例 下面将通过实际代码展示I2S的基本配置及使用代码。 8.3.2.1 I2S配置 #define I2S_PIN_BCLK 21 #define I2S_PIN_IN 22 #define I2S_PIN_LRCLK 35 void I2sSetup(void) { // pinctrl &amp; GPIO mux PINCTRL_SetPadMux(I2S_PIN_BCLK, IO_SOURCE_I2S_BCLK_OUT); PINCTRL_SetPadMux(I2S_PIN_IN, IO_SOURCE_I2S_DATA_IN); PINCTRL_SelI2sIn(IO_NOT_A_PIN, IO_NOT_A_PIN, I2S_PIN_IN); PINCTRL_SetPadMux(I2S_PIN_LRCLK, IO_SOURCE_I2S_LRCLK_OUT); PINCTRL_Pull(I2S_PIN_IN, PINCTRL_PULL_DOWN); // CLK &amp; Register SYSCTRL_ConfigPLLClk(6, 128, 2); // sorce clk PLL = 256MHz SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_1 + 4); // I2s_Clk = 51.2MHz I2S_ConfigClk(APB_I2S, 25, 32); // F_bclk = 1.024MHz, F_lrclk = 16K I2S_ConfigIRQ(APB_I2S, 0, 1, 0, 10); I2S_DMAEnable(APB_I2S, 0, 0); I2S_Config(APB_I2S, I2S_ROLE_MASTER, I2S_MODE_STANDARD, 0, 0, 0, 1, 24); // I2s interrupt platform_set_irq_callback(PLATFORM_CB_IRQ_I2S, cb_isr, 0); } 8.3.2.2 I2S使能 I2S使能分3种情况：I2S发送、I2S接收、使用DMA搬运 接收： void I2sStart(void) { I2S_ClearRxFIFO(APB_I2S); I2S_Enable(APB_I2S, 0, 1); } 发送： uint8_t sendSize = 10; uint32_t sendData[10]; void I2sStart(void) { int i; I2S_ClearTxFIFO(APB_I2S); // push data into TX_FIFO first for (i = 0; i &lt; sendSize; i++) { I2S_PushTxFIFO(APB_I2S, sendData[i]); } I2S_Enable(APB_I2S, 0, 1); } 使用DMA（接收）： #define CHANNEL_ID 0 DMA_Descriptor test __attribute__((aligned (8))); void I2sStart(uint32_t data) { DMA_EnableChannel(CHANNEL_ID, &amp;test); I2S_ClearRxFIFO(APB_I2S); I2S_DMAEnable(APB_I2S, 1, 1); I2S_Enable(APB_I2S, 0, 1); } 无论哪种情况都必须最后一步使能I2S，否则I2S工作异常。 8.3.2.3 I2S中断 接收： uint32_t cb_isr(void *user_data) { uint32_t state = I2S_GetIntState(APB_I2S); I2S_ClearIntState(APB_I2S, state); int i = I2S_GetRxFIFOCount(APB_I2S); while (i) { uint32_t data = I2S_PopRxFIFO(APB_I2S); i--; // do something with data } return 0; } 发送： uint8_t sendSize = 10; uint32_t sendData[10]; uint32_t cb_isr(void *user_data) { uint32_t state = I2S_GetIntState(APB_I2S); I2S_ClearIntState(APB_I2S, state); int i; for (i = 0; i &lt; sendSize; i++) { I2S_PushTxFIFO(APB_I2S, sendData[i]); } return 0; } 8.3.2.4 I2S &amp; DMA乒乓搬运 下面以经典的DMA乒乓搬运I2S接收数据为例展示I2S实际使用方法。 这里我们采用16K采样率，单个数据帧固定64位，和DMA协商握手、burstSize=8、一次搬运80个数据。 #include &quot;pingpong.h&quot; #define I2S_PIN_BCLK 21 #define I2S_PIN_IN 22 #define I2S_PIN_LRCLK 35 #define CHANNEL_ID 0 DMA_PingPong_t PingPong; static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); uint32_t *rr = DMA_PingPongIntProc(&amp;PingPong, CHANNEL_ID); uint32_t i = 0; uint32_t transSize = DMA_PingPongGetTransSize(&amp;PingPong); while (i &lt; transSize) { // do something with data &#39;rr[i]&#39; i++; } return 0; } void I2sSetup(void) { // pinctrl &amp; GPIO mux PINCTRL_SetPadMux(I2S_PIN_BCLK, IO_SOURCE_I2S_BCLK_OUT); PINCTRL_SetPadMux(I2S_PIN_IN, IO_SOURCE_I2S_DATA_IN); PINCTRL_SelI2sIn(IO_NOT_A_PIN, IO_NOT_A_PIN, I2S_PIN_IN); PINCTRL_SetPadMux(I2S_PIN_LRCLK, IO_SOURCE_I2S_LRCLK_OUT); PINCTRL_Pull(I2S_PIN_IN, PINCTRL_PULL_DOWN); // CLK &amp; Register SYSCTRL_ConfigPLLClk(6, 128, 2); // sorce clk PLL = 256MHz SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_1 + 4); // I2s_Clk = 51.2MHz I2S_ConfigClk(APB_I2S, 25, 32); // F_bclk = 1.024MHz, F_lrclk = 16K I2S_ConfigIRQ(APB_I2S, 0, 1, 0, 8); I2S_DMAEnable(APB_I2S, 0, 0); I2S_Config(APB_I2S, I2S_ROLE_MASTER, I2S_MODE_STANDARD, 0, 0, 0, 1, 24); // setup DMA DMA_PingPongSetup(&amp;PingPong, SYSCTRL_DMA_I2S_RX, 100, 8); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); // start working DMA_PingPongEnable(&amp;PingPong, CHANNEL_ID); I2S_ClearRxFIFO(APB_I2S); I2S_DMAEnable(APB_I2S, 1, 1); I2S_Enable(APB_I2S, 0, 1); } DMA（乒乓搬运）的具体用法请参见本手册DMA一节。 更加系统化的I2S代码请参考SDK中voice_remote_ctrl例程。 "],["ch-keyscan.html", "9 硬件键盘扫描控制器（KEYSCAN） 9.1 功能概述 9.2 使用说明 9.3 应用举例", " 9 硬件键盘扫描控制器（KEYSCAN） 9.1 功能概述 9.1.1 特性： 标准模式可配置矩阵，最大支持8行*22列的键盘矩阵。 每个io支持额外的两个独立按键扫描。 LPkey模式可配置三角阵列，最大支持16个COL连接共 y*(y-1)/2+2(x+y) 按键 标准模式支持table（按键变化才产生中断）模式 每个单独的行或者列可以设置启用或者禁用。 可配置时钟。 支持输入硬件去抖动，去抖时间可配置。 支持配置扫描间隔和释放时间，支持多按键同时按下。 支持中断和DMA。 9.1.2 功能简述 keyscan模块支持DMA，fifo最大深度32，按键扫描支持标准和lpkey两种工作模式，其中标准模式支持table（按键按下上报变化）模式，Keyscan还提供了去抖功能，为输入过滤掉毛刺。该功能可以针对每个通道单独启用。过滤时间可单独配置。 #### 标准模式 keyscan标准模式支持x*y+2(x+y)个按键布局（x：列扫描，最高支持8列。 y：行扫描，最高支持22行）。支持的键盘扫描排列如下图所示： 在标准模式下，keyscan模块会根据设定的扫描周期loop值（扫描周期和loop配置以及模块输入时钟相关）周期触发keyscan的按键扫描任务并将扫描到的键值压入FIFO，在keyscan的运行过程中，扫描流程如下。 标准扫描模式支持使能table模式，不需要手动获取fifo的数值并进行软件比对，硬件可以自动和上一次的采样结果进行比对，触发中断给出变化的键值。 9.1.3 LPkey模式 Lpkey模式支持y*(y-1)/2+2(x+y)个按键布局（x：列扫描，最高支持8列。 y：行扫描，最高支持22行）。支持的键盘扫描排列如下图所示： LPkey模式提供了以更少的io数量扩展更多扫描矩阵的一种方式，相比普通模式，相同的io数量可扫描的按键数量更多，适用于小封装或io数量受限的应用场景。 Lpkey模式不支持键值比较的（table）模式，扫描流程和标准模式相同。通过DMA或直接读取fifo的方式获取周期扫描按键值。判断按键是否触发。 9.2 使用说明 以4行*4列的键盘矩阵为例： 9.2.1 键盘矩阵的软件描述 typedef struct { KEYSCAN_InColIndex_t in_col; GIO_Index_t gpio; } KEYSCAN_InColList; typedef struct { KEYSCAN_OutRowIndex_t out_row; GIO_Index_t gpio; } KEYSCAN_OutRowList; KEYSCAN_OutRowList key_out_row[] = { {KEY_OUT_ROW_6, GIO_GPIO_30}, // 第1行 {KEY_OUT_ROW_7, GIO_GPIO_31}, // 第2行 {KEY_OUT_ROW_5, GIO_GPIO_29}, // 第3行 {KEY_OUT_ROW_0, GIO_GPIO_32}, // 第4行 }; #define key_out_row_num (sizeof(key_out_row) / sizeof(key_out_row[0])) KEYSCAN_InColList key_in_col[] = { {KEY_IN_COL_11, GIO_GPIO_11}, // 第1列 {KEY_IN_COL_12, GIO_GPIO_12}, // 第2列 {KEY_IN_COL_13, GIO_GPIO_13}, // 第3列 {KEY_IN_COL_14, GIO_GPIO_14}, // 第4列 }; #define key_in_col_num (sizeof(key_in_col) / sizeof(key_in_col[0])) 第1行按键接到了GPIO30，映射到KEYSCAN模块的ROW6。第1列按键接到了GPIO11，映射到KEYSCAN模块的COL11。以此类推4行4列的键盘阵列。 注意：KEYSCAN的ROW和COL不是随意映射到GPIO，映射关系参考管脚管理（PINCTRL）说明文档。 9.2.2 KEYSCAN模块初始化 typedef struct { KEYSCAN_InColList *col; int col_num; KEYSCAN_OutRowList *row; int row_num; uint8_t fifo_num_trig_int; uint8_t dma_num_trig_int; uint8_t loop_num_trig_int; uint8_t dma_en; uint8_t int_trig_en; uint8_t int_loop_en; uint16_t release_time; uint16_t scan_interval; uint8_t debounce_counter; #if (INGCHIPS_FAMILY == INGCHIPS_FAMILY_20) uint8_t table_mode_en; uint8_t lpkey_mode_en; #endif } KEYSCAN_SetStateStruct; /** * @brief Initialize keyscan module * * @param[in] keyscan_set Initial parameter struct * @return 0 if success else non-0 */ int KEYSCAN_Initialize(const KEYSCAN_SetStateStruct* keyscan_set); /** * @brief Initialize mapping table of keyboard array row and col * * @param[in] keyscan_set Initial parameter struct * @param[out] ctx keyboard array mapping table */ void KEYSCAN_InitKeyScanToIdx(const KEYSCAN_SetStateStruct* keyscan_set, KEYSCAN_Ctx *ctx); 9.2.3 获取扫描到的按键 KEYSCAN模块使能扫描后会按照行和列的配置开始扫描。模块有FIFO缓存扫描数据。每次扫描循环结束，FIFO中压入1个0x400标志完成一次扫描。 可以配置FIFO中数据个数触发中断或者DMA触发中断： void KEYSCAN_SetFifoNumTrigInt(uint32_t trig_num); void KEYSCAN_SetDmaNumTrigInt(uint32_t trig_num); 获取FIFO是否为空的状态和数据： /** * @brief Check keyscan FIFO empty or not * * @return 0: FIFO have data; 1: empty */ uint8_t KEYSCAN_GetIntStateFifoEmptyRaw(void); /** * @brief GET keyscan FIFO data * * @return 0~4 bits: col; 5~9 bits: row; 10 bit: scan cycle end flag */ uint16_t KEYSCAN_GetKeyData(void); 按键FIFO原始数据的0~4位是按下按键所在的KEYSCAN模块中的col，5~9位是row，注意这个值并不是键盘矩阵中的行和列，可以用下面接口将原始数据解析为键盘矩阵中的行和列： /** * @brief Transfer keyscan FIFO raw data to keyboard array row and col * * To use this helper function, `ctx` must be initialized with `KEYSCAN_InitKeyScanToIdx`. * * @param[in] ctx keyboard array mapping table * @param[in] key_data keyscan FIFO raw data * @param[out] row pressed key&#39;s 0-based row index in keyboard array * @param[out] col pressed key&#39;s 0-based col index in keyboard array * @return 0: scan cycle end data; * 1: find key pressed, *row and *col are key positions in keyboard array */ uint8_t KEYSCAN_KeyDataToRowColIdx(const KEYSCAN_Ctx *ctx, uint32_t key_data, uint8_t *row, uint8_t *col); 9.3 应用举例 9.3.1 初始化KEYSCAN模块 KEYSCAN_OutRowList key_out_row[] = { {KEY_OUT_ROW_6, GIO_GPIO_32}, // 第1行 {KEY_OUT_ROW_7, GIO_GPIO_33}, // 第2行 {KEY_OUT_ROW_5, GIO_GPIO_31}, // 第3行 {KEY_OUT_ROW_0, GIO_GPIO_23}, // 第4行 }; #define key_out_row_num (sizeof(key_out_row) / sizeof(key_out_row[0])) KEYSCAN_InColList key_in_col[] = { {KEY_IN_COL_11, GIO_GPIO_11}, // 第1列 {KEY_IN_COL_12, GIO_GPIO_12}, // 第2列 {KEY_IN_COL_13, GIO_GPIO_13}, // 第3列 {KEY_IN_COL_14, GIO_GPIO_14}, // 第4列 }; #define key_in_col_num (sizeof(key_in_col) / sizeof(key_in_col[0])) static KEYSCAN_Ctx key_ctx = {0}; static KEYSCAN_SetStateStruct keyscan_set = { .col = key_in_col, .col_num = key_in_col_num, .row = key_out_row, .row_num = key_out_row_num, .loop_num_trig_int = 1, .int_loop_en = 0, .table_mode_en = 0, // 使用table模式时，使能该结构体变量 .fifo_num_trig_int = 1, .release_time = 0x1ff, .scan_interval = 0xfff, .debounce_counter = 0xff, .dma_num_trig_int = 0x10, .dma_en = 0, .int_trig_en = 1, .lpkey_mode_en = 0, }; static uint32_t keyscan_cb_isr(void *user_data); static void setup_peripherals_keyscan(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ITEM_APB_KeyScan); SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl); KEYSCAN_Initialize(&amp;keyscan_set); KEYSCAN_InitKeyScanToIdx(&amp;keyscan_set, &amp;key_ctx); platform_set_irq_callback(PLATFORM_CB_IRQ_KEYSCAN, keyscan_cb_isr, 0); return; } 9.3.2 中断数据处理 9.3.2.1 标准模式 static uint8_t key_state_buf[2][key_out_row_num][key_in_col_num] = {0}; static uint8_t key_state_last_index = 0; static uint8_t key_state_now_index = 1; static void printf_key_state(void) { int row, col; for (row = 0; row &lt; key_out_row_num; row++) { for (col = 0; col &lt; key_in_col_num; col++) { if (key_state_buf[key_state_now_index][row][col] != key_state_buf[key_state_last_index][row][col]) { printf(&quot;row%u col%u %s\\r\\n&quot;, row + 1, col + 1, key_state_buf[key_state_now_index][row][col] == 0 ? &quot;release&quot; : &quot;press&quot;); } } } if (key_state_now_index == 0) { key_state_now_index = 1; key_state_last_index = 0; } else { key_state_now_index = 0; key_state_last_index = 1; } for (row = 0; row &lt; key_out_row_num; row++) { for (col = 0; col &lt; key_in_col_num; col++) { key_state_buf[key_state_now_index][row][col] = 0; } } return; } static void key_state_clear(void) { int row, col; for (row = 0; row &lt; key_out_row_num; row++) { for (col = 0; col &lt; key_in_col_num; col++) { key_state_buf[0][row][col] = 0; key_state_buf[1][row][col] = 0; } } } static uint32_t keyscan_cb_isr(void *user_data) { uint32_t key_data; uint8_t key_scan_row; uint8_t key_scan_col; uint8_t row = 0; uint8_t col = 0; static uint8_t have_key_pressed = 0; static uint8_t no_key_pressed_cnt = 0; while (KEYSCAN_GetIntStateFifoEmptyRaw() == 0) { key_data = KEYSCAN_GetKeyData(); if (KEYSCAN_KeyDataToRowColIdx(&amp;key_ctx, key_data, &amp;row, &amp;col)) { // 扫描到有按键按下 按键位置为 row col key_state_buf[key_state_now_index][row][col] = 1; have_key_pressed = 1; } else { // 完成一次扫描 根据have_key_pressed判断该轮扫描中是否有按键按下 if (have_key_pressed == 1) { have_key_pressed = 0; no_key_pressed_cnt = 0; } else { } switch (no_key_pressed_cnt) { case 0: // 该轮扫描中有按键按下 no_key_pressed_cnt++; printf_key_state(); break; case 1: // 该轮扫描中没有按键按下 上一轮扫描中有按键按下 说明按键释放 no_key_pressed_cnt++; printf_key_state(); key_state_clear(); break; case 2: // 连续两轮或以上都没有按键按下 break; default: break; } } } return 0; } 9.3.2.2 Table 模式 static uint32_t keyscan_cb_isr(void *user_data) { uint32_t key_data; KEYSCAN_ScanMode_t scan_mode; uint8_t key_scan_row; uint8_t key_scan_col; uint8_t row = 0; uint8_t col = 0; while (KEYSCAN_GetIntStateFifoEmptyRaw() == 0) { key_data = KEYSCAN_GetKeyData(); if(KEYSCAN_GetScanMode(1,&amp;scan_mode,key_data)) { KEYSCAN_KeyDataToRowColIdx(&amp;key_ctx, key_data, &amp;row, &amp;col); print(&quot;row = %d, col = %d\\n&quot;, row, col); } } } "],["ch-pinctrl.html", "10 管脚管理（PINCTRL） 10.1 功能概述 10.2 使用说明", " 10 管脚管理（PINCTRL） 10.1 功能概述 PINCTRL 模块管理芯片所有 IO 管脚的功能，包括外设 IO 的映射，上拉、下拉选择，输入模式控制， 输出驱动能力设置等。 每个 IO 管脚都可以配置为数字或模拟模式，当配置为数字模式时，特性如下： 每个 IO 管脚可以映射多种不同功能的外设 每个 IO 管脚都支持上拉或下拉 每个 IO 管脚都支持施密特触发输入方式 每个 IO 管脚支持四种输出驱动能力 鉴于片内外设丰富、IO 管脚多，进行管脚全映射并不现实，为此，PINCTRL 尽量保证灵活性的前提下做了一定取舍、优化。 部分常用外设的输入、输出功能管脚可与 \\(\\{{0 .. 22\\}}\\) 这 23 个常用 IO 之间任意连接（全映射）， 这部分常用外设功能管脚总结于表 10.1。 表 10.2 列出了其它外设功能管脚支持映射到哪些 IO 管脚上。 除此以外，所有 IO 管脚都可以配置为 GPIO 或者 DEBUG 模式。GPIO 模式的输入、输出方向由 GIO_SetDirection 控制。 DEBUG 模式为保留功能，具体功能暂不开放。 表 10.1: 支持与常用 IO 全映射的常用功能管脚 外设 功能管脚 I2C I2C0_SCL_I, I2C0_SCL_O, I2C0_SDA_I, I2C0_SDA_O, I2C1_SCL_I, I2C1_SCL_O, I2C1_SDA_I, I2C1_SDA_O I2S I2S_BCLK_I, I2S_BCLK_O, I2S_DIN, I2S_DOUT, I2S_LRCLK_I, I2S_LRCLK_O PCAP PCAP0_IN, PCAP1_IN, PCAP2_IN, PCAP3_IN, PCAP4_IN, PCAP5_IN SDM DMIC_CLK, DMIC_DATA QDEC QDEC_INDEX, QDEC_PHASEA, QDEC_PHASEB SPI0 SPI0_CLK_IN, SPI0_CLK_OUT, SPI0_CSN_IN, SPI0_CSN_OUT, SPI0_HOLD_IN, SPI0_HOLD_OUT, SPI0_MISO_IN, SPI0_MISO_OUT, SPI0_MOSI_IN, SPI0_MOSI_OUT, SPI0_WP_IN, SPI0_WP_OUT SPI SPI1_CLK_IN, SPI1_CLK_OUT, SPI1_CSN_IN, SPI1_CSN_OUT, SPI1_HOLD_IN, SPI1_HOLD_OUT, SPI1_MISO_IN, SPI1_MISO_OUT, SPI1_MOSI_IN, SPI1_MOSI_OUT, SPI1_WP_IN, SPI1_WP_OUT SWD SWDO, SW_TCK, SW_TMS UART0 UART0_CTS, UART0_RTS, UART0_RXD, UART0_TXD UART1 UART1_CTS, UART1_RTS, UART1_RXD, UART1_TXD 表 10.2: 其它外设功能管脚的映射关系 外设功能管脚 可连接到的 IO 管脚 KEY_IN_COL_0 0, 12, 24 KEY_IN_COL_1 1, 13, 25 KEY_IN_COL_2 2, 14, 26 KEY_IN_COL_3 3, 15, 27 KEY_IN_COL_4 4, 16, 28 KEY_IN_COL_5 5, 17, 29 KEY_IN_COL_6 6, 18, 30 KEY_IN_COL_7 7, 19, 31 KEY_IN_COL_8 8, 20, 32 KEY_IN_COL_9 9, 21, 33 KEY_IN_COL_10 10, 22, 34 KEY_IN_COL_11 11, 23, 35 KEY_IN_COL_12 12, 24, 0 KEY_IN_COL_13 13, 25, 1 KEY_IN_COL_14 14, 26, 2 KEY_IN_COL_15 15, 27, 3 KEY_IN_COL_16 16, 28, 4 KEY_IN_COL_17 17, 29, 5 KEY_IN_COL_18 18, 30, 6 KEY_IN_COL_19 19, 31, 7 KEY_IN_COL_20 20, 32, 8 KEY_IN_COL_21 21, 33, 9 KEY_OUT_ROW_0 0, 8, 16, 24, 32 KEY_OUT_ROW_1 1, 9, 17, 25, 33 KEY_OUT_ROW_2 2, 10, 18, 26, 34 KEY_OUT_ROW_3 3, 11, 19, 27, 35 KEY_OUT_ROW_4 4, 12, 20, 28 KEY_OUT_ROW_5 5, 13, 21, 29 KEY_OUT_ROW_6 6, 14, 22, 30 KEY_OUT_ROW_7 7, 15, 23, 31 ANT_SW0 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 32 ANT_SW1 1, 4, 7, 10, 13, 16, 19, 22, 25, 30 ANT_SW2 2, 5, 8, 11, 14, 17, 20, 23, 26, 31 ANT_SW3 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 32 ANT_SW4 1, 4, 7, 10, 13, 16, 19, 22, 24, 27, 32 ANT_SW5 2, 5, 8, 11, 14, 17, 20, 25, 30 ANT_SW6 0, 3, 6, 9, 12, 15, 18, 21， 23， 26， 31 ANT_SW7 1, 4, 7, 10, 13, 16, 22, 24， 27， 32 PA_RXEN 5, 12, 13, 14, 15, 16, 20, 21, 22， 23 PA_TXEN 4, 5, 6, 7, 8, 9, 10, 21, 22， 23， 30 TIMER0_PWM_0A 0, 2, 4, 6, 8, 10, 12, 14, 16, 19, 21, 23, 25 27, 29, 31, 33, 35 TIMER0_PWM_0B 1, 3, 5, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 28, 30, 32, 34 TIMER0_PWM_1A 0, 2, 4, 6, 8, 10, 12, 14, 16, 19, 21, 23, 25 27, 29, 31, 33, 35 TIMER0_PWM_1B 1, 3, 5, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 28, 30, 32, 34 TIMER1_PWM_0A 0, 2, 4, 6, 8, 10, 12, 14, 16, 19, 21, 23, 25 27, 29, 31, 33, 35 TIMER1_PWM_0B 1, 3, 5, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 28, 30, 32, 34 TIMER1_PWM_1A 0, 2, 4, 6, 8, 10, 12, 14, 16, 19, 21, 23, 25 27, 29, 31, 33, 35 TIMER1_PWM_1B 1, 3, 5, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 28, 30, 32, 34 PWM_0A 0, 2, 4, 6, 8, 10, 12, 14, 16, 19, 21, 23, 25 27, 29, 31, 33, 35 PWM_0B 1, 3, 5, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 28, 30, 32, 34 PWM_1A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 23, 25 27, 29, 31, 33, 35 PWM_1B 1, 3, 5, 7, 9, 11, 13, 15, 17, 20, 22, 24, 26, 28, 30, 32, 34 PWM_2A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 23, 25 27, 29, 31, 33, 35 PWM_2B 1, 3, 5, 7, 9, 11, 13, 15, 17, 20, 22, 24, 26, 28, 30, 32, 34 QDEC_EXT_IN_CLK 3, 9 QDEC_TIMER_EXT_IN1_A 1, 7, 13, 19 QDEC_TIMER_EXT_IN2_A 2, 8, 14, 20 QDEC_TIMER_EXT_IN2_B 5, 11, 17, 23 QDEC_TIMER_EXT_OUT0_A 0, 6, 12, 18 QDEC_TIMER_EXT_OUT1_A 1, 7, 13, 19 QDEC_TIMER_EXT_OUT2_A 2, 8, 14, 20 QDEC_TIMER_EXT_OUT0_B 3, 9, 15, 21 QDEC_TIMER_EXT_OUT1_B 4, 10, 16, 22 QDEC_TIMER_EXT_OUT2_B 5, 11, 17, 23 SPI0_CLK_IN 23, 37 SPI0_CLK_OUT 23, 37 SPI0_CSN_IN 24, 36 SPI0_CSN_OUT 24, 36 SPI0_HOLD_IN 25, 38 SPI0_HOLD_OUT 25, 38 SPI0_MISO_IN 27, 40 SPI0_MISO_OUT 27, 40 SPI0_MOSI_IN 30, 41 SPI0_MOSI_OUT 30, 41 SPI0_WP_IN 26, 39 SPI0_WP_OUT 26, 39 SPI1_CLK_IN 31 SPI1_CLK_OUT 31 SPI1_CS_IN 32 SPI1_CS_OUT 32 SPI1_MISO_IN 23 SPI1_MISO_OUT 23 SPI1_MOSI_IN 24 SPI1_MOSI_OUT 24 SPI1_HOLD_IN 25 SPI1_HOLD_OUT 25 SPI1_WP_IN 26 SPI1_WP_OUT 26 PCAP_IN0 24, 26, 30, 32 PCAP_IN1 23, 25, 27, 31 PCAP_IN2 24, 26, 30, 32 PCAP_IN3 23, 25, 27, 31 PCAP_IN4 24, 26, 30, 32 PCAP_IN5 23, 25, 27, 31 UART0_TX 23, 24 25 , 26, 27, 30, 31, 32 UART0_RTS 23, 24 25 , 26, 27, 30, 31, 32 UART1_TX 23, 24 25 , 26, 27, 30, 31, 32 UART1_RTS 23, 24 25 , 26, 27, 30, 31, 32 DMIC_DATA 24, 30 DMIC_CLK 25, 32 10.2 使用说明 10.2.1 为外设配置 IO 管脚 将外设输出连接到 IO 管脚 通过 PINCTRL_SetPadMux 将外设输出连接到 IO 管脚。 注意按照表 10.1 和 表 10.2 确认硬件是否支持。对于不支持的配置，显然无法生效，函数将返回非 0 值。 int PINCTRL_SetPadMux( const uint8_t io_pin_index, // IO 序号 (0 .. IO_PIN_NUMBER - 1) const io_source_t source // IO 源 ); 例如将 IO 管脚 10 配置为 GPIO 模式： PINCTRL_SetPadMux(10, IO_SOURCE_GPIO); 将 IO 管脚连接到外设的输入 对于有些外设的输入同样通过 PINCTRL_SetPadMux 配置。对于另一些输入， PINCTRL 为不同的外设分别提供了 API 用以配置输入。比如 UART 的数据输入 RXD 和用于硬件流控的 CTS，需要通过 PINCTRL_SelUartIn 配置 ： int PINCTRL_SelUartIn( uart_port_t port, // UART 序号 uint8_t io_pin_rxd, // 连接到 RXD 输入的 IO 管脚 uint8_t io_pin_cts); // 连接到 CTS 输入的 IO 管脚 对于不需要配置的输入，可在对应的参数上填入值 IO_NOT_A_PIN。 表 10.3 罗列了为各外设提供的输入配置函数。 表 10.3: 各外设的输入配置函数 外设 配置函数 KeyScan PINCTRL_SelKeyScanColIn I2C PINCTRL_SelI2cIn I2S PINCTRL_SelI2sIn IR PINCTRL_SelIrIn PDM PINCTRL_SelPdmIn PCAP PINCTRL_SelPCAPIn QDEC PINCTRL_SelQDECIn SWD PINCTRL_SelSwIn SPI PINCTRL_SelSpiIn UART PINCTRL_SelUartIn USB PINCTRL_SelUSB 10.2.2 配置上拉、下拉 IO 管脚的上拉、下拉模式通过 PINCTRL_Pull 配置： void PINCTRL_Pull( const uint8_t io_pin_index, // IO 管脚序号 const pinctrl_pull_mode_t mode // 模式 ); 表 10.4 列出了各管脚默认的上下拉配置。 表 10.4: 管脚上下拉默认配置 管脚 默认配置 1 上拉 2 上拉 3 上拉 4 上拉 15 下拉 16 下拉 17 下拉 其它 禁用上下拉 10.2.3 配置驱动能力 通过 PINCTRL_SetDriveStrength 配置 IO 管脚的驱动能力： void PINCTRL_SetDriveStrength( const uint8_t io_pin_index, const pinctrl_drive_strength_t strength); 默认驱动能力共分 4 档，分别为 \\(2mA\\)、\\(4mA\\)、\\(8mA\\)、\\(12mA\\)。除了 IO1 驱动能力默认为 \\(12mA\\) 之外， 其它管脚驱动能力默认 \\(8mA\\)。 10.2.4 配置天线切换控制管脚 支持最多 8 个管脚用于天线切换控制，相应地，天线切换模板（switching pattern）内每个数字包含 8 个比特， 取值范围为 \\(0..255\\)。这 8 个比特可依次通过 IO_SOURCE_ANT_SW0、……、IO_SOURCE_ANT_SW7 选择。 例如，查表 10.2 可知管脚 0 能够映射为 ANT_SW0，即比特 0。 通过下面这行代码就可将管脚 0 映射为 ANT_SW0： PINCTRL_SetPadMux(0, IO_SOURCE_ANT_SW0); 通过函数 PINCTRL_EnableAntSelPins 可批量配置用于天线切换控制的管脚： int PINCTRL_EnableAntSelPins( int count, // 数目 const uint8_t *io_pins); // 管脚数组 管脚数组 io_pins 里的第 n 个元素代表第 n 个比特所要映射的管脚。如果不需要为某个比特配置管脚，则在 io_pins 的对应位置填入 IO_NOT_A_PIN。比如，只选用第 0、第 2 等两个比特用作控制，分别映射到管脚 0 和 5： const uint8_t io_pins[] = {0, IO_NOT_A_PIN, 5}; PINCTRL_EnableAntSelPins(sizeof(io_pins), io_pins); 10.2.5 配置模拟模式 通过以下 3 步可将一个管脚配置为模拟模式： 配置为 GPIO 模式； 禁用上下拉； 将 GPIO 配置为高阻态。 函数 PINCTRL_EnableAnalog 封装了以上步骤： void PINCTRL_EnableAnalog(const uint8_t io_index); 模拟模式适用于以下几种外设。 USB 函数 PINCTRL_SelUSB() 内部封装了 PINCTRL_EnableAnalog，开发者不需要再为 USB 管脚调用该函数配置模拟模式。 ADC 开发者需要调用该函数使能某管脚的 ADC 输入功能。支持 ADC 输入功能的管脚如表 10.5 所示。 表 10.5: 支持 ADC 输入的管脚 管脚 模拟输入 7 AIN 0 8 AIN 1 9 AIN 2 10 AIN 3 30 AIN 4 31 AIN 5 34 AIN 6 35 AIN 7 15 AIN 8 20 AIN 9 ASDM 开发者需要调用该函数使能管脚的 ASDM 输入采样功能，Amic内部驱动电压输出（MicBias）功能， 以及内部Vref参考电压输出（ASDM_Vref）功能。 Vref参考电压可从IO（ASDM Vref Pad）输出，外接滤波电容，可提升采样信号质量。 表 10.6: 支持 ASDM 输入输入的管脚 管脚 模拟输入输出 11 ASDM_Vref 12 MicBias 13 ASDM_P 14 ASDM_N "],["ch-pwm.html", "11 增强型脉宽调制发生器（PWM） 11.1 PWM 工作模式 11.2 PCAP 11.3 PWM 使用说明 11.4 PCAP 使用说明 11.5 IR模式示例", " 11 增强型脉宽调制发生器（PWM） 增强型脉宽调制发生器具有：生成脉宽调制信号（PWM），捕捉外部脉冲输入（PCAP），带载波生成IR发送信号， 捕获计算IR信号。 增强型脉宽调制发生器具备 3 个通道，每个通道都可以单独配置为 PWM 或者 PCAP 模式。 每个通道拥有独立的 FIFO。FIFO 里的每个存储单元为 2 个 20bit 数据。 FIFO 深度为 4，即最多存储 4 个单元，共 \\(8 \\times 20bit\\) 数据。 这里的 20bit 位宽是因为本硬件模块内部 PWM 使用的各计数器都是 20 比特。 可根据 FIFO 内的数据量触发中断或者 DMA 传输。 说明：TIMER 也支持生成脉宽调制信号，但是可配置的参数较简单，不支持死区等。 PWM 特性： 最多支持 3 个 PWM 通道，每一个通道包含 A、B 两个输出 每个通道参数独立 支持死区 支持通过 DMA 更新 PWM 配置 支持WS2812位带灯控制 PCAP 特性： 支持 3 个 PCAP 通道，每一个通道包含两个输入 支持捕捉上升沿、下降沿 支持通过 DMA 读取数据 IR 特性： * 支持 IR 捕获模式。 * 支持 IR 发送，可配置不同载波频率。 11.1 PWM 工作模式 PWM 使用的时钟频率可配置，请参考 SYSCTRL。 每个 PWM 通道支持以下多种工作模式： typedef enum { PWM_WORK_MODE_UP_WITHOUT_DIED_ZONE = 0x0, PWM_WORK_MODE_UP_WITH_DIED_ZONE = 0x1, PWM_WORK_MODE_UPDOWN_WITHOUT_DIED_ZONE = 0x2, PWM_WORK_MODE_UPDOWN_WITH_DIED_ZONE = 0x3, PWM_WORK_MODE_SINGLE_WITHOUT_DIED_ZONE = 0x4, PWM_WORK_MODE_DMA = 0x5, PWM_WORK_MODE_PCAP = 0x6, PWM_WORK_MODE_IR = 0x7 } PWM_WorkMode_t; 11.1.1 最简单的模式：UP_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH &lt;= cnt; B = !A; } 11.1.2 UP_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH，DZONE_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH + DZONE_TH &lt;= cnt; B = DZONE_TH &lt;= cnt &lt; HIGH_TH); } 11.1.3 UPDOWN_WITHOUT_DIED_ZONE 此模式需要的门限参数与 UP_WITHOUT_DIED_ZONE 相同。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH &lt;= cnt &lt;= PERA_TH + HIGH_TH; B = !A; } 11.1.4 UPDOWN_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH。 以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH + DZONE_TH &lt;= cnt &lt;= PERA_TH + HIGH_TH; B = (cnt &lt; PERA_TH - HIGH_TH) || (cnt &gt; PERA_TH + HIGH_TH + DZONE_TH); } 11.1.5 SINGLE_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。此模式只产生一个脉冲，以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt++; A = HIGH_TH &lt;= cnt &lt; PERA_TH; B = !A; } 以上伪代码仅用于辅助描述硬件行为，与实际行为可以存在微小差异。 11.1.6 DMA 模式 此模式支持通过 DMA 实时更新门限。 11.1.7 输出控制 对于每个通道的每一路输出，另有 3 个参数控制最终的两路输出：掩膜、停机输出值、反相。 最终的输出以伪代码描述如下： output_control(v) { if (掩膜 == 1) return A 路输出 0、B 路输出 1; if (本通道已停机) return 停机输出值; if (反相) v = !v; return v; } 11.2 PCAP PCAP 每个通道包含两路输入。PCAP 内部有一个单独的 32 比特计数器2， 当检测到输入信号变化（包含上升沿和下降沿）时，PCAP 将计数器的值及边沿变化信息作为一个存储单元压入 FIFO： struct data0 { uint32_t cnt_high:12; uint32_t p_cap_0_p:1; // A 路出现上升沿 uint32_t p_cap_0_n:1; // A 路出现下降沿 uint32_t p_cap_1_p:1; // B 路出现上升沿 uint32_t p_cap_1_n:1; // B 路出现下降沿 uint32_t tag:4; uint32_t padding:12; }; struct data1 { uint32_t cnt_low:20; uint32_t padding:12; }; 通过复位整个模块可以清零 PCAP 计数器。 11.2.1 IR模式 IR可以使能一路IR信号输出，载波频率可配，通过配置pwm输出步进可生成灵活的IR信号，推荐预定义IR数据流，使用DMA的方式快速完成IR控制信号输出。 IR抓取模式以PCAP模式为基础，通过PCAP抓取IR信号，通内部配置IR信号解码参数，可完成IR信号的解码，解码结果输出到对应FIFO。 在此模式下，需要将步进配置为预测的IR的3〜6次 频率通过寄存器pera_th，建议使用200kHz，IR给出将抓取 以下时间节点： 1，第一个上升的边缘，跌落边缘，第二次上升边缘，跌落边缘，以便 确定载波频率。 2，载波停止的时间点以及它开始的时间点。 11.3 PWM 使用说明 11.3.1 启动与停止 共有两个开关与 PWM 的启动和停止有关：使能（Enable）、停机控制（HaltCtrl）。只有当 Enable 为 1， HaltCtrl 为 0 时，PWM 才真正开始工作。 相关的 API 为： // 使能 PWM 通道 void PWM_Enable( const uint8_t channel_index, // 通道号 const uint8_t enable // 使能或禁用 ); // PWM 通道停机控制 void PWM_HaltCtrlEnable( const uint8_t channel_index, // 通道号 const uint8_t enable // 停机(1) 或运转(0) ); 11.3.2 配置工作模式 void PWM_SetMode( const uint8_t channel_index, // 通道号 const PWM_WorkMode_t mode // 模式 ); 11.3.3 配置门限 // 配置 PERA_TH void PWM_SetPeraThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 DZONE_TH void PWM_SetDiedZoneThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 HIGH_TH void PWM_SetHighThreshold( const uint8_t channel_index, const uint8_t multi_duty_index, // 对于 ING20XX，此参数无效 const uint32_t threshold); 各门限值最大支持 0xFFFFF，共 20 个比特。 11.3.4 输出控制 // 掩膜控制 void PWM_SetMask( const uint8_t channel_index, // 通道号 const uint8_t mask_a, // A 路掩膜 const uint8_t mask_b // B 路掩膜 ); // 配置停机输出值 void PWM_HaltCtrlCfg( const uint8_t channel_index, // 通道号 const uint8_t out_a, // A 路停机输出值 const uint8_t out_b // B 路停机输出值 ); // 反相 void PWM_SetInvertOutput( const uint8_t channel_index, // 通道号 const uint8_t inv_a, // A 路是否反相 const uint8_t inv_b // B 路是否反相 ); 11.3.5 综合示例 下面的例子将 channel_index 通道配置成输出频率为 frequency、占空比为 (on_duty)% 的方波， 涉及 3 个关键参数： 生成这种最简单的 PWM 信号需要的模式为 UP_WITHOUT_DIED_ZONE； PERA_TH 控制输出信号的频率，设置为 PWM_CLOCK_FREQ / frequency； HIGH_TH 控制信号的占空比，设置为 PERA_TH * (100 - on_duty) % void PWM_SetupSimple( const uint8_t channel_index, const uint32_t frequency, const uint16_t on_duty) { uint32_t pera = PWM_CLOCK_FREQ / frequency; uint32_t high = pera &gt; 1000 ? pera / 100 * (100 - on_duty) : pera * (100 - on_duty) / 100; PWM_HaltCtrlEnable(channel_index, 1); PWM_Enable(channel_index, 0); PWM_SetPeraThreshold(channel_index, pera); PWM_SetHighThreshold(channel_index, 0, high); PWM_SetMode(channel_index, PWM_WORK_MODE_UP_WITHOUT_DIED_ZONE); PWM_SetMask(channel_index, 0, 0); PWM_Enable(channel_index, 1); PWM_HaltCtrlEnable(channel_index, 0); } 11.3.6 使用 DMA 实时更新配置 使用 DMA 能够实时更新配置（相当于工作在 UP_WITHOUT_DIED_ZONE，但是每个循环使用不同的参数）： 每当 PWM 计数器计完一圈回零时，自动使用来自 DMA 的数据更新配置。 这些数据以 2 个 uint32_t 为一组，依次表示 HIGH_TH 和 PERA_TH。 void PWM_DmaEnable( const uint8_t channel_index, // 通道号 uint8_t trig_cfg, // DMA 请求触发门限 uint8_t enable // 使能 ); 当 PWM 内部 FIFO 数据少于 trig_cfg，PWM 请求 DMA 传输数据。PWM FIFO 深度为 8 ，可以存储 8 个 32 比特数据（只有低 20 比特有效，其余比特忽略），相当于 4 组 PWM 配置， 所以 trig_cfg 的取值范围为 \\(0..7\\)。 11.4 PCAP 使用说明 11.4.1 配置 PCAP 模式 要启用 PCAP 模式，需要 5 个步骤： 关闭整个模块的时钟（参考 SYSCTRL） 使用 PCAP_Enable 使能 PCAP 模式 void PCAP_Enable( const uint8_t channel_index // 通道号 ); 使用 PCAP_EnableEvents 选择要检测的事件 void PCAP_EnableEvents( const uint8_t channel_index, uint8_t events_on_0, uint8_t events_on_1); events 为下面两个事件的组合： enum PCAP_PULSE_EVENT { PCAP_PULSE_RISING_EDGE = 0x1, PCAP_PULSE_FALLING_EDGE = 0x2, }; 比如在通道 1 的 A 路输入上同时检测、上报上升沿和下降沿： PCAP_EnableEvents(1, PCAP_PULSE_RISING_EDGE | PCAP_PULSE_FALLING_EDGE, ...); 打开整个模块的时钟（参考 SYSCTRL） 配置 DMA 传输 当 PCAP 通道 FIFO 内存储的数据多于或等于 trig_cfg 时，请求 DMA 传输数据。trig_cfg 的取值范围为 \\(0..7\\)。 void PCAP_DmaEnable( const uint8_t channel_index, // 通道号 uint8_t trig_cfg, // DMA 请求触发门限 uint8_t enable // 使能 ); 使能计数器 void PCAP_CounterEnable( uint8_t enable // 使能(1)/禁用(0) ); 11.4.2 读取计数器 uint32_t PCAP_ReadCounter(void); 11.5 IR模式示例 11.5.1 IR 发送模式 该模式演示了NEC发送一段NEC数据序列的代码，需要根据NEC的序列要求，计算要填入fifo的数值，之后通过写fifo或DMA的形式发送NEC序列。 //IR Step Mode constant #define IR_REG_SW (1&lt;&lt;15) #define NEC_START_P_NUM 342 #define NEC_START_I_NUM 172 #define NEC_LOGIC_NUM 22 #define NEC_STOP_NUM 22 void PWM_Init(void) { SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ITEM_APB2_PWM) | (1 &lt;&lt; SYSCTRL_ITEM_APB1_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB1_GPIO0)); PINCTRL_SetPadMux(GIO_GPIO_8,IO_SOURCE_PWM4_A); PINCTRL_SetPadMux(GIO_GPIO_7,IO_SOURCE_PWM4_B); } void IR_Step_Mode_init(const uint8_t channel_index) { PWM_Init(); PWM_Enable(channel_index, 0); SYSCTRL_EnablePcapMode(channel_index,0); PWM_SetMask(channel_index,0,0);//设置通道输出极性 SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB2_PWM); SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB2_PWM); PWM_SetMode(channel_index, PWM_WORK_MODE_IR); PWM_StepEnabled(channel_index,0);//close step enabled IR_CycleCarrierSetup(channel_index,0,38000,70); IR_CycleCarrierSetup(channel_index,1,38000,0); PWM_Enable(channel_index, 1); } void NEC_START(const uint8_t channel_index) { IR_WriteCarrierData(channel_index,NEC_START_P_NUM); while (IR_BusyState(channel_index)); IR_WriteCarrierData(channel_index,NEC_START_I_NUM | IR_REG_SW); while (IR_BusyState(channel_index)); } void NEC_LOGIC(const uint8_t channel_index,uint8_t x) { uint8_t pulse; IR_WriteCarrierData(channel_index,NEC_LOGIC_NUM); while (IR_BusyState(channel_index)); pulse = NEC_LOGIC_NUM*(x * 2 + 1); IR_WriteCarrierData(channel_index,pulse | IR_REG_SW); while (IR_BusyState(channel_index)); } void NEC_STOP(const uint8_t channel_index) { IR_WriteCarrierData(channel_index,NEC_STOP_NUM); while(IR_BusyState(channel_index)); } void IR_Write_data(const uint8_t channel_index,uint8_t data) { uint8_t i; for(i = 0; i&lt;8; i++) { NEC_LOGIC(channel_index,((data&gt;&gt;i) &amp; 0x01)); } } void IR_NECSend_Command(const uint8_t channel_index,uint8_t address, uint8_t cmd) { NEC_START(channel_index); IR_Write_data(channel_index,address); IR_Write_data(channel_index,~address); IR_Write_data(channel_index,cmd); IR_Write_data(channel_index,~cmd); NEC_STOP(channel_index); } void PWM_IR_Reset(uint8_t channel) { PWM_Enable(channel, 0); PWM_Enable(channel, 1); } void IR_test_cycle(const uint8_t channel_index,uint8_t address, uint8_t cmd) { PWM_IR_Reset(channel_index); IR_NECSend_Command(channel_index,address, cmd); delay_ms(200); } void main(void) { IR_Step_Mode_init(0); IR_test_cycle(0,0xFF,0x00); IR_test_cycle(0,0xFF,0x00); while(1); } 11.5.2 IR接收模式 该模式通过抓取载波频率和具体的信号步进的方式解析对应的红外信号，以下是代码示例(部分函数实现可参考发送部分配置)： //IR Grabbing test function void IR_Grabbing_TX(void) { SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ITEM_APB2_PWM) | (1 &lt;&lt; SYSCTRL_ITEM_APB1_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB1_GPIO0)); PINCTRL_SetPadMux(GIO_GPIO_8,IO_SOURCE_PWM5_A); PWM_Enable(1, 0); SYSCTRL_EnablePcapMode(1,0); PWM_SetMask(1,0,0); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB2_PWM); SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB2_PWM); PWM_SetMode(1, PWM_WORK_MODE_IR); PWM_StepEnabled(1,0);//close step enabled IR_CycleCarrierSetup(1,0,38000,70); IR_CycleCarrierSetup(1,1,38000,0); PWM_Enable(1, 1); } void IR_Grabbing_init(void) { SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ITEM_APB1_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB1_GPIO0)); PINCTRL_SelPCAPIn(0, GIO_GPIO_7); SYSCTRL_EnablePcapMode(0,1); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB2_PWM); SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB2_PWM); PCAP_Enable(0); PWM_StepEnabled(0,1); PCAP_EnableEvents(0, PCAP_PULSE_RISING_EDGE | PCAP_PULSE_FALLING_EDGE, PCAP_PULSE_RISING_EDGE | PCAP_PULSE_FALLING_EDGE); APB2_PWM-&gt;Channels[0].Ctrl0 &amp;= ~(0x7 &lt;&lt; 12); APB2_PWM-&gt;Channels[0].Ctrl0 |= (0x1 &lt;&lt; 12); uint32_t pera = PWM_CLOCK_FREQ / 200000; APB2_PWM-&gt;Channels[0].PeraTh = pera; NVIC_Configuration(); PWM_FifoIntEnable(0,1,PWM_FIFO_TRIGGER_EN); PCAP_CounterEnable(1); PWM_Enable(0, 1); } void IR_Grabbing_test(void) { IR_Grabbing_init(); IR_Grabbing_TX(); IR_test_cycle(1,0xFF,0x00); } 所有 6 路输入共有此计数器。↩︎ "],["ch-qdec.html", "12 QDEC简介 12.1 功能描述 12.2 使用方法 12.3 编程指南", " 12 QDEC简介 QDEC全称Quadrature Decoder，即正交解码器。 其作用是用来解码来自旋转编码器的脉冲序列，以提供外部设备运动的步长和方向。 12.1 功能描述 12.1.1 特点 可配置时钟 支持过滤器 支持APB总线 支持DMA 12.1.2 正转和反转 QDEC是通过采集到phase_a、phase_b相邻两次的数值变化来判断外设的运动方向。 顺时针采集数据如图所示： 图 12.1: QDEC顺时针采集数据 逆时针采集数据如图所示： 图 12.2: QDEC逆时针采集数据 在QDEC数据上，如果引脚配置和连接正确，顺时针转动则采集到的数据逐渐增大，逆时针则数据逐渐减小。 12.2 使用方法 12.2.1 方法概述 方法概述为：GPIO选配，时钟配置，QDEC参数配置以及数据处理。 12.2.1.1 GPIO选择 驱动接口：PINCTRL_SelQDECIn QDEC的GPIO选择，请参考 PINCTRL 对phase_a、phase_b选定要配置的GPIO口，并调用PINCTRL_SelQDECIn接口进行配置。 12.2.1.2 时钟配置 驱动接口：SYSCTRL_SelectQDECClk 当前QDEC可以选择使用的时钟源为HCLK时钟或者sclk_slow时钟 出于实际效果和硬件资源等因素考虑，我们推荐开发者选择sclk_slow作为时钟源 对所选用的时钟源还需要进行一次分频，分频系数范围为1-1023，默认值为2 这里需要特别注意的是：如果使用sclk_slow时钟， 请务必配置pclk时钟频率不大于qdec时钟源频率 注意： 如果配置pclk频率大于qdec时钟源频率，会出现qdec参数配置失败从而不能正常工作的现象。 为了方便开发者使用，可以直接调用下面提供的接口来配置pclk时钟符合上述要求： static void QDEC_PclkCfg(void) { if ((APB_SYSCTRL-&gt;QdecCfg &gt;&gt; 15) &amp; 1) return; uint32_t hclk = SYSCTRL_GetHClk(); uint32_t slowClk = SYSCTRL_GetSlowClk(); uint8_t div = hclk / slowClk; if (hclk % slowClk) div++; if (!(div &gt;&gt; 4)) SYSCTRL_SetPClkDiv(div); } 开发者可以将以上代码拷贝到程序里，在配置qdec之前调用即可。 在配置完qdec之后可以选择将pclk恢复到原来频率，实例可参考SDK中HID mouse例程。 12.2.1.3 QDEC参数配置 驱动接口：QDEC_EnableQdecDiv、QDEC_QdecCfg 共有3个参数需要配置：qdec_clk_div、filter和miss 其含义分别如下： qdec_clk_div：用于控制qdec结果上报频率。即多少个时钟周期上报一次采样结果 filter：用于过滤filter×时钟周期时长以内的毛刺 miss：用于控制qdec可以自动补偿的最大miss结果数。例如由于滚轮转动过快，导致两次采样中变换了不止一个结果，则此时会自动补偿最多miss个结果。 对于miss值配置此处建议先加入较小的miss值（如miss=1）测试效果，如果效果良好则可以尝试继续加大miss值。在保证性能的基础上，理论上miss值越大越好。 注意： 对于miss值的配置需要格外注意，miss值的设置主要考虑到可能由于转动速度过快导致有数据丢失的情况，但此补偿机制容易受设备信号质量影响。对于信号质量很差的设备，如信号很多毛刺，如果加入miss则可能出现“采样数据跳变”和“换向迟钝”的问题。对于此类设备，建议进行以下几方面尝试： 1. 如选用sclk_slow作为时钟源，检查是否有配置pclk频率小于qdec工作频率 2. 改用较小工作时钟 3. 采用较小的miss值（如miss=1）和较大的filter值 4. 采用较大工作时钟（如HCLK时钟），不加miss进行采样 如果偶尔有较小的数据跳变，如5以内，则需判断其可能属于正常情况。 12.2.2 注意点 phase_a、phase_b引脚配置注意区分正反，交换引脚则得到相反的转向 配置pclk时钟可能会影响其他外设，建议配好qdec之后将pclk及时恢复 qdec采样快慢和时钟正相关，和qdec_clk_div大小无关，qdec_clk_div只控制对结果的上报频率 qdec上报结果会同时触发qdec中断或者DMA_REQ，qdec_clk_div设置过低会占用较多CPU资源 filter建议选择较大值，受毛刺影响较小，稳定性较好 12.3 编程指南 12.3.1 驱动接口 QDEC_QdecCfg：qdec标准配置接口 QDEC_EnableQdecDiv：qdec_clk_div设置使能接口 QDEC_ChannelEnable：qdec通道使能接口 QDEC_GetData：qdec获取数据接口 QDEC_GetDirection：qdec获取转向接口 QDEC_Reset：qdec复位接口 12.3.2 代码示例 下面一段代码展示了qdec全部配置并循环读数： static void QDEC_PclkCfg(void) { if ((APB_SYSCTRL-&gt;QdecCfg &gt;&gt; 15) &amp; 1) return; uint32_t hclk = SYSCTRL_GetHClk(); uint32_t slowClk = SYSCTRL_GetSlowClk(); uint8_t div = hclk / slowClk; if (hclk % slowClk) div++; if (!(div &gt;&gt; 4)) SYSCTRL_SetPClkDiv(div); } void test(void) { // setup qdec SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_QDEC)); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_QDEC); PINCTRL_SelQDECIn(16, 17); // set GPIO16=phase_a, GPIO17=phase_b SYSCTRL_SelectQDECClk(SYSCTRL_CLK_SLOW, 100); QDEC_PclkCfg(); // set pclk not bigger than sclk_slow QDEC_EnableQdecDiv(QDEC_DIV_1024); QDEC_QdecCfg(50, 1); QDEC_ChannelEnable(1); // print qdec data and direction when rotate the mouse wheel manually uint16_t preData = 0; uint16_t data = 0; uint8_t dir; while(1) { data = QDEC_GetData(); dir = QDEC_GetDirection(); if (data != preData) { if (dir) { printf(&quot;data: %d, %s\\n&quot;, data, &quot;anticlockwise&quot;); } else { printf(&quot;data: %d, %s\\n&quot;, data, &quot;clockwise&quot;); } } preData = data; } } 当手动转动鼠标滚轮时，会打印出收到的qdec数据和转向。 推荐开发者采用timer定时轮询的方式读取qdec数据，并进行数据处理和上报。具体的qdec详细使用实例请参考SDK中HID mouse例程。 "],["ch-spi.html", "13 串行外围设备接口（SPI） 13.1 功能概述 13.2 使用说明", " 13 串行外围设备接口（SPI） SPI全称为Serial Peripheral interface即串行外围设备接口。 SPI是一种高速同步的通信总线。一般使用四个IO：SDI（数据输入），SDO（数据输出），SCK（时钟），CS（片选）。针对Flash的QSPI则还需要使用额外的两个IO：WP（写保护），HOLD（保持）。 13.1 功能概述 两个SPI模块 支持SPI主(Master)&amp;从(Slave)模式 支持Quad SPI，可以从外挂Flash执行代码 独立的RX&amp;TX FIFO，深度为8个word 支持DMA 支持XIP(SPI0) 13.2 使用说明 13.2.1 时钟以及IO配置 使用模块之前，需要打开相应的时钟，并且配置IO（查看对应datasheet获取可用的IO）： 通过SYSCTRL_ClearClkGateMulti打开SPI时钟，例如SPI1则需要打开SYSCTRL_ITEM_APB_SPI1。 配置IO的输入功能PINCTRL_SelSpiIn，没有使用到的IO可以使用IO_NOT_A_PIN替代。 使用PINCTRL_SetPadMux配置IO的输出功能。 对于Slave的输入，例如CLK需要保持默认低电平，则使用PINCTRL_Pull配置IO的上拉功能。 打开SPI中断platform_set_irq_callback。 对于时钟大于20M的使用场景，IO的选择有特殊要求，请参考高速时钟和IO映射。 以SPI1为例，高速IO可以为： #define SPI_MIC_CLK GIO_GPIO_7 #define SPI_MIC_MOSI GIO_GPIO_8 #define SPI_MIC_MISO GIO_GPIO_9 #define SPI_MIC_CS GIO_GPIO_10 #define SPI_MIC_WP GIO_GPIO_11 #define SPI_MIC_HOLD GIO_GPIO_12 下述示例可以将指定IO映射到SPI1的Master模式： static void setup_peripherals_spi_pin(void) { SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl)); PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); } 如果是Slave模式，则需要额外配置默认上拉，并且输入输出IO有区别： static void setup_peripherals_spi_pin(void) { SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl))); PINCTRL_Pull(SPI_MIC_CLK,PINCTRL_PULL_DOWN); PINCTRL_Pull(SPI_MIC_CS,PINCTRL_PULL_UP); PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); } 13.2.2 模块初始化 模块的初始化通过apSSP_DeviceParametersSet和结构体apSSP_sDeviceControlBlock实现，结构体各个参数为： eSclkDiv：时钟分频因子，决定了SPI的时钟速率。该参数和SPI模块时钟有关，在默认配置下，SPI模块时钟为24M，eSclkDiv可以直接使用SPI_INTERFACETIMINGSCLKDIV_DEFAULT_xx宏定义。对于更高的时钟，需要首先提高SPI模块时钟，然后再计算eSclkDiv，计算公式和配置方式请参考章节其他配置-&gt;时钟配置。 eSCLKPhase：上升沿还是下降沿采样，参考SPI_TransFmt_CPHA_e。 eSCLKPolarity：时钟默认是低电平还是高电平，参考SPI_TransFmt_CPOL_e。 eLsbMsbOrder：bit传输顺序是LSB还是MSB，默认是MSB，参考SPI_TransFmt_LSB_e。 eDataSize：每个传输单位的bit个数，8/16/32bit，参考SPI_TransFmt_DataLen_e。 eMasterSlaveMode：选择是Master还是Slave模式，参考SPI_TransFmt_SlvMode_e。 eReadWriteMode：选择传输模式：只读/只写/同时读写，参考SPI_TransCtrl_TransMode_e。 eQuadMode：选择是普通SPI还是QSPI，参考SPI_TransCtrl_DualQuad_e。 eWriteTransCnt：每次发送的单位个数，每个单位eDataSize个bit，达到单位个数后，CS将会拉高，代表一次传输结束。 eReadTransCnt：每次接收的单位个数，每个单位eDataSize个bit，达到单位个数后，CS将会拉高，代表一次传输结束。 eAddrEn：是否需要在数据之前发送地址，只适用Master，参考SPI_TransCtrl_AddrEn_e。 eCmdEn：是否需要在数据之前发送命令，只适用Master，参考SPI_TransCtrl_CmdEn_e。 eInterruptMask：需要打开的SPI中断类型，比如SPI传输结束中断和FIFO中断，参考bsSPI_INTREN_xx。 TxThres：触发TX FIFO中断的门限值，比如可以为eWriteTransCnt/2，参考apSSP_SetTxThres。 RxThres：触发RX FIFO中断的门限值，比如可以为eReadTransCnt/2，参考apSSP_SetRxThres。 SlaveDataOnly：Slave模式下生效，如果只有数据，需要设置为打开，如果包含地址eAddrEn或者命令eCmdEn，需要设置改参数为DISABLE，参考SPI_TransCtrl_SlvDataOnly_e。 eAddrLen：如果打开了eAddrEn，需要选择地址长度，参考SPI_TransFmt_AddrLen_e。 具体使用请参考编程指南。 13.2.3 中断配置 通过eInterruptMask打开需要的中断: bsSPI_INTREN_ENDINTEN：传输结束（CS拉高）之后会触发该中断。 bsSPI_INTREN_TXFIFOINTEN：到达TxThres门限值之后，触发FIFO中断。 bsSPI_INTREN_RXFIFOINTEN：到达RxThres门限值之后，触发FIFO中断。 通过apSSP_GetDataNumInRxFifo来判断当前FIFO中有效数据的个数。使用apSSP_ReadFIFO来读取FIFO中的数据，直到FIFO为空。 13.2.4 编程指南 以下提供不同场景下的代码实现供参考。 13.2.4.1 场景1：同时读写，不使用DMA 其中SPI主（Master）和SPI从（Slave）配置为同时读写模式，CPU操作读写，没有使用DMA 配置之前需要决定使用的IO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD。 13.2.4.1.1 Master配置 配置IO，参考时钟以及IO配置。 模块初始化： 假设每个传输单元是32bit，则mode 0下的Master模式初始化配置为： #define SPI_MASTER_PARAM(DataLen) { SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M, \\ SPI_CPHA_ODD_SCLK_EDGES, SPI_CPOL_SCLK_LOW_IN_IDLE_STATES, \\ SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST, SPI_DATALEN_32_BITS, \\ SPI_SLVMODE_MASTER_MODE, SPI_TRANSMODE_WRITE_READ_SAME_TIME, \\ SPI_DUALQUAD_REGULAR_MODE, DataLen, DataLen, \\ SPI_ADDREN_DISABLE, SPI_CMDEN_DISABLE, (1 &lt;&lt; bsSPI_INTREN_ENDINTEN), \\ 0, 0, SPI_SLVDATAONLY_ENABLE, SPI_ADDRLEN_1_BYTE } 使用APIapSSP_DeviceParametersSet来初始化SPI模块： #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam = SPI_MASTER_PARAM(DATA_LEN); apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 中断实现 该示例中只打开了SPI ENDINT中断，该中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 发送数据 发送数据需要填充数据到TX FIFO并且触发传输： 使用apSSP_WriteFIFO写入需要传输的数据，通过apSSP_TxFifoFull来判断TX FIFO状态，写入数据直到FIFO变满。FIFO的深度为8，超过8个数据可以分为多次发送。 apSSP_WriteCmd来触发传输，此场景中eAddrEn或者eCmdEn都是关闭的，但是仍然需要填充一个任意数据（比如0x00）来触发传输。 使用apSSP_GetSPIActiveStatus等待发送结束，或者查看对应中断。 发送的数据格式和长度需要和eDataSize等参数对应。 uint32_t write_data[DATA_LEN]; void peripherals_spi_send_data(void) { apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer for(i = 0; i &lt; DATA_LEN; i++) { if(apSSP_TxFifoFull(APB_SSP1)){ break; } apSSP_WriteFIFO(APB_SSP1, write_data[i]); } while(apSSP_GetSPIActiveStatus(APB_SSP1)); } 接收数据 在SPI发送结束后，通过apSSP_GetDataNumInRxFifo查看并读取RX FIFO中的数据。 uint32_t read_data[DATA_LEN]; uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } 使用流程 设置IO，setup_peripherals_spi_pin()。 初始化SPI，setup_peripherals_spi_module()。 在需要时候发送SPI数据，peripherals_spi_send_data()。 检查中断状态。 13.2.4.1.2 Slave配置 配置IO，参考时钟以及IO配置。 模块初始化： Slave的初始化和Master相同，只需要将mode切换为SPI_SLVMODE_SLAVE_MODE： #define SPI_SLAVE_PARAM(DataLen) { SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M, \\ SPI_CPHA_ODD_SCLK_EDGES, SPI_CPOL_SCLK_LOW_IN_IDLE_STATES, \\ SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST, SPI_DATALEN_32_BITS, \\ SPI_SLVMODE_SLAVE_MODE, SPI_TRANSMODE_WRITE_READ_SAME_TIME, \\ SPI_DUALQUAD_REGULAR_MODE, DataLen, DataLen, \\ SPI_ADDREN_DISABLE, SPI_CMDEN_DISABLE, (1 &lt;&lt; bsSPI_INTREN_ENDINTEN), \\ 0, 0, SPI_SLVDATAONLY_ENABLE, SPI_ADDRLEN_1_BYTE } 调用apSSP_DeviceParametersSet来初始化SPI模块： static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam = SPI_SLAVE_PARAM(DATA_LEN); apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 发送数据 Slave的待发送数据需要提前放到TX FIFO中。 比如在初始化之后，就可以往FIFO中填充发送数据，同时需要判断apSSP_TxFifoFull： for(i = 0; i &lt; DATA_LEN; i++) { if(apSSP_TxFifoFull(APB_SSP1)){ break; } apSSP_WriteFIFO(APB_SSP1, write_data[i]); } 接收数据 Slave的数据接收需要在中断中进行，bsSPI_INTREN_ENDINTEN中断代表传输结束，此时可以读取RX FIFO中的内容，如果数据长度大于FIFO深度，则需要打开RxThres，在FIFO中断中读取接收数据，或者使用DMA方式，否则数据会丢失。 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1), i; if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 使用流程 设置IO，setup_peripherals_spi_pin()。 初始化SPI，setup_peripherals_spi_module()。 观察SPI中断，中断触发代表当前传输结束。 13.2.4.2 场景2：同时读写，使用DMA 其中SPI主从配置为同时读写模式，同时使用DMA进行读写。 配置之前需要决定使用的IO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD。 13.2.4.2.1 Master配置 配置IO，参考时钟以及IO配置。 模块初始化，参考场景1Master配置。 DMA初始化 使用之前需要初始化DMA模块： static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } DMA设置 设置DMA将指定地址的数据搬运到SPI1 TX FIFO，并打开DMA。 SPI1启动后，搬运自动开始： void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX, src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 设置DMA将SPI1 RX FIFO的数据搬运到指定地址： void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX, size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 中断实现 该示例中只打开了SPI ENDINT中断，该中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 接收数据配置 首先需要打开 SPI 模块中的DMA功能apSSP_SetRxDmaEn。 设置每次传输时接收和发射的个数，改参数已经在模块初始化中设置过了，此处为可选项，如果需要更新，可以通过apSSP_SetTransferControlRdTranCnt和apSSP_SetTransferControlWrTranCnt来更新。注意：该场景下，发射和接收的个数需要相同。 配置DMA。 #define SPI_DMA_RX_CHANNEL (1)//DMA channel 1 uint32_t read_data[DATA_LEN]; void peripherals_spi_read_data(void) { apSSP_SetRxDmaEn(APB_SSP1,1); apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 发送数据配置 类似于接收，发射需要打开SPI的DMA功能，并且配置DMA。 #define SPI_DMA_TX_CHANNEL (0)//DMA channel 0 uint32_t write_data[DATA_LEN]; void peripherals_spi_push_data(void) { apSSP_SetTxDmaEn(APB_SSP1,1); apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); } 发送数据 在需要发送数据时，通过DMA填充待发射数据到TX FIFO。 配置接收数据的DMA，同时读写模式下，发射和接收同步进行。 配置命令触发传输。 等待发射结束apSSP_GetSPIActiveStatus，关闭DMA功能。 void peripherals_spi_send_data(void) { peripherals_spi_read_data(); peripherals_spi_push_data(); apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer while(apSSP_GetSPIActiveStatus(APB_SSP1)); apSSP_SetTxDmaEn(APB_SSP1,0); } 使用流程 设置IO，setup_peripherals_spi_pin()。 初始化SPI，setup_peripherals_spi_module()。 初始化DMA，setup_peripherals_dma_module()。 在需要时候发送SPI数据，peripherals_spi_send_data()。 检查中断状态。 13.2.4.2.2 Slave配置 配置IO，参考时钟以及IO配置。 模块初始化，参考场景1Slave配置。 DMA初始化，与Master的DMA初始化相同，参考setup_peripherals_dma_module。 DMA设置，与Master的DMA设置相同，参考peripherals_spi_dma_to_txfifo 和peripherals_spi_rxfifo_to_dma。 接收数据配置，与Master相同，参考peripherals_spi_read_data。 发送数据配置，与Master相同，参考peripherals_spi_push_data。 传输前准备 对于Slave，如果需要在第一次传输时发送数据，则需要提前将需要发送的数据配置到DMA，配置peripherals_spi_push_data。 使用peripherals_spi_read_data配置接收DMA，等待Master传输。 peripherals_spi_read_data(); peripherals_spi_push_data(); 中断实现 bsSPI_INTREN_ENDINTEN的触发代表当前传输结束。 检查接收数据。 如果需要准备下一次传输，使用peripherals_spi_read_data建立接收DMA。 如果需要准备下一次传输，准备发送数据，使用peripherals_spi_push_data建立发射DMA。 清除中断标志。 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { peripherals_spi_read_data(); peripherals_spi_push_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 使用流程 设置IO，setup_peripherals_spi_pin()。 初始化SPI，setup_peripherals_spi_module()。 初始化DMA，setup_peripherals_dma_module()。 设置接收DMA，peripherals_spi_read_data()。 设置发射DMA，peripherals_spi_push_data()。 观察SPI中断，中断触发代表当前接收结束。 13.2.5 其他配置 13.2.5.1 时钟配置（pParam.eSclkDiv） 13.2.5.1.1 默认配置 对于默认配置，SPI时钟的配置通过 pParam.eSclkDiv 来实现，计算公式为：\\((spi\\quad interface\\quad clock)/(2\\times(eSclkDiv + 1))\\)，其中默认配置下，spi interface clock 为24M，因此可以得到不同时钟下的eSclkDiv： #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_6M (1) #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_4M (2) #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_3M (3) #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M4 (4) #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M (5) 13.2.5.1.2 高速时钟配置 SPI0和SPI1的高速时钟配置有一些不同，注意：高速时钟需要使用特定的IO，请查看SPI高速时钟和pin的映射。 13.2.5.1.2.1 SPI0 对于更高的时钟，需要在配置pParam.eSclkDiv之前打开额外配置，打开方式如下 首先通过SYSCTRL_GetPLLClk()获取PLL时钟，此处假设为336M。 切换SPI0到高速时钟SYSCTRL_SelectSpiClk(SPI_PORT_0,SYSCTRL_CLK_HCLK+1),此处的入参代表分频比2，即最终的spi interface clock为\\(336/2 = 168.0M\\)。 通过计算公式\\((spi\\quad interface\\quad clock)/(2\\times(eSclkDiv + 1))\\) 得到不同时钟下的eSclkDiv。 通过SYSCTRL_GetClk(SYSCTRL_ITEM_AHB_SPI0)来确认interface clock是否生效。 在以上举例中，可以使用以下宏定义来配置pParam.eSclkDiv #define SPI_INTERFACETIMINGSCLKDIV_SPI0_21M (1) #define SPI_INTERFACETIMINGSCLKDIV_SPI0_14M (2) 以下的API可以实现相同的功能，假设PLL时钟为336M，入参为21000000(21M),则该API可以完成SPI0时钟配置，并且返回eSclkDiv。入参需要和PLL成倍数关系。 uint8_t setup_peripherals_spi_0_high_speed_interface_clk(uint32_t spiClk) { //for spi0 only uint8_t eSclkDiv = 0; uint32_t spiIntfClk; uint32_t pllClk = SYSCTRL_GetPLLClk()； SYSCTRL_SelectSpiClk(SPI_PORT_0,SYSCTRL_CLK_PLL_DIV_1+1); spiIntfClk = SYSCTRL_GetClk(SYSCTRL_ITEM_AHB_SPI0); eSclkDiv = ((spiIntfClk/spiClk)/2)-1; return eSclkDiv; } 调用方式为： pParam.eSclkDiv = setup_peripherals_spi_0_high_speed_interface_clk(21000000); 13.2.5.1.2.2 SPI1 对于更高的时钟，需要在配置pParam.eSclkDiv之前打开HCLK配置，打开方式如下： 首先查看HCLK频率:SYSCTRL_GetHClk()。 如果有需要可以使用SYSCTRL_SelectHClk(SYSCTRL_CLK_PLL_DIV_1+3);来修改HCLK时钟。修改方法为，首先使用SYSCTRL_GetPLLClk()获取PLL时钟，入参为分频比，假如PLL时钟为336M，则SYSCTRL_CLK_PLL_DIV_1+6为7分频，最终HClk为336/7=48M。 将SPI1时钟切换到HCLK:SYSCTRL_SelectSpiClk(SPI_PORT_1,SYSCTRL_CLK_HCLK)。 通过计算公式\\((spi\\quad interface\\quad clock)/(2\\times(eSclkDiv + 1))\\) 得到不同时钟下的eSclkDiv。 通过SYSCTRL_GetClk(SYSCTRL_ITEM_APB_SPI1)来确认interface clock是否生效。 假设HCLK为112M（即spi interface clock），通过计算公式可以得到不同时钟下的eSclkDiv为： #define SPI_INTERFACETIMINGSCLKDIV_SPI1_19M (2) #define SPI_INTERFACETIMINGSCLKDIV_SPI1_14M (3) 以下的API可以实现相同的功能，假设HCLK时钟为112M，入参为14000000(14M),则该API可以完成SPI1时钟配置，并且返回eSclkDiv。入参需要和HCLK成倍数关系 uint8_t setup_peripherals_spi_1_high_speed_interface_clk(uint32_t spiClk) { uint8_t eSclkDiv = 0; uint32_t spiIntfClk; uint32_t hClk = SYSCTRL_GetHClk(); SYSCTRL_SelectSpiClk(SPI_PORT_1,SYSCTRL_CLK_HCLK); spiIntfClk = SYSCTRL_GetClk(SYSCTRL_ITEM_APB_SPI1); eSclkDiv = ((spiIntfClk/spiClk)/2)-1; return eSclkDiv; } 调用方式为： pParam.eSclkDiv = setup_peripherals_spi_1_high_speed_interface_clk(14000000); 13.2.5.2 QSPI 使用 QSPI的bit顺序以及MOSI/MISO的含义和普通SPI不同，但大部分读写的配置是共享的。 使用QSPI需要在普通SPI的配置的基础上，做一些额外修改： 13.2.5.2.1 IO 配置 QSPI用到了CLK,CS,MOSI,MISO,HOLD,WP,主从都需要配置为输入输出： PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); PINCTRL_SetPadMux(SPI_MIC_WP, IO_SOURCE_SPI1_WP_OUT); PINCTRL_SetPadMux(SPI_MIC_HOLD, IO_SOURCE_SPI1_HOLD_OUT); 对于Slave，则还需要额外配置CS的内部上拉： PINCTRL_Pull(SPI_MIC_CLK,PINCTRL_PULL_DOWN); PINCTRL_Pull(SPI_MIC_CS,PINCTRL_PULL_UP); 13.2.5.2.2 QSPI Master 13.2.5.2.2.1 pParam 配置 QSPI的部分pParam参数需要修改为如下，同时Addr和Cmd需要打开： pParam.eQuadMode = SPI_DUALQUAD_QUAD_IO_MODE; pParam.SlaveDataOnly = SPI_SLVDATAONLY_DISABLE; pParam.eAddrEn = SPI_ADDREN_ENABLE; pParam.eCmdEn = SPI_CMDEN_ENABLE; 此外，Master还需要配置pParam.eReadWriteMode, 例如： SPI_TRANSMODE_WRITE_READ： 读和写顺序执行，比如首先利用四线完成写操作，然后再读。 SPI_TRANSMODE_WRITE_DUMMY_READ： 先写后读，在Write和Read之间添加dummy（默认为8个clk cycle）。 对于Slave，则读写顺序相反： SPI_TRANSMODE_READ_WRITE：先读后写。 SPI_TRANSMODE_READ_DUMMY_WRITE： 先读后写，在Read和Write之间添加dummy（默认为8个clk cycle）。 SPI_TransCtrl_TransMode_e定义了可以使用的pParam.eReadWriteMode。 配置参数举例： #define SPI_MASTER_PARAM(DataLen) { SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M, \\ SPI_CPHA_ODD_SCLK_EDGES, SPI_CPOL_SCLK_LOW_IN_IDLE_STATES, \\ SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST, SPI_DATALEN_32_BITS, SPI_SLVMODE_MASTER_MODE, \\ SPI_TRANSMODE_WRITE_DUMMY_READ, SPI_DUALQUAD_QUAD_IO_MODE, DataLen, DataLen, \\ SPI_ADDREN_ENABLE, SPI_CMDEN_ENABLE, (1 &lt;&lt; bsSPI_INTREN_ENDINTEN), \\ 0, 0, SPI_SLVDATAONLY_DISABLE, SPI_ADDRLEN_1_BYTE } #define SPI_SLAVE_PARAM(DataLen) { SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M, \\ SPI_CPHA_ODD_SCLK_EDGES, SPI_CPOL_SCLK_LOW_IN_IDLE_STATES, \\ SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST, SPI_DATALEN_32_BITS, SPI_SLVMODE_SLAVE_MODE, \\ SPI_TRANSMODE_READ_DUMMY_WRITE, SPI_DUALQUAD_QUAD_IO_MODE, DataLen, DataLen, \\ SPI_ADDREN_ENABLE, SPI_CMDEN_ENABLE, (1 &lt;&lt; bsSPI_INTREN_ENDINTEN), \\ 0, 0, SPI_SLVDATAONLY_DISABLE, SPI_ADDRLEN_1_BYTE } 13.2.5.2.2.2 Dummy cnt 配置 pParam.eReadWriteMode中指定了dummy的位置，通过apSSP_SetTransferControlDummyCnt配置dummy个数。 API的入参为dummy cnt，通过以下关系转换成API CLK的dummy cycles。 \\(cycles = (dummy \\quad cnt + 1) \\times ((pParam.eDataSize) / (spi \\quad io \\quad width))\\) dummy cnt + 1 pParam.eDataSize spi io width cycles 1 8 1(single) 8 1 32 4(quad-qspi) 8 以上述的参数配置为例，则下述API可以将dummy cycle配置为16： apSSP_SetTransferControlDummyCnt(APB_SSP1, 1);//dummy cnt = 1; 注意，额外的配置需要在apSSP_DeviceParametersSet之后以避免参数覆盖。 13.2.5.2.2.3 Addr 格式 QSPI的Command和Addr通过apSSP_WriteCmd配置，首先发送Command，Command固定占用MOSI的8个cycle， 然后发送Addr，Addr的长度通过pParam.eAddrLen配置，发送格式通过apSSP_SetTransferControlAddrFmt配置。 SPI_ADDRFMT_SINGLE_MODE: 默认配置，Addr只占用MOSI SPI_ADDRFMT_QUAD_MODE：Addr以QSPI的模式发送，占用MOSI,MISO,WP,HOLD 该API只适用于SPI Master。 假如Addr配置为3字节以及QUAD MODE，则传输格式为： 13.2.5.2.2.4 QSPI 读取和XIP 当通过SPI外接FLASH模块的时候，可以通过芯片内置功能直接读取FLASH内容而不需要操作SPI。该功能只支持SPI0。 操作步骤为， 首先打开时钟并且配置SPI IO， 参考时钟以及IO配置。对于QSPI，请参考QSPI的IO配置。 IO必须使用高速时钟和IO映射中SPI0的指定IO。 然后需要额外打开SPI的直接读取功能（不需要其他的SPI模块配置） void apSSP_SetMemAccessCmd(SSP_TypeDef *SPI_BASE, apSSP_sDeviceMemRdCmd cmd); cmd用来选择FLASH的读取命令，该命令需要查看对应的FLASH手册来获取。apSSP_sDeviceMemRdCmd中 列出了所有支持的读取命令以及该命令的格式： typedef enum { SPI_MEMRD_CMD_03 = 0 ,//read command 0x03 + 3bytes address(regular mode) + data (regular mode) SPI_MEMRD_CMD_0B = 1 ,//read command 0x0B + 3bytes address(regular mode) + 1byte dummy + data (regular mode) SPI_MEMRD_CMD_3B = 2 ,//read command 0x3B + 3bytes address(regular mode) + 1byte dummy + data (dual mode) SPI_MEMRD_CMD_6B = 3 ,//read command 0x6B + 3bytes address(regular mode) + 1byte dummy + data (quad mode) SPI_MEMRD_CMD_BB = 4 ,//read command 0xBB + 3bytes + 1byte 0 address(dual mode) + data (dual mode) SPI_MEMRD_CMD_EB = 5 ,//read command 0xEB + 3bytes + 1byte 0 address(quad mode) + 2bytes dummy + data (quad mode) SPI_MEMRD_CMD_13 = 8 ,//read command 0x13 + 4bytes address(regular mode) + data (regular mode) SPI_MEMRD_CMD_0C = 9 ,//read command 0x0C + 4bytes address(regular mode) + 1byte dummy + data (regular mode) SPI_MEMRD_CMD_3C = 10,//read command 0x3C + 4bytes address(regular mode) + 1byte dummy + data (dual mode) SPI_MEMRD_CMD_6C = 11,//read command 0x6C + 4bytes address(regular mode) + 1byte dummy + data (quad mode) SPI_MEMRD_CMD_BC = 12,//read command 0xBC + 4bytes + 1byte 0 address(dual mode) + data (dual mode) SPI_MEMRD_CMD_EC = 13,//read command 0xEC + 4bytes + 1byte 0 address(quad mode) + 2bytes dummy + data (quad mode) }apSSP_sDeviceMemRdCmd; 以SPI_MEMRD_CMD_EB为例，该命令的格式为：command(0xEB)+address(4bytes)+dummy(2bytes)+data(quad mode) 直接读取外置FLASH的内容 外置FLASH的内容映射在AHB_QSPI_MEM_BASE开始的连续空间（32MB）。 使用举例： setup_peripherals_spi_pin(); apSSP_SetMemAccessCmd(AHB_SSP0, SPI_MEMRD_CMD_EB); // read by *((uint8_t*)AHB_QSPI_MEM_BASE + i), i=[0,32MB) XIP 通过SPI模块下载程序到外置FLASH模块，然后跳转到外置FLASH地址来执行代码。 13.2.5.2.3 QSPI Slave Addr只适用于Master，当作为Slave的时候，只支持Command命令。Slave在QSPI下集成了 两个Command: QSPI read only: 0x0E 格式固定为：Command(单线，8bit) + Dummy(单线，8bit) + read Data(四线) QSPI write only: 0x54 格式固定为：Command(单线，8bit) + Dummy(单线，8bit) + write Data(四线) 当使用这两个Command的时候，Master需要按照上述格式配置。 13.2.5.3 高速时钟和IO映射 只有SPI0支持XIP，最大时钟速率和VBAT有关： Function SPI0 SPI1 XIP 最大速率：96M（取决于VBAT） 不支持 SPI0和SPI1最大可以支持的时钟在不同场景下有区别： Function SPI0 SPI1 Master 传输中只有读或者写：96M 24M Master 传输中既有读也有写：48M 24M Slave 24M 24M 高速时钟对IO能力有要求，因此对于时钟大于20M的情况，需要使用以下固定的IO，其中SPI0的IO映射固定。对于SPI1，SCLK必须使用IO7，其他IO8/9/10/11/12可以任意配置。 SPI0 SPI1 GPIO36:CS GPIO7: SCLK GPIO37:SCLK GPIO8: CS/HOLD/WP/MISO/MOSI GPIO38:HOLD GPIO9: CS/HOLD/WP/MISO/MOSI GPIO39:WP GPIO10:CS/HOLD/WP/MISO/MOSI GPIO40:MISO GPIO11:CS/HOLD/WP/MISO/MOSI GPIO41:MOSI GPIO12:CS/HOLD/WP/MISO/MOSI "],["ch-sysctrl.html", "14 系统控制（SYSCTRL） 14.1 功能概述 14.2 使用说明", " 14 系统控制（SYSCTRL） 14.1 功能概述 SYSCTRL 负责管理、控制各种片上外设，主要功能有： 外设的复位 外设的时钟管理，包括时钟源、频率设置、门控等 DMA 规划 其它功能 14.1.1 外设标识 SYSCTRL 为外设定义了几种不同的标识。最常见的一种标识为： typedef enum { SYSCTRL_ITEM_APB_GPIO0 , SYSCTRL_ITEM_APB_GPIO1 , // ... SYSCTRL_ITEM_NUMBER, } SYSCTRL_Item; 这种标识用于外设的复位、时钟门控等。SYSCTRL_ResetItem 和 SYSCTRL_ClkGateItem 是 SYSCTRL_Item 的两个别名。 下面这种标识用于 DMA 规划： typedef enum { SYSCTRL_DMA_UART0_RX = 0, SYSCTRL_DMA_UART1_RX = 1, //... } SYSCTRL_DMA; 14.1.2 时钟树 从源头看，共有 4 个时钟源： 内部 32KiHz RC 时钟； 外部 32768Hz 晶体； 内部高速 RC 时钟（8M/16M/24M/32M/48M 可调）； 外部 24MHz 晶体。 从 4 个时钟源出发，得到两组时钟： 32KiHz 时钟（clk_32k） 32k 时钟有两个来源：内部 32KiHz RC 电路，外部 32768Hz 晶体。 慢时钟 慢时钟有两个来源：内部高速 RC 时钟，外部 24MHz 晶体。 BLE 子系统中射频相关的部分固定使用外部 24MHz 晶体提供的时钟。 之后， PLL 输出（clk_pll） clk_pll 的频率 \\(f_{pll}\\) 可配置，受 \\(div_{pre}\\)（前置分频）、\\(loop\\)（环路分频）和 \\(div_{output}\\)（输出分频）等 3 个参数控制： \\[f_{vco}=\\frac{f_{in}\\times loop}{div_{pre}}\\] \\[f_{pll}=\\frac{f_{vco}}{div_{output}}\\] 这里，\\(f_{in}\\) 即慢时钟。要求 \\(f_{vco} \\in [60,600]MHz\\)， \\(f_{in}/div_{pre} \\in [2,24]MHz\\)。 sclk_fast 与 sclk_slow clk_pll 经过门控后的时钟称为 sclk_fast，慢时钟经过门控后称为 sclk_slow。 hclk sclk_fast 经过分频后得到 hclk。下列外设（包括 CPU）固定使用这个时钟3： DMA 片内 Flash QSPI USB4 其它内部模块如 AES、Cache 等 hclk 经过分频后得到 pclk。pclk 主要用于硬件内部接口。 sclk_slow 的进一步分频 sclk_slow 经过若干独立的分频器得到以下多种时钟： sclk_slow_pwm_div：专供 PWM 选择使用 sclk_slow_timer_div：供 TIMER0、TIMER1、TIMER2 选择使用 sclk_slow_ks_div：专供 KeyScan 选择使用 sclk_slow_adc_div：供 EFUSE、ADC、IR 选择使用 sclk_slow_pdm_div：专供 PDM 选择使用 sclk_fast 的进一步分频： sclk_fast 经过若干独立的分频器得到以下多种时钟： sclk_fast_i2s_div：专供 I2S 选择使用 sclk_fast_qspi_div：专供 SPI0 选择使用 sclk_fast_flash_div：专供片内 Flash 选择使用 sclk_fast_usb_div：专供 USB 使用 各硬件外设可配置的时钟源汇总如表 14.1。 表 14.1: 各硬件外设的时钟源 外设 时钟源 GPIO0、GPIO1 选择 sclk_slow 或者 clk_32k TMR0、TMR1、TMR2 独立配置 sclk_slow_timer_div 或者 clk_32k WDT clk_32k PWM sclk_slow_pwm_div 或者 clk_32k PDM sclk_slow_pdm_div QDEC 对 hclk 或者 sclk_slow KeyScan sclk_slow_ks_div 或者 clk_32k IR、ADC、EFUSE 独立配置 sclk_slow_adc_div 或者 sclk_slow DMA hclk SPI0 sclk_fast_qspi_div 或者 sclk_slow I2S sclk_fast_i2s_div 或者 sclk_slow UART0、UART1、SPI1 独立配置 hclk 或者 sclk_slow I2C0、I2C1 pclk 14.1.3 DMA 规划 由于 DMA 支持的硬件握手信号只有 16 种，无法同时支持所有外设。 因此需要事先确定将要的外设握手信号，并通过 SYSCTRL_SelectUsedDmaItems 接口声明。 规划DMA通道需要同时将需要支持的16个DMA通道的握手信号传入 SYSCTRL_SelectUsedDmaItems 接口。 一个外设可能具备一个以上的握手信号，需要注意区分。比如 UART0 有两个握手信号 UART0_RX 和 UART0_TX，分别用于触发 DMA 发送请求（通过 DMA 传输接收到的数据）和读取请求（向 DMA 请 求新的待发送数据）。外设握手信号定义在 SYSCTRL_DMA 内： typedef enum { SYSCTRL_DMA_UART0_RX = 0, SYSCTRL_DMA_UART1_RX = 1, // ... } SYSCTRL_DMA; 14.2 使用说明 14.2.1 外设复位 通过 SYSCTRL_ResetBlock 复位外设，通过 SYSCTRL_ReleaseBlock 释放复位。 void SYSCTRL_ResetBlock(SYSCTRL_ResetItem item); void SYSCTRL_ReleaseBlock(SYSCTRL_ResetItem item); 14.2.2 时钟门控 通过 SYSCTRL_SetClkGate 设置门控（即关闭时钟），通过 SYSCTRL_ClearClkGate 消除门控（即恢复时钟）。 void SYSCTRL_SetClkGate(SYSCTRL_ClkGateItem item); void SYSCTRL_ClearClkGate(SYSCTRL_ClkGateItem item); SYSCTRL_SetClkGateMulti 和 SYSCTRL_ClearClkGateMulti 可以同时控制多个外设的门控。 items 参数里的各个比特与 SYSCTRL_ClkGateItem 里的各个外设一一对应。 void SYSCTRL_SetClkGateMulti(uint32_t items); void SYSCTRL_ClearClkGateMulti(uint32_t items); 14.2.3 时钟配置 举例如下。 clk_pll 与 hclk 使用 SYSCTRL_ConfigPLLClk 配置 clk_pll： int SYSCTRL_ConfigPLLClk( uint32_t div_pre, // 前置分频 uint32_t loop, // 环路倍频 uint32_t div_output // 输出分频 ); 例如，假设慢时钟配置为 24MHz，下面的代码将 hclk 配置为 112MHz 并读取到变量： SYSCTRL_ConfigPLLClk(5, 70, 1); SYSCTRL_SelectHClk(SYSCTRL_CLK_PLL_DIV_3); uint32_t SystemCoreClock = SYSCTRL_GetHClk(); 为硬件 I2S 配置时钟 使用 SYSCTRL_SelectI2sClk 为 I2S 配置时钟： void SYSCTRL_SelectI2sClk(SYSCTRL_ClkMode mode); SYSCTRL_ClkMode 的定义为： typedef enum { SYSCTRL_CLK_SLOW, // 使用 sclk_slow SYSCTRL_CLK_32k = ..., // 使用 32KiHz 时钟 SYSCTRL_CLK_HCLK, // 使用 hclk SYSCTRL_CLK_ADC_DIV = ..., // 使用 sclk_slow_adc_div SYSCTRL_CLK_PLL_DIV_1 = ..., // 对 sclk_fast 分频 SYSCTRL_CLK_SLOW_DIV_1 = ..., // 对 sclk_slow 分配 } SYSCTRL_ClkMode; 根据表 14.1 可知，I2S 可使用 slk_slow： SYSCTRL_SelectI2sClk(SYSCTRL_CLK_SLOW); 或者独占一个分频器，对 sclk_fast 分频得到 sclk_fast_i2s_div，比如使用 sclk_fast 的 5 分频： SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_5); 读取时钟频率 使用 SYSCTRL_GetClk 读取指定外设的时钟频率： uint32_t SYSCTRL_GetClk(SYSCTRL_Item item); 比如， // I2S 使用 PLL 的 5 分频 SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_5); // freq = sclk_fast 的频率 / 5 uint32_t freq = SYSCTRL_GetClk(SYSCTRL_ITEM_APB_I2S); 降低频率以节省功耗 降低系统各时钟的频率可以显著降低动态功耗。相关函数有： SYSCTRL_SelectHClk：选择 hclk SYSCTRL_SelectFlashClk：选择内部 Flash 时钟 SYSCTRL_SelectSlowClk：选择慢时钟 SYSCTRL_EnablePLL：开关 PLL 配置用于慢时钟的高速 RC 时钟 通过 SYSCTRL_EnableSlowRC 可以使能并配置内部高速 RC 时钟的频率模式： void SYSCTRL_EnableSlowRC( uint8_t enable, // 使能或禁用 SYSCTRL_SlowRCClkMode mode // 频率模式 ); 频率模式为： typedef enum { SYSCTRL_SLOW_RC_8M = ..., SYSCTRL_SLOW_RC_16M = ..., SYSCTRL_SLOW_RC_24M = ..., SYSCTRL_SLOW_RC_32M = ..., SYSCTRL_SLOW_RC_48M = ..., } SYSCTRL_SlowRCClkMode; 由于内部（芯片之间）、外部环境（温度）存在微小差异或变化，所以这个 RC 时钟的频率或存在一定误差， 需要进行调谐以尽量接近标称值。通过 SYSCTRL_AutoTuneSlowRC 可自动完成调谐5： uint32_t SYSCTRL_AutoTuneSlowRC(SYSCTRL_SlowRCClkMode value); 这个函数返回的数据为调谐参数。如果认为有必要6，可以把此参数储存起来，如果系统重启， 可通过 SYSCTRL_TuneSlowRC 直接写入参数调谐频率。 温馨提示： 关闭 PLL 时，务必先将 CPU、Flash 时钟切换至慢时钟； 修改慢时钟配置时，需要保证 PLL 的输出、CPU 时钟等在支持的频率内； 推荐使用 SDK 提供的工具生成时钟配置代码，规避错误配置。 14.2.4 DMA 规划 使用 SYSCTRL_SelectUsedDmaItems 配置要使用的 DMA 握手信号： int SYSCTRL_SelectUsedDmaItems( uint32_t items // 各比特与 SYSCTRL_DMA 一一对应 ); 使用 SYSCTRL_GetDmaId 可获取为某外设握手信号的 DMA 信号 ID，如果返回 -1， 说明没有规划该外设握手信号7： int SYSCTRL_GetDmaId(SYSCTRL_DMA item); 14.2.5 唤醒后的时钟配置 ROM 内的启动程序包含一个时钟配置程序，当系统初始上电或者从低功耗状态唤醒时， 这个程序就按照预定参数配置几个关键时钟及看门狗。 默认情况下，这个时钟配置程序是打开的，所使用的预定参数如下： PLL：打开，div_pre、loop、div_output 分别为 5、70、1； hclk：clk_pll 3 分频； 片内 Flash 时钟：clk_pll 2 分频； 看门狗：不使能。 由于初始上电或者唤醒后，慢时钟来自外部 24MHz 晶体， 可计算出上述几个时钟的频率如表 14.2。 表 14.2: 默认参数对应的时钟频率 时钟 频率（MHz） PLL 336 hclk 112 片内 Flash 168 通过以下两个函数向这个程序传递参数： 使能这个程序并设置参数 void SYSCTRL_EnableConfigClocksAfterWakeup( uint8_t enable_pll, // 是否使能 PLL uint8_t pll_loop, // PLL loop SYSCTRL_ClkMode hclk, // hclk SYSCTRL_ClkMode flash_clk, // 片内 Flash 时钟 uint8_t enable_watchdog); // 是否使能看门狗 如果使能看门狗，系统唤醒后，时钟配置程序将其配置为 \\(4.5s\\) 后触发超时、复位系统。 禁用这个程序 void SYSCTRL_DisableConfigClocksAfterWakeup(void); 如果禁用这个程序，系统唤醒后几个时钟的频率见表 14.3。 表 14.3: 禁用时钟配置程序时重新唤醒后几个关键时钟的频率 时钟 频率（MHz） PLL 384 hclk 24 片内 Flash 24 14.2.6 RAM 相关 SoC 内部包含多个内存块，根据用途可分为：仅供 CPU 使用的 SYS RAM，CPU 和蓝牙 Modem 皆可使用的 SHARE RAM 以及高速缓存（Cache）。部分内存块既可以作为 SYS RAM 也可以作为 SHARE RAM（见表 14.4）， 在不同的软件包内将被配置为不同用途。 表 14.4: 可作为 SYS/SHARE RAM 的内存块 名称 大小 (KiB) 配置为 SYS RAM 时的地址范围 配置为 SHARE RAM 时的地址范围 备注 SYS_MEM_BLOCK_0 16 0x20000000~0x20003FFF 不支持 不可关闭 SYS_MEM_BLOCK_1 16 0x20004000~0x20007FFF 0x40128000~0x4012BFFF REMAPPABLE_BLOCK_0 16 0x20008000~0x2000BFFF 0x40124000~0x40127FFF REMAPPABLE_BLOCK_1 8 0x2000C000~0x2000DFFF 0x40122000~0x40123FFF SHARE_MEM_BLOCK_0 8 不支持 0x40120000~0x40121FFF 在 noos_mini, mini 软件包共配置 56 KiB SYS RAM，8 KiB SHARE RAM； 在其它软件包里，SYS、SHARE RAM 各 32 KiB。详见表 14.5。 注意，虽然 SYS_MEM_BLOCK_1 也可用作 SHARE RAM，但是在所有的软件包里它总是被用作 SYS RAM。 表 14.5: 各软件包里的 SYS/SHARE RAM 配置 名称 SYS RAM SHARE RAM 地址范围 包含的内存块 地址范围 包含的内存块 mini, noos_mini 0x20000000 ~ 0x2000DFFF SYS_MEM_BLOCK_0 SYS_MEM_BLOCK_1 REMAPPABLE_BLOCK_0 REMAPPABLE_BLOCK_1 0x40120000 ~ 0x40121FFF SHARE_MEM_BLOCK_0 其它 0x20000000 ~ 0x20007FFF SYS_MEM_BLOCK_0 SYS_MEM_BLOCK_1 0x40120000 ~ 0x40127FFF SHARE_MEM_BLOCK_0 REMAPPABLE_BLOCK_0 REMAPPABLE_BLOCK_1 表 14.4 中的内存块支持低功耗数据保持。 所有这些内存块默认都是开启的，部分内存块可关闭以节省功耗。如果程序中实际用到的 SYS RAM 较少，可通过 SYSCTRL_SelectMemoryBlocks 选择所要使用的内存块，并关闭不使用的内存块： void SYSCTRL_SelectMemoryBlocks( uint32_t block_map); 例如在一个使用 mini 软件包的程序里，如果确认只需要 32 KiB 的 SYS RAM，那么为了降低功耗，可关闭 REMAPPABLE_BLOCK_0 和 REMAPPABLE_BLOCK_1，保留其它内存块： SYSCTRL_SelectMemoryBlocks( SYSCTRL_SYS_MEM_BLOCK_0 | SYSCTRL_SYS_MEM_BLOCK_1 | SYSCTRL_SHARE_MEM_BLOCK_0); 另有 2 个内存块可配置为 SYS RAM 或者高速缓存，其配置可通过 SYSCTRL_CacheControl 动态修改。 将其映射为 SYS RAM 后，可按照表 14.6 中的地址访问。 表 14.6: 可用作高速缓存的内存块 名称 大小 (KiB) 配置为 SYS RAM 时的地址范围 D-Cache-M 8 0x2000E000~0x2000FFFF I-Cache-M 8 0x20010000~0x20011FFF 这两个内存块都默认处于 Cache 模式。当需要更多的 RAM 时，通过 SYSCTRL_CacheControl 可将这两块内存映射为普通 RAM： void SYSCTRL_CacheControl( SYSCTRL_CacheMemCtrl i_cache, SYSCTRL_CacheMemCtrl d_cache ); SYSCTRL_CacheMemCtrl 包含两个值，对应 Cache 模式和 SYS MEM 模式： typedef enum { SYSCTRL_MEM_BLOCK_AS_CACHE = 0, SYSCTRL_MEM_BLOCK_AS_SYS_MEM = 1, } SYSCTRL_CacheMemCtrl; 务必注意： 从低功耗状态唤醒时，这两个内存块都将恢复默认值 AS_CACHE； 低功耗状态时，这两个内存块里的数据（无论处于哪种模式）都会丢失； 映射为普通 RAM 后，系统缺少高速缓存，性能有可能明显下降。 每个外设可单独对 hclk 门控。↩︎ 仅高速时钟。↩︎ 以 24MHz 晶体为参考。↩︎ 比如认为 SYSCTRL_AutoTuneSlowRC 耗时过长。↩︎ SYSCTRL_SelectUsedDmaItems 的 items 参数里对应的比特为 0↩︎ "],["ch-timer.html", "15 定时器（TIMER） 15.1 功能概述 15.2 使用说明 15.3 使用示例", " 15 定时器（TIMER） 15.1 功能概述 ING20XX系列具有功能完全相同的3个计时器，每个计时器包含两个通道，每个通道支持1个32位计时器， 所以系统中一共有6个32位计时器。既可以用作脉冲宽度调制器(PWM)，也可以用作简单的定时器。 特性： 支持AMBA2.0 支持APB总线 最多4个多功能定时器 提供6种使用场景（定时器和PWM的组合） 计时器时钟源可选 计时器可以暂停 15.2 使用说明 15.2.1 设置TIMER工作模式 使用 TMR_SetOpMode 设置TIMER的工作模式。 void TMR_SetOpMode( TMR_TypeDef *pTMR, //定时器外设地址 uint8_t ch_id, //通道ID uint8_t op_mode, //工作模式 uint8_t clk_mode, //时钟模式 uint8_t pwm_park_value ); 关于 TMR_SetOpMode 中的参数 pwm_park_value 的值将影响PWM的输出： 若为0：通道被禁用时，PWM输出为低电平；通道启用时，较低周期的PWM计数器先计数； 若为1：通道被禁用时，PWM输出为高电平；通道启用时，较高周期的PWM计数器先计数； TIMER具有6种不同的工作模式，可以大致分为三类：定时器功能、PWM功能、（定时器+PWM）组合功能。 定时器功能 32位定时器可以分别作为1个32位定时器、2个16位定时器、4个8位定时器，定义如下所示。 #define TMR_CTL_OP_MODE_32BIT_TIMER_x1 1 // one 32bit timer #define TMR_CTL_OP_MODE_16BIT_TIMER_x2 2 // dual 16bit timers #define TMR_CTL_OP_MODE_8BIT_TIMER_x4 3 // four 8bit timers 脉冲宽度调制器功能 定时器的本质其实是计数器，所以可以拆分为2个16位的计数器来产生PWM信号。 #define TMR_CTL_OP_MODE_16BIT_PWM 4 // PWM with two 16bit counters 组合功能 定时器与PWM的功能可以组合使用，对应的组合方式有两种：1）一个8bitPWM和一个16位计时器； 2）一个8位PWM和两个8位计时器。 #define TMR_CTL_OP_MODE_8BIT_PWM_16BIT_TIMER_x1 6 // MIXED: PWM with two 8bit counters + one 16bit timer #define TMR_CTL_OP_MODE_8BIT_PWM_8BIT_TIMER_x2 7 // MIXED: PWM with two 8bit counters + dual 8bit timer 注意: 要更改当前工作的定时器通道模式，必须先禁用该通道,然后将通道设置为新模式并启用它。 TIMER的时钟源有两种，分别是内部时钟和外部时钟，定义如下所示。 #define TMR_CLK_MODE_EXTERNAL 0 //external clock #define TMR_CLK_MODE_APB 1 //internal clock 15.2.2 获取时钟频率 使用 TMR_GetClk 获取TIMER某个通道的时钟频率。 uint32_t TMR_GetClk( TMR_TypeDef *pTMR, uint8_t ch_id ); 15.2.3 重载值 使用 TMR_SetReload 设置 TIMER 某个通道的重载值。 void TMR_SetReload( TMR_TypeDef *pTMR, uint8_t ch_id, //通道ID uint32_t value ); 在不同的TIMER模式中， value 的值分配如下表。 Table: (#tab:ch-timer-value-distribute) TIMER模式 bits[0:7] bits[8:15] bits[16:23] bits[24:31] TMR_CTL_OP_MODE_32BIT_TIMER_x1 TMR_CTL_OP_MODE_16BIT_TIMER_x2 TMR_CTL_OP_MODE_8BIT_TIMER_x4 Timer0 Timer1 Timer2 TMR_CTL_OP_MODE_16BIT_PWM TMR_CTL_OP_MODE_8BIT_PWM_16BIT_TIMER_x1 PWM low period PWM high period TMR_CTL_OP_MODE_8BIT_PWM_8BIT_TIMER_x2 Timer0 Timer1 PWM low period PWM high period 关于上述格中分配的重载值有两点说明： 定时器模式下，某个 Timer 在其（重载值 + 1）个计数周期产生一次中断； PWM模式下， 高周期和低周期的频率值分别是对应重载值 + 1。 15.2.4 使能TIMER 使用 TMR_Enable 使能对应通道上的一个或多个timer。 void TMR_Enable( TMR_TypeDef *pTMR, uint8_t ch_id, uint8_t mask //比特 0 为 1 配置TIMER0 //比特 1 为 1 配置TIMER1 //比特 2 为 1 配置TIMER2 //比特 3 为 1 配置TIMER3 ); 注意，如果相应的通道 不存在 或在通道模式中它 不是一个有效的设备 ，则定时器或PWM不能被启用。 例如，当0号通道设置为32位定时器模式时，0号通道的Timer 1不能使能。 15.2.5 获取TIMER的比较值 使用 TMR_GetCMP 获取定时器的比较输出。 uint32_t TMR_GetCMP( TMR_TypeDef *pTMR, uint8_t ch_id ); 15.2.6 获取TIMER的计数器值 使用 TMR_GetCNT 获取定时器的计数值。 uint32_t TMR_GetCNT( TMR_TypeDef *pTMR, uint8_t ch_id ); 15.2.7 计时器暂停 使用 TMR_PauseEnable 可以将计时器暂停，计时器的counter将保持当前的计数值，取消暂停之后将恢复计数。 void TMR_PauseEnable( TMR_TypeDef *pTMR, uint8_t enable ); 15.2.8 配置中断请求 使用 TMR_IntEnable 配置并使能TIMER中断。 void TMR_IntEnable( TMR_TypeDef *pTMR, uint8_t ch_id, uint8_t mask ); 15.2.9 处理中断状态 使用 TMR_IntHappened 一次性获取某个通道上所有 Timer （最多 4 个 Timer ）的中断触发状态，返回非 0 值表示该 Timer 上产生了中断请求。第 \\(n\\) 比特（第 0 比特为最低比特）对应 Timer \\(n\\) 上的中断触发状态。 uint8_t TMR_IntHappened ( TMR_TypeDef *pTMR, uint8_t ch_id ); 使用 TMR_IntClr 可以一次性清除某个通道上所有定时器的中断状态。 void TMR_IntClr( TMR_TypeDef *pTMR, uint8_t ch_id, uint8_t mask //比特 0 为 1 清除对应通道上的 Timer0 //比特 1 为 1 清除对应通道上的 Timer1 //比特 2 为 1 清除对应通道上的 Timer2 //比特 3 为 1 清除对应通道上的 Timer3 ); 15.3 使用示例 15.3.1 使用计时器功能及暂停功能 将TIMER1的通道0设置为TMR_CTL_OP_MODE_32BIT_TIMER_x1模式，并设定每1秒产生一次中断： TMR_SetOpMode(APB_TMR1, 0, TMR_CTL_OP_MODE_32BIT_TIMER_x1, TMR_CLK_MODE_APB, 0); TMR_SetReload(APB_TMR1, 0, TMR_GetClk(APB_TMR1, 0)); //4999 TMR_Enable(APB_TMR1, 0, 0xf); TMR_IntEnable(APB_TMR1, 0, 0xf); 15.3.2 使用TIMER的PWM功能 将TIMER1的通道0的工作模式设置为 TMR_CTL_OP_MODE_16BIT_PWM ，并使用13号引脚输出10HzPWM信号。 #define PIN_TMR_PWM 13 static void setup_peripheral_timer(void) { SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) |(1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) |(1 &lt;&lt; SYSCTRL_ITEM_APB_TMR1)); SYSCTRL_SelectTimerClk(TMR_PORT_1, SYSCTRL_CLK_32k); TMR_SetOpMode(APB_TMR1, TMR_CTL_OP_MODE_16BIT_PWM, TMR_CLK_MODE_EXTERNAL, 0); TMR_SetReload(APB_TMR1, 0, 0x00090009); // 9 9 TMR_Enable(APB_TMR1, 0, 0xf); PINCTRL_SetPadMux(PIN_TMR_PWM, IO_SOURCE_TIMER1_PWM0_B); } 15.3.3 通道0产生2个周期性中断 使用TIMER1通道0生成2个中断:一个用于每1000个APB时钟周期，另一个用于每3000个APB周期。 static void setup_peripheral_timer(void) { SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) |(1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) |(1 &lt;&lt; SYSCTRL_ITEM_APB_TMR1)); SYSCTRL_SelectTimerClk(TMR_PORT_1, SYSCTRL_CLK_32k); TMR_SetOpMode(APB_TMR1, 0, TMR_CTL_OP_MODE_16BIT_TIMER_x2, TMR_CLK_MODE_APB, 0); TMR_SetReload(APB_TMR1, 0, 0x0BB703E7); // 2999 999 TMR_IntEnable(APB_TMR1, 0, 0x3); //Ch0Int0 Ch0Int1 TMR_Enable(APB_TMR1, 0, 0x3); //Ch0TMR0En Ch0TMR1En } 15.3.4 产生2路对齐的PWM信号 使用TIMER1的通道0和通道1分别生成两路PWM信号PWM0和PWM1，对应参数设置如下所示： PWM0:周期= 30个外部时钟周期，占空比= 1/3 PWM1:周期= 60个外部时钟周期，占空比= 1/3 将两路PWM对齐，并分别由引脚13、14输出。 #define PIN_TMR_PWM0 13 #define PIN_TMR_PWM1 14 static void setup_peripheral_timer(void) { SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) |(1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) |(1 &lt;&lt; SYSCTRL_ITEM_APB_TMR1)); SYSCTRL_SelectTimerClk(TMR_PORT_1, SYSCTRL_CLK_32k); TMR_SetOpMode(APB_TMR1, 0, TMR_CTL_OP_MODE_16BIT_PWM, TMR_CLK_MODE_EXTERNAL, 1); TMR_SetOpMode(APB_TMR1, 1, TMR_CTL_OP_MODE_16BIT_PWM, TMR_CLK_MODE_EXTERNAL, 1); TMR_SetReload(APB_TMR1, 0, 0x00090013); //9 19 TMR_SetReload(APB_TMR1, 1, 0x00130027); //19 39 TMR_Enable(APB_TMR1, 0, 0xf); TMR_Enable(APB_TMR1, 1, 0xf); PINCTRL_SetPadMux(PIN_TMR_PWM0, IO_SOURCE_TIMER1_PWM0_B); PINCTRL_SetPadMux(PIN_TMR_PWM1, IO_SOURCE_TIMER1_PWM1_A); } "],["ch-uart.html", "16 通用异步收发传输器（UART） 16.1 功能概述 16.2 使用说明 16.3 示例代码", " 16 通用异步收发传输器（UART） 16.1 功能概述 UART全称Universal Asynchronous Receiver/Transmitter，即通用异步收发传输器件。 UART对接收的数据执行串并转换，对发送的数据执行并串转换。 特性： 支持硬件流控 可编程波特率发生器，最高波特率可达7000000bps 独立的发送和接收 FIFO 单个组合中断，包括接收（包括超时）、传输、调制解调器状态和错误状态中断，每个中断可屏蔽 支持 DMA 方式 16.2 使用说明 16.2.1 设置波特率 使用 apUART_BaudRateSet 设置对应UART设备的波特率。 void apUART_BaudRateSet( UART_TypeDef* pBase, //UART参数结构体&amp;设备地址 uint32_t ClockFrequency, //时钟信号的频率 uint32_t BaudRate //波特率 ); 16.2.2 获取波特率 使用 apUART_BaudRateGet 获取对应UART设备的波特率。 uint32_t apUART_BaudRateGet ( UART_TypeDef* pBase, uint32_t ClockFrequency ); 16.2.3 UART初始化 在使用UART之前，需要先通过 apUART_Initialize 对UART进行初始化。 void apUART_Initialize( UART_TypeDef* pBase, UART_sStateStruct* UARTx, //uart状态结构体 uint32_t IntMask //中断掩码 ); 初始化 UART 之前需要初始化如下所示的 UART 状态结构体： typedef struct UART_xStateStruct { // Line Control Register, UARTLCR_H UART_eWLEN word_length; // WLEN UART_ePARITY parity; // PEN, EPS, SPS uint8_t fifo_enable; // FEN uint8_t two_stop_bits; // STP2 // Control Register, UARTCR uint8_t receive_en; // RXE uint8_t transmit_en; // TXE uint8_t UART_en; // UARTEN uint8_t cts_en; //CTSEN uint8_t rts_en; //RTSEN // Interrupt FIFO Level Select Register, UARTIFLS uint8_t rxfifo_waterlevel; // RXIFLSEL uint8_t txfifo_waterlevel; // TXIFLSEL //UART_eFIFO_WATERLEVEL rxfifo_waterlevel; // RXIFLSEL //UART_eFIFO_WATERLEVEL txfifo_watchlevel; // TXIFLSEL // UART Clock Frequency uint32_t ClockFrequency; uint32_t BaudRate; } UART_sStateStruct; 常用的中断掩码如下所示， IntMask 是它们的组合。 #define UART_INTBIT_RECEIVE 0x10 //receive interrupt #define UART_INTBIT_TRANSMIT 0x20 //transmit interrupt 例如，配置并初始化串口，开启接收中断和发送中断，设置串口波特率为115200： 首先，创建UART配置函数 config_uart ，在函数内初始化UART状态结构体，并配置必要的状态参数， 然后调用 apUART_Initialize 初始化串口。 void config_uart(uint32_t freq, uint32_t baud) { UART_sStateStruct config; config.word_length = UART_WLEN_8_BITS; config.parity = UART_PARITY_NOT_CHECK; config.fifo_enable = 1; config.two_stop_bits = 0; config.receive_en = 1; config.transmit_en = 1; config.UART_en = 1; config.cts_en = 0; config.rts_en = 0; config.rxfifo_waterlevel = 1; config.txfifo_waterlevel = 1; config.ClockFrequency = freq; config.BaudRate = baud; apUART_Initialize(PRINT_PORT, &amp;config, UART_INTBIT_RECEIVE | UART_INTBIT_TRANSMIT); } 使用时只需要如下所示调用 config_uart 函数即可。 config_uart(OSC_CLK_FREQ, 115200); 16.2.4 UART轮询模式 在轮询模式下，CPU通过检查线路状态寄存器中的位来检测事件： 使用 apUART_Check_Rece_ERROR 查询接收产生的错误字。 uint8_t apUART_Check_Rece_ERROR( UART_TypeDef* pBase ); 用 apUART_Check_RXFIFO_EMPTY查询Rx FIFO是否为空。 uint8_t apUART_Check_RXFIFO_EMPTY( UART_TypeDef* pBase ); 使用 apUART_Check_RXFIFO_FULL查询Rx FIFO是否已满。 uint8_t apUART_Check_RXFIFO_FULL( UART_TypeDef* pBase ); 使用 apUART_Check_TXFIFO_EMPTY 查询Tx FIFO是否为空。 uint8_t apUART_Check_TXFIFO_EMPTY( UART_TypeDef* pBase ); 使用 apUART_Check_TXFIFO_FULL 查询Tx FIFO是否已满。 uint8_t apUART_Check_TXFIFO_FULL( UART_TypeDef* pBase ); 16.2.5 UART中断使能/禁用 用 apUART_Enable_TRANSMIT_INT 使能发送中断，用 apUART_Disable_TRANSMIT_INT 禁用发送中断； 用 apUART_Enable_RECEIVE_INT 使能接收中断，用 apUART_Disable_RECEIVE_INT 禁用接收中断。 中断默认是禁用的，使能中断既能用上述 apUART_Enable_TRANSMIT_INT 和 apUART_Enable_RECEIVE_INT 的方式，也可以通过 apUART_Initialize 初始化串口是设置参数 IntMask 的值使能相应的中断，详情请参考 UART初始化 16.2.6 处理中断状态 用 apUART_Get_ITStatus 获取某个UART上的中断触发状态，返回非 0 值表示该 UART 上产生了中断请求；用 apUART_Get_all_raw_int_stat 一次性获取所有 UART 的中断触发状态， 第 \\(n\\) 比特（第 0 比特为最低比特）对应 UART \\(n\\) 上的中断触发状态。 UART产生中断后，需要消除中断状态方可再次触发。用 apUART_Clr_RECEIVE_INT 消除某个 UART上接收中断的状态， 用 apUART_Clr_TX_INT 消除某个 UART上发送中断的状态。用 apUART_Clr_NonRx_INT 消除某个 UART上除接收以外的中断状态。 16.2.7 UART FIFO中断触发逻辑 RX中断： 当接收FIFO水位标记被触发时，产生RX中断。 RX Timeout中断： 当接收FIFO超时中断被触发时，产生RX Timeout中断。 TX中断： 当发送FIFO水位标记被触发时，产生TX中断。 当使能TX fifo中断时，不会直接产生中断，需向fifo写入数据后，才会产生中断。例如：txfifo_waterlevel = 1， 则当fifo中有1个字节数据时，产生中断；当fifo中有2个字节数据时，不会产生中断，需写入第2个字节后，才会产生中断。 注意： 当使能TX时，TX fifo写入的第一个字节会直接发送，因此当txfifo_waterlevel = 0时，写入一个字节不会产生fifo中断。 推荐每次发送数据时，使用apUART_Check_TXFIFO_FULL()接口，写入数据直到TX fifo满，减少中断次数的同时保证中断正常产生。 16.2.8 发送数据 使用 UART_SendData 发送数据。 void UART_SendData( UART_TypeDef* pBase, uint8_t Data ); 16.2.9 接收数据 使用 UART_ReceData 接收数据。 uint8_t UART_ReceData( UART_TypeDef* pBase ); 16.2.10 DMA传输模式使能 使用 UART_DmaEnable使能UART的DMA工作模式，可以使用DMA完成对串口数据的收发，从而不占用 CPU 的资源。 void UART_DmaEnable( UART_TypeDef *pBase, uint8_t tx_enable, //发送使能(1)/禁用(0) uint8_t rx_enable, //接收使能(1)/禁用(0) uint8_t dma_on_err ); 16.3 示例代码 16.3.1 UART接收变长字节数据 UART+FIFO方式 #define RX_FIFO_WATER_LEVEL 0x10 char dst[256]; void config_uart(uint32_t freq, uint32_t BaudRate) { //config uarts parameter UART_sStateStruct config; config.word_length = UART_WLEN_8_BITS; config.parity = UART_PARITY_NOT_CHECK; config.fifo_enable = 1; config.two_stop_bits = 0; config.receive_en = 1; config.transmit_en = 1; config.UART_en = 1; config.cts_en = 0; config.rts_en = 0; config.rxfifo_waterlevel = RX_FIFO_WATER_LEVEL; config.txfifo_waterlevel = 1; config.ClockFrequency = freq; config.BaudRate = BaudRate; apUART_Initialize(APB_UART0, &amp;config, UART_INTBIT_TIMEOUT | UART_INTBIT_RECEIVE); } uint32_t uart_isr(void *user_data) { uint32_t status; static int index = 0; uint8_t cnt = 0; while(1) { status = apUART_Get_all_raw_int_stat(APB_UART0); if (status == 0) break; APB_UART0-&gt;IntClear = status; // rx int if (status &amp; (1 &lt;&lt; bsUART_RECEIVE_INTENAB)) { while (apUART_Check_RXFIFO_EMPTY(APB_UART0) != 1) { char c = APB_UART0-&gt;DataRead; dst[index++] = c; cnt++; /* To avoid the situation where the RX FIFO data length is the same as that of the RX_FIFO_WATER_LEVEL, the rx timeout interrupt cannot be generated.*/ if(cnt &gt;= RX_FIFO_WATER_LEVEL - 1) { break; } } } // rx timeout_int if (status &amp; (1 &lt;&lt; bsUART_TIMEOUT_INTENAB)) { while (apUART_Check_RXFIFO_EMPTY(APB_UART0) != 1) { char c = APB_UART0-&gt;DataRead; dst[index++] = c; } dst[index] = 0; // 一包数据接收完毕，可在此进行数据处理 index = 0; } } return 0; } void uart_peripherals_read_data() { //注册uart0中断 platform_set_irq_callback(PLATFORM_CB_IRQ_UART0, uart_isr, NULL); config_uart(OSC_CLK_FREQ, 115200); } UART+FIFO+DMA方式 char dst[256]; char src[] = &quot;Finished to receive a frame!\\n&quot;; #define DMA_RX_CHANNEL_ID 1 #define DMA_TX_CHANNEL_ID 0 void config_uart(uint32_t freq, uint32_t BaudRate) { //config uarts parameter UART_sStateStruct config; config.word_length = UART_WLEN_8_BITS; config.parity = UART_PARITY_NOT_CHECK; config.fifo_enable = 1; config.two_stop_bits = 0; config.receive_en = 1; config.transmit_en = 1; config.UART_en = 1; config.cts_en = 0; config.rts_en = 0; config.rxfifo_waterlevel = 7; config.txfifo_waterlevel = 1; config.ClockFrequency = freq; config.BaudRate = BaudRate; apUART_Initialize(APB_UART0, &amp;config, UART_INTBIT_TIMEOUT); UART_DmaEnable(APB_UART0, 1, 1, 0); } static void setup_peripheral_dma(void) { DMA_Descriptor descriptor __attribute__((aligned (8))) = {0}; DMA_PreparePeripheral2Mem( &amp;descriptor, dst, SYSCTRL_DMA_UART0_RX, sizeof(dst), DMA_ADDRESS_INC, 0); DMA_EnableChannel(DMA_RX_CHANNEL_ID, &amp;descriptor); } //添加UART通过DMA发送的配置 void UART_trigger_DmaSend(void) { DMA_Descriptor descriptor __attribute__((aligned (8))) = {0}; DMA_PrepareMem2Peripheral( &amp;descriptor, SYSCTRL_DMA_UART0_TX, src, strlen(src), DMA_ADDRESS_INC, 0); DMA_EnableChannel(DMA_TX_CHANNEL_ID, &amp;descriptor); } uint32_t uart_isr(void *user_data) { uint32_t status; int index = 0; while(1) { status = apUART_Get_all_raw_int_stat(APB_UART0); if (status == 0) break; APB_UART0-&gt;IntClear = status; // rx timeout_int if (status &amp; (1 &lt;&lt; bsUART_TIMEOUT_INTENAB)) { index = APB_DMA-&gt;Channels[DMA_RX_CHANNEL_ID].Descriptor.DstAddr - (uint32_t)rx_buffer; while (apUART_Check_RXFIFO_EMPTY(APB_UART0) != 1) { char c = APB_UART0-&gt;DataRead; dst[index++] = c; } dst[index] = 0; // 一包数据接收完毕，可在此进行数据处理 UART_trigger_DmaSend(); setup_peripheral_dma(); } } return 0; } void uart_peripherals_read_data() { //注册uart0中断 platform_set_irq_callback(PLATFORM_CB_IRQ_UART0, uart_isr, NULL); config_uart(OSC_CLK_FREQ, 115200); setup_peripheral_dma(); } "],["ch-usb.html", "17 通用串行总线 (USB) 17.1 功能概述 17.2 使用说明", " 17 通用串行总线 (USB) 17.1 功能概述 支持full-speed (12 Mbps) 模式 集成PHY Transceiver，内置上拉，软件可控 Endpoints: Endpoints 0: control endpoint Endpoints 1-5: 可以配置为in/out，以及control/isochronous/bulk/interrupt 支持USB suspend, resume, remote-wakeup 内置DMA方便数据传输 17.2 使用说明 17.2.1 USB软件结构 driver layer，USB的底层处理，不建议用户修改。 处理了大部分和应用场景无关的流程，提供了USB_IrqHandler，调用event handler。 位置：\\ING\\_SDK\\sdk\\src\\FWlib\\peripheral\\_usb.c bsp layer，处理场景相关的流程，需要用户提供event handler，并实现control和transfer相关处理。 位置：\\ING\\_SDK\\sdk\\src\\BSP\\bsp\\_usb_xxx.c 17.2.2 USB Device 状态 USB的使用首先需要配置USB CLK，USB IO以及PHY，并且初始化USB模块，此时USB为”NONE”状态，等待USB的reset中断（USB_IrqHandler）。 reset中断的触发代表USB cable已经连接，而且host已经检测到了device，在reset中断中，USB模块完成相关的USB初始化。并继续等待中断。 enumeration中断的触发代表device可以开始接收SOF以及control传输，device需要配置并打开endpoint 0，进入”DEFAULT”状态。 out中断的触发代表收到了host的get descriptor，用户需要准备好相应的descriptor，并配置相关的in endpoint。 out中断中的set address request会将device的状态切换为”ADDRESS”。 out中断中的set configuration会将device的状态切换为”CONFIGURED”。此时device可以开始在配置的endpoint上传输数据。 bus上的idle会自动触发suspend中断（用户需要在初始化中使能suspend中断），此时切换为”SUSPEND”状态。 idle之后任何bus上的活动将会触发resume中断（用户需要在初始化中使能resume中断）,用户也可以选择使用remote wakeup主动唤醒。 唤醒之后的usb将重新进入”CONFIGURED”状态，每1ms（full-speed）将会收到1个SOF中断（用户需要在初始化中使能SOF中断）。 typedef enum { USB_DEVICE_NONE, /* A USB device may be attached or detached from the USB */ USB_DEVICE_ATTACHED, /*USB devices may obtain power from an external source */ USB_DEVICE_POWERED, /* After the device has been powered, and reset is done */ USB_DEVICE_DEFAULT, /* All USB devices use the default address when initially powered or after the device has been reset. Each USB device is assigned a unique address by the host after attachment or after reset. */ USB_DEVICE_ADDRESS, /* Before a USB device function may be used, the device must be configured. */ USB_DEVICE_CONFIGURED, /* In order to conserve power, USB devices automatically enter the Suspended state when the device has observed no bus traffic for a specified period */ USB_DEVICE_SUSPENDED, USB_DEVICE_TEST_RESET_DONE }USB_DEVICE_STATE_E; 17.2.3 设置 IO USB的DP/DM固定在GPIO16/17,IO初始化细节请参考ING_SDK\\sdk\\src\\BSP\\bsp\\_usb.c中的bsp_usb_init() // ATTENTION ! FIXED IO FOR USB on 20 series #define USB_PIN_DP GIO_GPIO_16 #define USB_PIN_DM GIO_GPIO_17 17.2.4 设置 PHY 使用SYSCTRL_USBPhyConfig()初始化PHY, 细节请参考ING_SDK\\sdk\\src\\BSP\\bsp\\_usb.c中的bsp_usb_init()。 /** * @brief Config USB PHY functionality * * @param[in] enable Enable(1)/Disable(0) usb phy module * @param[in] pull_sel DP pull up(0x1)/DM pull up(0x2)/DP&amp;DM pull down(0x3) */ void SYSCTRL_USBPhyConfig(uint8_t enable, uint8_t pull_sel); 17.2.5 USB 模块初始化 细节请参考ING_SDK\\sdk\\src\\BSP\\bsp\\_usb.c中的bsp_usb_init()。 USB模块首选需要打开USB中断并配置相应接口，其中USB_IrqHandler由driver提供不需要用户修改。 platform_set_irq_callback(PLATFORM_CB_IRQ_USB, USB_IrqHandler, NULL); 其次需要初始化USB模块以及相关状态信息，入参结构体中用户需要提供event handler，其余为可选项 /** * @brief interface API. initilize usb module and related variables, must be called before any usb usage * * @param[in] device callback function with structure USB_INIT_CONFIG_T. * When this function has been called your device is ready to be enumerated by the USB host. * @param[out] null. */ extern USB_ERROR_TYPE_E USB_InitConfig(USB_INIT_CONFIG_T *config); 17.2.6 event handler USB的用户层调用通过event handler来实现， 细节请参考ING_SDK\\sdk\\src\\BSP\\bsp\\_usb.c中的bsp_usb_event_handler()。 event handler需要包含对以下event事件的处理： USB_EVENT_EP0_SETUP 该event包含EP0(control endpoint)上的所有request，包括读取/设置 descriptor，设置address，set/clear feature等request，按照USB协议， device需要支持所有协议中的标准request。 descriptor需要按照协议格式准备，并且放置在4bytes对齐的全局地址， 并通过USB_SendData()发送给host，在整个过程中，该全局地址和数据需要保持。 （4bytes对齐是内部DMA搬运的要求，否则可能出现错误）。 对于没有data stage的request，event handler中不需要使用 USB_SendData()以及USB_RecvData()。 对于不支持的request，需要设置status为： status = USB_ERROR_REQUEST_NOT_SUPPORT; 根据返回的status，driver判断当前request是否支持，否则按照协议发送stall给host。 对于包含data stage的out传输，driver将继续接收数据，数据将在USB_EVENT_EP_DATA_TRANSFER的EP0通知用户。 setup/data/status stage的切换将在driver内进行。 USB_EVENT_EP_DATA_TRANSFER 数据相关的处理，接收和发射数据。 参数包含ep number uint8_t ep; 以及数据处理类型，分别代表发送和接收transfer的结束。 typedef enum { /// Event send when a receive transfert is finish USB_CALLBACK_TYPE_RECEIVE_END, /// Event send when a transmit transfert is finish USB_CALLBACK_TYPE_TRANSMIT_END } USB_CALLBACK_EP_TYPE_T; USB_EVENT_DEVICE_RESET USB reset 中断的event，代表枚举的开始。 USB_EVENT_DEVICE_SOF SOF中断，每1m（full-speed）将会收到1个SOF中断（用户需要在初始化中使能SOF中断）。 USB_EVENT_DEVICE_SUSPEND bus 进入idle状态后触发suspend，此时总线上没有USB活动。driver会关闭phy clock。 USB_EVENT_DEVICE_RESUME bus 上的任何USB活动将会触发wakeup中断。resume后driver打开phy clock，USB恢复到正常状态。 17.2.6.1 USB_EVENT_EP0_SETUP的实现 control以及枚举相关的流程实现需要通过USB_EVENT_EP0_SETUP event来进行。 默认的control endpoint是EP0, 所有request都会触发该event。 如果场景不支持某个request，则需要设置status == USB_ERROR_REQUEST_NOT_SUPPORT。driver会据此发送stall。 如果场景需要处理某个request，则需要将status设置为非USB_ERROR_REQUEST_NOT_SUPPORT状态。 用户需要将所有descriptor保存在4bytes对齐的全局地址。以device descriptor为例 case USB_REQUEST_DEVICE_DESCRIPTOR_DEVICE: { size = sizeof(USB_DEVICE_DESCRIPTOR_REAL_T); size = (setup-&gt;wLength &lt; size) ? (setup-&gt;wLength) : size; status |= USB_SendData(0, (void*)&amp;DeviceDescriptor, size, 0); } break; 首先判断size，确保数据没有超出request要求，然后使用USB_SendData发送in transfer数据。其中DeviceDescriptor为device descriptor地址。 set address request需要配置device地址，因此在driver layer实现。 17.2.6.2 SUSPEND 的处理 SUSPEND状态下可以根据需求进行power saving，默认配置只关闭了phy clock，其余的USB power/clock处理需要根据场景在应用层中的low power mode中来实现。 17.2.6.3 remote wakeup 进入suspend的device可以选择主动唤醒，唤醒通过bsp_usb_device_remote_wakeup()连续发送10ms的resume signal来实现。 void bsp_usb_device_remote_wakeup(void) { USB_DeviceSetRemoteWakeupBit(U_TRUE); // setup timer for 10ms, then disable resume signal platform_set_timer(internal_bsp_usb_device_remote_wakeup_stop,16); } 17.2.7 常用driver API 17.2.7.1 send usb data 使用该API发送USB数据（包括setup data和应用数据），但需要在set config（打开endpoint）之后使用。 ep: 数据发送对应的Endpoint，需要使用USB_EP_DIRECTION_IN。 buffer：buffer地址需要是四字节对齐c __attribute__ ((aligned (4)))。 size: 需要小于512*MPS，例如对于EP0，如果MPS为64bytes，则size需要小于\\(512 \\times 64\\)。 flag：NULL。 如果成功则返回U_TRUE，否则返回U_FALSE。 extern USB_ERROR_TYPE_E USB_SendData(uint8_t ep, void* buffer, uint16_t size, uint32_t flag); 17.2.7.2 receive usb data 使用该API接收USB数据（包括setup data和应用数据），但需要在set config（打开endpoint）之后使用。 ep: 数据发送对应的Endpoint，需要使用USB_EP_DIRECTION_OUT。 buffer：buffer地址需要是四字节对齐c __attribute__ ((aligned (4)))。 size: 需要是MPS的整数倍，如果期望接收的数据小于MPS，参考flag设置。 flag： 1&lt;&lt;USB_TRANSFERT_FLAG_FLEXIBLE_RECV_LEN: 当接收数据小于MPS时需要设置。 如果成功则返回U_TRUE，否则返回U_FALSE。 extern USB_ERROR_TYPE_E USB_RecvData(uint8_t ep, void* buffer, uint16_t size, uint32_t flag); 17.2.7.3 enable/disable ep 正常处理中不需要使用该API，特殊情况下可以根据需求打开关闭某个特定的endpoint。 /** * @brief interface APIs. use this pair for enable/disable certain ep. * * @param[in] ep number with USB_EP_DIRECTION_IN/OUT. * @param[out] null */ extern void USB_EnableEp(uint8_t ep, USB_EP_TYPE_T type); extern void USB_DisableEp(uint8_t ep); 17.2.7.4 usb close USB的disable请使用bsp layer中的bsp_usb_disable()。 /** * @brief interface API. shutdown usb module and reset all status data. * * @param[in] null. * @param[out] null. */ extern void bsp_usb_disable(void); 17.2.7.5 usb stall /** * @brief interface API. set ep stall pid for current transfer * * @param[in] ep num with direction. * @param[in] U_TRUE: stall, U_FALSE: set back to normal * @param[out] null. */ extern void USB_SetStallEp(uint8_t ep, uint8_t stall); 17.2.7.6 usb in endpoint nak /** * @brief interface API. use this api to set NAK on a specific IN ep * * @param[in] U_TRUE: enable NAK on required IN ep. U_FALSE: stop NAK * @param[in] ep: ep number with USB_EP_DIRECTION_IN/OUT. * @param[out] null. */ extern void USB_SetInEndpointNak(uint8_t ep, uint8_t enable); 17.2.8 使用场景 17.2.8.1 example 0: WINUSB WinUSB 是适用于 USB 设备的通用驱动程序，随附在Windows系统中。 对于某些通用串行总线 (USB) 设备（例如只有单个应用程序访问的设备），可以直接使用WINUSB而不需要实现驱动程序。如果已将设备定义为 WinUSB 设备 ，Windows会自动加载Winusb.sys。 参考：\\ING\\_SDK\\sdk\\src\\BSP\\bsp_usb.c 首先调用bsp_usb_init()初始化USB模块,之后的USB活动则全部在bsp_usb_event_handler()中处理。 #define FEATURE_WCID_SUPPORT device需要在enumeration阶段提供WCID标识和相关descriptor。示例中的descriptor实现如下： #define USB_WCID_DESCRIPTOR_INDEX_4 \\ { \\ #define USB_WCID_DESCRIPTOR_INDEX_5 \\ { \\ 通过修改USB_STRING_PRODUCT来改变产品名称iproduct #define USB_STRING_PRODUCT {16,0x3,&#39;w&#39;,0,&#39;i&#39;,0,&#39;n&#39;,0,&#39;-&#39;,0,&#39;d&#39;,0,&#39;e&#39;,0,&#39;v&#39;,0} 第一个值是整个数组的长度，第二个值不变，之后是16bit unicode字符串 （每个符号占用两个字节），该示例中iproduct为’win-dev’。 该示例中打开了两个bulk endpoint，endpoint 1 为input，endpoint 2为output,最大包长为64： #define USB_EP_1_DESCRIPTOR \\ { \\ .size = sizeof(USB_EP_DESCRIPTOR_REAL_T), \\ .type = 5, \\ .ep = USB_EP_DIRECTION_IN(EP_IN), \\ .attributes = USB_EP_TYPE_BULK, \\ .mps = EP_X_MPS_BYTES, \\ .interval = 0 \\ } #define USB_EP_2_DESCRIPTOR \\ { \\ .size = sizeof(USB_EP_DESCRIPTOR_REAL_T), \\ .type = 5, \\ .ep = USB_EP_DIRECTION_OUT(EP_OUT), \\ .attributes = USB_EP_TYPE_BULK, \\ .mps = EP_X_MPS_BYTES, \\ .interval = 0 \\ } 在set configuration(USB_REQUEST_DEVICE_SET_CONFIGURATION)之后，In/out endpoint 可以使用，通过USB_RecvData()配置out endpoint接收host发送的数据。 在收到host的数据后USB_CALLBACK_TYPE_RECEIVE_END，通过USB_SendData()将数据 发送给host（通过in endpoint）。 在WIN10及以上的系统上，该设备会自动加载winusb.sys并枚举成WinUsb Device, 设备名称为”win-dev”。 通过ing_usb.exe可以对该设备进行一些简单数据测试: ing_usb.exe VID:PID -w 2 xxxx xxxx VID:PID的数值请查看USB_DEVICE_DESCRIPTOR。 -w：代表写命令。 2：传输类型，2为bulk transfer。 xxxx: 需要传输的数据（32bit），默认包长度为endpoint的mps。 数据会通过out endpoint发送给USB Device并通过in endpoint回环并打印出来)： 使用ing_usb.exe可以读取in endpoint的数据，但是bsp layer中需要做相应的修改 （使用in endpoint发送数据给host）： ing_usb.exe VID:PID -r 2 VID:PID的数值请查看USB_DEVICE_DESCRIPTOR。 -r：代表读命令。 2：传输类型，2为bulk transfer。 17.2.8.2 example 1: HID composite 该示例实现了一个mouse + keyboard的复合设备， 使用了两个独立的interface，每个interface包含一个In Endpoint。 参考：\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.c 首先调用bsp_usb_init()初始化USB模块, 之后的USB活动则全部在bsp_usb_event_handler()中处理，report的发送参考report data 发送。 17.2.8.2.1 标准描述符 其标准描述符结构如下，configuration descriptor之后分别是interface descriptor, hid descriptor, endpoint descriptor。 typedef struct __attribute__((packed)) { USB_CONFIG_DESCRIPTOR_REAL_T config; USB_INTERFACE_DESCRIPTOR_REAL_T interface_kb; BSP_USB_HID_DESCRIPTOR_T hid_kb; USB_EP_DESCRIPTOR_REAL_T ep_kb[bNUM_EP_KB]; USB_INTERFACE_DESCRIPTOR_REAL_T interface_mo; BSP_USB_HID_DESCRIPTOR_T hid_mo; USB_EP_DESCRIPTOR_REAL_T ep_mo[bNUM_EP_MO]; }BSP_USB_DESC_STRUCTURE_T; 上述描述符的示例在路径\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.h，以keyboard interface为例： #define USB_INTERFACE_DESCRIPTOR_KB \\ { \\ .size = sizeof(USB_INTERFACE_DESCRIPTOR_REAL_T), \\ .type = 4, \\ .interfaceIndex = 0x00, \\ .alternateSetting = 0x00, \\ .nbEp = bNUM_EP_KB, \\ .usbClass = 0x03, \\ /* 0: no subclass, 1: boot interface */ \\ .usbSubClass = 0x00, \\ /* 0: none, 1: keyboard, 2: mouse */ \\ .usbProto = 0x00, \\ .iDescription = 0x00 \\ } 其中可能需要根据场景修改的变量使用宏定义，其他则使用常量。请注意：该实现中没有打开boot function。 17.2.8.2.2 报告描述符 报告描述符的示例在路径\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.h keyboard的report描述符为： #define USB_HID_KB_REPORT_DESCRIPTOR { \\ 0x05, 0x01, /* USAGE_PAGE (Generic Desktop) */ \\ 0x09, 0x06, /* USAGE (Keyboard) */ \\ 0xa1, 0x01, /* COLLECTION (Application) */ \\ 0x05, 0x07, /* USAGE_PAGE (Keyboard) */ \\ ...\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.h keyboard report descriptor包含8bit modifier input，8bit reserve, 5bit led output, 3bit reserve, 6bytes key usage id 。report本地结构为： #define KEY_TABLE_LEN (6) typedef struct __attribute__((packed)) { uint8_t modifier; uint8_t reserved; uint8_t key_table[KEY_TABLE_LEN]; }BSP_KEYB_REPORT_s; report中的usage id data的实现分别在以下enum中： BSP_KEYB_KEYB_USAGE_ID_e BSP_KEYB_KEYB_MODIFIER_e BSP_KEYB_KEYB_LED_e mouse的report描述符为： #define USB_HID_MOUSE_REPORT_DESCRIPTOR_SIZE (50) #define USB_HID_MOUSE_REPORT_DESCRIPTOR { \\ 0x05, 0x01, /* USAGE_PAGE (Generic Desktop) */ \\ 0x09, 0x02, /* USAGE (Mouse) */ \\ 0xa1, 0x01, /* COLLECTION (Application) */ \\ ...\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.h report包含一个3bit button(button 1 ~ button 3), 5bit reserve, 8bit x value, 8bit y value 结构为： typedef struct __attribute__((packed)) { uint8_t button;/* 1 ~ 3 */ int8_t pos_x;/* -127 ~ 127 */ int8_t pos_y;/* -127 ~ 127 */ }BSP_MOUSE_REPORT_s; 17.2.8.2.3 standard/class request EP0的request处理在event：USB_EVENT_EP0_SETUP。 HID Class相关的处理在interface destination下：USB_REQUEST_DESTINATION_INTERFACE。 以其中keyboard report 描述符的获取为例： setup-&gt;wIndex代表了interface num，其中0为keyboard interface（参考BSP_USB_DESC_STRUCTURE_T） 使用USB_SendData发送report数据 case USB_REQUEST_DEVICE_GET_DESCRIPTOR: { switch(((setup-&gt;wValue)&gt;&gt;8)&amp;0xFF) { case USB_REQUEST_HID_CLASS_DESCRIPTOR_REPORT: { switch(setup-&gt;wIndex) { case 0: { size = sizeof(ReportKeybDescriptor); size = (setup-&gt;wLength &lt; size) ? (setup-&gt;wLength) : size; status |= USB_SendData(0, &amp;ReportKeybDescriptor, size, 0); KeybReport.pending = U_FALSE; }break; ...\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.c 17.2.8.2.4 report data 发送 keyboard key的发送,入参为一个键值以及其是否处于按下的状态，如果该键按下，则将其添加到report中并发送出去。 /** * @brief interface API. send keyboard key report * * @param[in] key: value comes from BSP_KEYB_KEYB_USAGE_ID_e * @param[in] press: 1: pressed, 0: released * @param[out] null. */ extern void bsp_usb_handle_hid_keyb_key_report(uint8_t key, uint8_t press); keyboard modifier的发送，与key类似，区别是modifier是bitmap data。 extern void bsp_usb_handle_hid_keyb_key_report(uint8_t key, uint8_t press); /** * @brief interface API. send keyboard modifier report * * @param[in] modifier: value comes from BSP_KEYB_KEYB_MODIFIER_e * @param[in] press: 1: pressed, 0: released * @param[out] null. */ extern void bsp_usb_handle_hid_keyb_modifier_report(BSP_KEYB_KEYB_MODIFIER_e modifier, uint8_t press); keyboard led的获取，该示例中没有out endpoint，因此led report可能是用EP0的set report得到， 参考：USB_REQUEST_HID_CLASS_REQUEST_SET_REPORT。 mouse report的发送,入参分别为x,y的相对值和button的组合（按下为1，释放为0）。 /** * @brief interface API. send mouse report * * @param[in] x: 8bit int x axis value, relative, * @param[in] y: 8bit int y axis value, relative, * @param[in] btn: 8bit value, button 1 to 3, * @param[out] null. */ extern void bsp_usb_handle_hid_mouse_report(int8_t x, int8_t y, uint8_t btn); 17.2.8.3 example 3: USB MSC 该示例提供了以下功能，通过BSP_USB_MSC_FUNC来选择： BSP_USB_MSC_FLASH_DISK： 在指定的FLASH空间内初始化一个FAT16文件系统。在成功枚举后， 可以在host端（电脑侧）以操作磁盘的形式直接读取/写入文件。 BSP_USB_MSC_FLASH_DISK_NO_VFS：类似BSP_USB_MSC_FLASH_DISK但是没有提供文件系统， 适用于用户自定义的存储设备，当成功枚举后，host端（电脑侧）会提示需要格式化磁盘，选择 相应的参数，完成格式化后，即可以按照正常磁盘使用。 BSP_USB_MSC_FLASH_DISK_DOWNLOADER：拖拽下载功能。打开磁盘后，放入bin文件，则可以 完成下载并重启。 参考：\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_msc.c 应用层需要调用bsp_usb_init()初始化USB模块, 插入电脑，完成枚举，则可以使用对应功能。 "],["ch-watchdog.html", "18 看门狗（WATCHDOG） 18.1 功能概述 18.2 使用说明", " 18 看门狗（WATCHDOG） 18.1 功能概述 看门狗的本质就是一个定时器，其功能主要是防止程序跑飞，同时也能防止程序在线运行时出现死循环， 一旦发生错误就向芯片内部发出重启信号。 特性： 支持AMBA 2.0 APB总线 当看门狗超时时，提供中断和重启的组合 为控制/重启寄存器提供写保护机制 可编程定时器时钟源 可配置的用于寄存器写保护和定时器重启的魔数 看门狗定时器可外部暂停 ING20XX的看门狗定时器提供了一个两级机制，如下图所示（图 18.1）。： 图 18.1: WDT阶段图 1）第一阶段 中断阶段：若watchdog中断启用，则在中断计时结束时会产生中断信号wdt_int； 2）第二阶段 复位阶段：若watchdog复位启用，并且在复位超时时间结束前watchdog未重启，则会产生复位信号wdt_rst使得系统复位。 18.2 使用说明 18.2.1 配置看门狗 使用 TMR_WatchDogEnable3 配置并启用看门狗。 void TMR_WatchDogEnable3( wdt_inttime_interval_t int_timeout, , //中断阶段时间 wdt_rsttime_interval_t rst_timeout, //复位阶段时间 uint8_t enable_int //中断使能(1)/禁用(0) ); 其中中断阶段时间和复位阶段的时间设置分别支持16种和8种，分别如下述的枚举变量 wdt_inttime_interval_t 和 wdt_rsttime_interval_t所示。 默认使用的PCLK=32.768MHz，所以对应 int_timeout == WDT_INTTIME_INTERVAL_1S 时，对应的中断阶段时间为1s，其余时间以及复位阶段的超时时间以此类推。 typedef enum { WDT_INTTIME_INTERVAL_2MS = 0, //0.001953125s WDT_INTTIME_INTERVAL_8MS = 1, //0.0078125s WDT_INTTIME_INTERVAL_31MS = 2, //0.03125s WDT_INTTIME_INTERVAL_62MS = 3, //0.0625s WDT_INTTIME_INTERVAL_125MS = 4, WDT_INTTIME_INTERVAL_250MS = 5, WDT_INTTIME_INTERVAL_500MS = 6, WDT_INTTIME_INTERVAL_1S = 7, WDT_INTTIME_INTERVAL_4S = 8, WDT_INTTIME_INTERVAL_16S = 9, WDT_INTTIME_INTERVAL_1M_4S = 10, //64s WDT_INTTIME_INTERVAL_4M_16S = 11, //256s WDT_INTTIME_INTERVAL_17M_4S = 12, //1024s WDT_INTTIME_INTERVAL_1H_8M_16S = 13, //4096s WDT_INTTIME_INTERVAL_4H_33M_6S = 14, //16384s WDT_INTTIME_INTERVAL_18H_12M_16S = 15 //65536s }wdt_inttime_interval_t; typedef enum { WDT_RSTTIME_INTERVAL_4MS = 0, //3.90625ms WDT_RSTTIME_INTERVAL_8MS = 1, //7.8125ms WDT_RSTTIME_INTERVAL_15MS = 2, //15.625ms WDT_RSTTIME_INTERVAL_31MS = 3, //31.25ms WDT_RSTTIME_INTERVAL_62MS = 4, //62.5ms WDT_RSTTIME_INTERVAL_125MS = 5, WDT_RSTTIME_INTERVAL_250MS = 6, WDT_RSTTIME_INTERVAL_500MS = 7 }wdt_rsttime_interval_t; 为了方便使用，通过宏定义将ING20xx和ING916xx和ING918xx接口统一为 TMR_WatchDogEnable 。 #define TMR_WatchDogEnable(timeout) do { uint64_t TMR_CLK_FREQ = OSC_CLK_FREQ;uint32_t cnt = (uint64_t)(timeout) / OSC_CLK_FREQ;uint8_t mode = 7;\\ for (uint8_t i = 1; i &lt; 10; i++,mode++) { if (cnt &lt; (1UL &lt;&lt; (i * 2))) {break;}} \\ TMR_WatchDogEnable3(mode, WDT_RSTTIME_INTERVAL_500MS, 1); } while (0) \\ 代码中会将设置的时间映射到结构体 wdt_inttime_interval_t 中 ，但是由于 ING916XX 的WDT能设置的时间是离散的，所以为了方便使用， 我们只选取从 WDT_INTTIME_INTERVAL_1S 到 WDT_INTTIME_INTERVAL_18H_12M_16S 。 由于 ING916XX 和 ING918XX 的看门狗在机制上有差别，所以使用 ING916XX 时推荐使用 TMR_WatchDogEnable3 。 若要在 ING916XX 中使用 TMR_WatchDogEnable 需注意：ING918XX 的看门狗没有中断机制，实际的复位超时时间为设定时间的两倍； 而在 ING916XX 中的中断阶段和复位阶段的超时时间都是可以设置的，复位时间我们默认0.5s。所以若用 TMR_WatchDogEnable(OSC_CLK_FREQ * 1) 设置的时间在918和916上分别是2s和1.5s。 18.2.2 重启看门狗 使用 TMR_WatchDogRestart 重启看门狗，也就是我们俗称的 喂狗。 void TMR_WatchDogRestart(void); 18.2.3 清除中断 使用 TMR_WatchDogClearInt 清除看门狗的中断。 void TMR_WatchDogClearInt(void); 18.2.4 禁用看门狗 在使用TMR_WatchDogEnable 启用或 TMR_WatchDogRestart 重启看门狗之后， 需要使用 TMR_WatchDogDisable 才能将其禁用。 void TMR_WatchDogDisable(void); 18.2.5 暂停看门狗 使用 TMR_WatchDogPauseEnable() 可以暂停看门狗。 void TMR_WatchDogPauseEnable( uint8_t enable ); 18.2.6 处理中断状态 当调用 TMR_WatchDogEnable 或者在 TMR_WatchDogEnable3的参数中使能中断，就会在WDT上产生中断， 此时需要调用 TMR_WatchDogClearInt 清除看门狗中断之后才能再次触发中断。 "],["ch-eflash.html", "19 内置 Flash（EFlash） 19.1 功能概述 19.2 使用说明", " 19 内置 Flash（EFlash） 19.1 功能概述 芯片内置一定容量的 Flash，可编程擦写。擦除时以扇区（sector）为单位进行，每个扇区大小为 EFLASH_SECTOR_SIZE 字节；写入时以 32bit 为单位。 表中的 Flash 时钟频率可通过 SYSCTRL_GetFlashClk() 读取。Flash 内部会对这个时钟 2 分频， 实际工作频率是这个时钟频率的一半。 19.2 使用说明 19.2.1 擦除并写入新数据 通过 program_flash 擦除并写入一段数据。 int program_flash( // 待写入的地址 const uint32_t dest_addr, // 数据源的地址 const uint8_t *buffer, // 数据长度（以字节为单位，必须是 4 的倍数） uint32_t size); dest_addr 为统一编址后的地址，而非 Flash 内部从 0 开始的地址。dest_addr 必须对应于某个扇区的起始地址。数据源不可位于 Flash 内。 program_flash 将根据 size 自动擦除一个或多个扇区并写入数据。 本函数如果成功，则返回 0，否则返回非 0。 19.2.2 不擦除直接写入数据 通过 write_flash 不擦除直接写入数据。 int write_flash( // 待写入的地址 const uint32_t dest_addr, // 数据源的地址 const uint8_t *buffer, // 数据长度（以字节为单位，必须是 4 的倍数） uint32_t size); dest_addr 为统一编址后的地址，必须 32bit 对齐。write_data 不擦除 Flash，而是直接写入。 数据源不可位于 Flash 内。如果对应的 Flash 空间未被擦除，将无法写入。 本函数如果成功，则返回 0，否则返回非 0。 19.2.3 单独擦除 通过 erase_flash_sector 擦除一个指定的扇区。 int erase_flash_sector( // 待擦除的地址 const uint32_t addr); addr 必须对应于某个扇区的起始地址。本函数如果成功，则返回 0，否则返回非 0。 19.2.4 Flash 数据升级 通过 flash_do_update 可以升级 Flash 里的数据。这个函数可用于 FOTA 升级。 int flash_do_update( // 数据块数目 const int block_num, // 每个数据块的信息 const fota_update_block_t *blocks, // 用于缓存一个扇区的内存 uint8_t *ram_buffer); 每个数据块的定为为： typedef struct fota_update_block { uint32_t src; uint32_t dest; uint32_t size; } fota_update_block_t; 这个函数的行为大致如下： flash_do_update() { for (block in blocks) { flash_copy(block.dest, block.src, block.size); } } 如前所述，program_flash 的数据源不能位于 Flash，所以 flash_copy 需要把各扇区逐个读入 ram_buffer，然后使用 program_flash 擦除、写入。 这个函数如果成功，将自动重启系统，否则返回非 0。 "],["ch-rtimer.html", "20 RTIMER简介 （Reduce Timer） 20.1 功能描述 20.2 使用方法", " 20 RTIMER简介 （Reduce Timer） RTIME是Reduce Timer（递减定时器）的缩写，ING20XX系列芯片提供了两个简单的递减计数器模块。 该模块结构简单，仅支持向下计数，仅支持定时计数。可应用于简单的定时计数场景。 注意：FWLib中为方便表述将所有代码归类到peripheral_timer.c文件中。为了表述一致，将RTIMER0和RTIMER1分别表述为为TIMER2和TIMER3。 例如：RTIMER的platform注册回调命名和寄存器基地址如下表述. typedef enum { ... PLATFORM_CB_IRQ_TIMER2, PLATFORM_CB_IRQ_TIMER3, ... } platform_irq_callback_type_t; ... #define APB_TMR2 ((RTMR_TypeDef *)APB_TMR2_BASE) #define APB_TMR3 ((RTMR_TypeDef *)APB_TMR3_BASE) ... 20.1 功能描述 20.1.1 特性 32位增量计数器和32位比较寄存器 支持三种工作模式：连续回绕、自由运行、单次模式 中断支持 20.1.2 工作模式 具有三种工作模式： 连续回绕（Continuous Wrapping Mode） 定时器开始运行，并将计数器的值（Counter）和比较值（Compare）进行对比，当定时器值小于比较值时，触发中断和数值重载。 自由运行 与自动回绕模式的区别主要是在计数到比较直的时候不会自动重载数值，而是继续递减计数到0再溢出重新计数，可通过获取cnt支持，标定固定周期的定时器时间戳。 单次模式 定时器开始运行，并将计数器的值（Counter）和比较值（Compare）进行对比，当定时器值小于比较值时，触发中断，并停止计数，即定时器只运行一次就停止。 20.2 使用方法 20.2.1 API参考 初始化RTMR工作模式，RTMR支持WRAPPING、ONESHOT、FREERUN三种工作模式，用户可根据需求选择合适的工作模式。 // timer work mode #define TMR_CTL_OP_MODE_WRAPPING 0 // 0 - continuous wrapping mode #define TMR_CTL_OP_MODE_ONESHOT 1 // 1 - one-stop mode #define TMR_CTL_OP_MODE_FREERUN 2 // 2 - continuous free-run mode void RTMR_SetOpMode(RTMR_TypeDef *pTMR, uint8_t mode); 设置RTMR比较值，比较值是定时器的停止条件参考，除freerun模式，用户要根据自己的定时器工作频率和需要的计时时间计算对应的比较早。 注意递减计数器值从0递减，需要设定的定时时间值（cnt）为（0xffff - cnt） void RTMR_SetCompare(RTMR_TypeDef *pTMR, uint32_t cnt); 获取当前计数值，用户在定时器运行过程中可以通过获取当前cnt计数值，，来获取当前时间戳。 uint32_t RTMR_GetCNT(RTMR_TypeDef *pTMR); 复位当前定时器计数值，手动停止计数器或计数器初始化时推荐调用，防止定时器初值不为0造成定时时间偏差。 void RTMR_Reload(RTMR_TypeDef *pTMR); 定时器使能停止。可通过接口控制定时器的启动和停止。 void RTMR_Enable(RTMR_TypeDef *pTMR); void RTMR_Disable(RTMR_TypeDef *pTMR); 定时器中断控制，可通过接口打开和关闭对应中断。 void RTMR_IntEnable(RTMR_TypeDef *pTMR); void RTMR_IntDisable(RTMR_TypeDef *pTMR); 20.2.2 使用示例 使用自动回绕模式周期触发定时器。 static uint32_t rtimer_callback(void *user_data) { if(RTMR_IntHappened(APB_TMR2)) { printf(&quot;rtimer int\\r\\n&quot;); RTMR_IntClr(APB_TMR2); } } void rtimer_init(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_RTMR2); RTMR_SetCMP(APB_TMR2, 0xffffffff - getpll_clk() / 1000); RTMR_SetOpMode(APB_TMR2, TMR_CTL_OP_MODE_WRAPPING); RTMR_Reload(APB_TMR2); platform_set_irq_callback(PLATFORM_CB_IRQ_TIMER2, rtimer_callback, 0); RTMR_IntEnable(APB_TMR2); } 使用单次模式计数一次并触发中断 static uint32_t rtimer_callback(void *user_data) { if(RTMR_IntHappened(APB_TMR2)) { printf(&quot;rtimer int\\r\\n&quot;); RTMR_IntClr(APB_TMR2); } } void rtimer_init(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_RTMR2); RTMR_SetCMP(APB_TMR2, 0xffffffff - getpll_clk() / 1000); RTMR_SetOpMode(APB_TMR2, TMR_CTL_OP_MODE_ONESHOT); RTMR_Reload(APB_TMR2); platform_set_irq_callback(PLATFORM_CB_IRQ_TIMER2, rtimer_callback, 0); RTMR_IntEnable(APB_TMR2); } "],["ch-pte.html", "21 PTE简介 （Peripheral-Trigger-Engine） 21.1 PTE功能描述 21.2 使用方法", " 21 PTE简介 （Peripheral-Trigger-Engine） 外设触发引擎( Peripheral trigger engine，PTE )通过事件发布和任务订阅的方式实现外设之间的连接，而不需要MCU的任何干预。通过PTE连接通道，当外设发生事件时，可以自动触发外设的预定义任务。这种逻辑联系无需 CPU 干预、降低功耗、提升实时性，可以使用PTE实现外设的预定义的行为。 21.1 PTE功能描述 PTE功能包括事件发布和任务订阅。PTE事件发布器可以发布事件，PTE任务订阅器可以订阅事件并执行相应的任务。PTE可以发布的外设任务和监听事件类型是硬件预先定义的，软件只能使用预先定义的事件类型。 注意：部分外设的事件和任务和DMA相关，使用这些任务和事件必须配合DMA使用 21.1.1 特性 外设作为发布者/订阅者 外设作为发布者可以在设定的通道上发布事件。 外设作为订阅者可以根据设定通道上的事件执行对应任务。 支持多种连接选项，包括一对一、一对多、多对一、多对多。 外设可以触发DMA任务，DMA可以发布生成的事件。 支持最高16个发布和订阅通道。 16个通道可以任意作为一个分组，支持最大四个通道分组。 21.1.2 PTE外设通道连接特性 PTE外设喝PTE模块之间的连接模块称之为PTEC(Peripheral-Trigger-Engine Controller)， 功能框图如下图所示： PTE外设和PTE模块之间的连接功能框图 由该框图可以看出，外设的任务喝事件可以预先配置到任意一个或多个通道，PTEC根据通道配置，将外设的任务和事件连接起来，当注册到同一个通道的外设发生事件时，PTEC会自动触发外设的预定义任务。 例如： GPIOTE（GPIO Task Event）的按键检测事件和UART的DMA开始发送任务预先配置在一个通道0，GPIOTE模块检测到了一个按键按下的事件，发布给PTEC，PTEC根据通道配置，触发UART的DMA开始发送任务。中间无需CPU干预，提升了任务实时性。 21.1.3 PTE模块通道的使能和分组 PTE的外设连接功能框图如下所示： PTE模块通道的使能和分组 根据图示，PTE的通道连接特性包括： PTE通道内部是一个总线矩阵。 每个外设的功能task和event可以通过PTEC配置到一个或多个通道。 每个PTE通道可以单独配置使能和关闭，外设通道功能使能前无法发布和订阅事件。 PTE通道可以配置为分组，最多支持四个分组。 PTE通道分组将多个通道组合为一组，监听一个通道的event触发分组内通道的多个任务。 21.1.4 PTE事件接收器 PTE事件接收器可以在对应的通道监听事件。PTE通道会监听所有配置到当前通道的事件。 PTE支持的发布事件如下： typedef enum { PTE_EVENT_QDEC_CH0_STOP_CPL = 0, // QDEC channel 0 stop complete event PTE_EVENT_QDEC_CH1_STOP_CPL, // QDEC channel 1 stop complete event PTE_EVENT_QDEC_CH2_STOP_CPL, // QDEC channel 2 stop complete event PTE_EVENT_DMA_CH0_STOP_CPL = 0, // DMA channel 0 stop complete event PTE_EVENT_DMA_CH1_STOP_CPL, // DMA channel 1 stop complete event PTE_EVENT_DMA_CH2_STOP_CPL, // DMA channel 2 stop complete event PTE_EVENT_DMA_CH3_STOP_CPL, // DMA channel 3 stop complete event PTE_EVENT_DMA_CH4_STOP_CPL, // DMA channel 4 stop complete event PTE_EVENT_DMA_CH5_STOP_CPL, // DMA channel 5 stop complete event PTE_EVENT_DMA_CH6_STOP_CPL, // DMA channel 6 stop complete event PTE_EVENT_DMA_CH7_STOP_CPL, // DMA channel 7 stop complete event PTE_EVENT_GPIOTE_CH0_INPUT_INT = 0, // GPIOTE channel 0 input interrupt event PTE_EVENT_GPIOTE_CH1_INPUT_INT, // GPIOTE channel 1 input interrupt event PTE_EVENT_GPIOTE_CH2_INPUT_INT, // GPIOTE channel 2 input interrupt event PTE_EVENT_GPIOTE_CH3_INPUT_INT, // GPIOTE channel 3 input interrupt event PTE_EVENT_GPIOTE_CH4_INPUT_INT, // GPIOTE channel 4 input interrupt event PTE_EVENT_GPIOTE_CH5_INPUT_INT, // GPIOTE channel 5 input interrupt event PTE_EVENT_GPIOTE_CH6_INPUT_INT, // GPIOTE channel 6 input interrupt event PTE_EVENT_GPIOTE_CH7_INPUT_INT, // GPIOTE channel 7 input interrupt event PTE_EVENT_TIMER_CH0_TIM0_TIM_UP = 0, // Timer 0 channel 0 timer up event PTE_EVENT_TIMER_CH0_TIM1_TIM_UP, // Timer 1 channel 0 timer up event PTE_EVENT_TIMER_CH0_TIM2_TIM_UP, // Timer 2 channel 0 timer up event PTE_EVENT_TIMER_CH0_TIM3_TIM_UP, // Timer 3 channel 0 timer up event PTE_EVENT_TIMER_CH1_TIM0_TIM_UP, // Timer 0 channel 1 timer up event PTE_EVENT_TIMER_CH1_TIM1_TIM_UP, // Timer 1 channel 1 timer up event PTE_EVENT_TIMER_CH1_TIM2_TIM_UP, // Timer 2 channel 1 timer up event PTE_EVENT_TIMER_CH1_TIM3_TIM_UP, // Timer 3 channel 1 timer up event PTE_EVENT_SPI_TX_END = 0, // SPI TX end event PTE_EVENT_I2C_TX_CPL = 0, // I2C TX complete event PTE_EVENT_ADC_DATA_CPL = 0, // ADC data complete event PTE_EVENT_ADC_STOP_TX_ST, // ADC stop transfer status flag in dma mode PTE_EVENT_UART_TX_INT = 0, // UART TX interrupt event PTE_EVENT_UART_RX_INT, // UART RX interrupt event PTE_EVENT_PWM_CH0_PWM_STOP = 0, // PWM channel 0 PWM stop event PTE_EVENT_PWM_CH0_FIFO_TRG, // PWM channel 0 FIFO trigger event PTE_EVENT_PWM_CH0_PCM_STOP, // PWM channel 0 PCM stop event PTE_EVENT_PWM_CH1_PWM_STOP, // PWM channel 1 PWM stop event PTE_EVENT_PWM_CH1_FIFO_TRG, // PWM channel 1 FIFO trigger event PTE_EVENT_PWM_CH1_PCM_STOP, // PWM channel 1 PCM stop event PTE_EVENT_PWM_CH2_PWM_STOP, // PWM channel 2 PWM stop event PTE_EVENT_PWM_CH2_FIFO_TRG, // PWM channel 2 FIFO trigger event PTE_EVENT_PWM_CH2_PCM_STOP, // PWM channel 2 PCM stop event PTE_EVENT_ASDM_RX_DATA = 0, // ASDM RX data event }PTE_Event; 这些支持的事件可配置到对应的PTE通道上报对应的外设事件。 21.1.5 PTE任务发布器 PTE任务发布器用于将任务发布到对应的外设，PTE监听到通道上的事件后会触发配置到当前通道的所有任务执行。PTE任务发布器支持以下任务： typedef enum { PTE_TASK_QDEC_CH0_START = 0, // QDEC channel 0 start PTE_TASK_QDEC_CH0_STOP, // QDEC channel 0 stop PTE_TASK_QDEC_CH1_START, PTE_TASK_QDEC_CH1_STOP, PTE_TASK_QDEC_CH2_START, PTE_TASK_QDEC_CH2_STOP, PTE_TASK_GPIOTE_TOGGLE_CH0 = 0, // GPIOTE channel 0 toggle PTE_TASK_GPIOTE_TOGGLE_CH1, PTE_TASK_GPIOTE_TOGGLE_CH2, PTE_TASK_GPIOTE_TOGGLE_CH3, PTE_TASK_GPIOTE_TOGGLE_CH4, PTE_TASK_GPIOTE_TOGGLE_CH5, PTE_TASK_GPIOTE_TOGGLE_CH6, PTE_TASK_GPIOTE_TOGGLE_CH7, PTE_TASK_GPIOTE_HIGH_CH0, // GPIOTE channel 0 high PTE_TASK_GPIOTE_HIGH_CH1, PTE_TASK_GPIOTE_HIGH_CH2, PTE_TASK_GPIOTE_HIGH_CH3, PTE_TASK_GPIOTE_HIGH_CH4, PTE_TASK_GPIOTE_HIGH_CH5, PTE_TASK_GPIOTE_HIGH_CH6, PTE_TASK_GPIOTE_HIGH_CH7, PTE_TASK_GPIOTE_LOW_CH0, // GPIOTE channel 0 low PTE_TASK_GPIOTE_LOW_CH1, PTE_TASK_GPIOTE_LOW_CH2, PTE_TASK_GPIOTE_LOW_CH3, PTE_TASK_GPIOTE_LOW_CH4, PTE_TASK_GPIOTE_LOW_CH5, PTE_TASK_GPIOTE_LOW_CH6, PTE_TASK_GPIOTE_LOW_CH7, PTE_TASK_TIMER_CH0_TM0_START = 0, // TIMER channel 0 timer 0 start PTE_TASK_TIMER_CH0_TM1_START, PTE_TASK_TIMER_CH0_TM2_START, PTE_TASK_TIMER_CH0_TM3_START, PTE_TASK_TIMER_CH1_TM0_START, PTE_TASK_TIMER_CH1_TM1_START, PTE_TASK_TIMER_CH1_TM2_START, PTE_TASK_TIMER_CH1_TM3_START, PTE_TASK_TIMER_CH0_TM0_STOP, // TIMER channel 0 timer 0 stop PTE_TASK_TIMER_CH0_TM1_STOP, PTE_TASK_TIMER_CH0_TM2_STOP, PTE_TASK_TIMER_CH0_TM3_STOP, PTE_TASK_TIMER_CH1_TM0_STOP, PTE_TASK_TIMER_CH1_TM1_STOP, PTE_TASK_TIMER_CH1_TM2_STOP, PTE_TASK_TIMER_CH1_TM3_STOP, PTE_TASK_SPI_MASTER_TX_START = 0, // start spi master transfer in dma mode PTE_TASK_SPI_MASTER_TX_STOP, //stop spi master transfer in dma mode PTE_TASK_I2C_MASTER_TX = 0, //I2C start i2c master transfer in dma mode PTE_TASK_ADC_START = 0, // ADC start to sample data PTE_TASK_ADC_LOOP, // acd loop PTE_TASK_ADC_STOP_TX, // adc stop transfer in dma mode PTE_TASK_UART_TX_START = 0, // UART start transmiting data in dma mode PTE_TASK_UART_TX_STOP, // UART stop transmiting data in dma mode PTE_TASK_UART_RX_START, // UART start receiving data in dma mode PTE_TASK_UART_RX_STOP, // UART stop receiving data in dma mode PTE_TASK_PWM_CH0_IR_START = 0, // PWM channel 0 IR send start PTE_TASK_PWM_CH0_ONE_PULSE, //PWM channel0 one pulse pwm PTE_TASK_PWM_CH0_PWM_START, //PWM channel0 start pwm PTE_TASK_PWM_CH0_PWM_DMA_START, //PWM channel0 start pwm in dma mode PTE_TASK_PWM_CH0_PCM_START, //PWM channel0 start pcm PTE_TASK_PWM_CH0_PWM_STOP, //PWM channel0 stop pwm PTE_TASK_PWM_CH0_PCM_STOP, //PWM channel0 stop pcm PTE_TASK_PWM_CH1_IR_START, PTE_TASK_PWM_CH1_ONE_PULSE, PTE_TASK_PWM_CH1_PWM_START, PTE_TASK_PWM_CH1_PWM_DMA_START, PTE_TASK_PWM_CH1_PCM_START, PTE_TASK_PWM_CH1_PWM_STOP, PTE_TASK_PWM_CH1_PCM_STOP, PTE_TASK_PWM_CH2_IR_START, PTE_TASK_PWM_CH2_ONE_PULSE, PTE_TASK_PWM_CH2_PWM_START, PTE_TASK_PWM_CH2_PWM_DMA_START, PTE_TASK_PWM_CH2_PCM_START, PTE_TASK_PWM_CH2_PWM_STOP, PTE_TASK_PWM_CH2_PCM_STOP, PTE_TASK_I2S_TX_START = 0, // I2S start sending data in dma mode PTE_TASK_I2S_RX_START, // I2S start receiving data in dma mode PTE_TASK_I2S_TX_STOP, // I2S stop sending data PTE_TASK_I2S_RX_STOP, // I2S stop receiving data PTE_TASK_ASDM_RX_START = 0, //ASDM start receiving data PTE_TASK_ASDM_RX_STOP, //ASDM stop receiving data }PTE_Task; 21.1.6 PTE分组 PTE可以将多个PTE通道映射到同一个PTE分组内，一个分组可以订阅一个PTE通道，当该PTE的时间源触发后，分组内的所有PTE通道都会执行相应的任务。 21.2 使用方法 21.2.1 API介绍 配置使能对应的任务到指定的PTE通道,使用该接口配置pte通道触发后要执行的任务。 uint8_t PTE_ConfigTask(PTE_Module module, PTE_Task Task, PTE_Channel SetTaskChannel, uint8_t enable); 配置使能对应的监听事件到指定的PTE通道,使用该接口配置pte通道触发事件源。 uint8_t PTE_ConfigEvent(PTE_Module module, PTE_Event Event, PTE_Channel SetEventChannel, uint8_t enable); 触发对应的任务，使用该接口可以通过软件方式手动触发任务运行，可以测试任务触发情况或手动触发任务运行。 uint8_t PTE_TaskTrigger(PTE_Module module, PTE_Task Task); 使能对应的PTE通道，使用该接口使能PTE通道。PTE必须使能通道有效 void PTE_ChxEnable(uint32_t items); 关闭对应的PTE通道使能 void PTE_ChxDisable(uint32_t items); 获取当前的通道使能状态 uint32_t PTE_ChxGetEnableState(void); 使能PTE分组，调用该接口相当于一直向整个GROUP所有通道发送执行对应任务的信号。 void PTE_SetTaskChxGroupEN(PTEC_ChannelGroup SetChannelGroup) 关闭PTE分组，关闭向整个GROUP发送所有通道的执行任务信号。 void PTE_SetTaskChxGroupDIS(PTEC_ChannelGroup SetChannelGroup) 使能对分组对指定通道事件的订阅 void PTE_SetTaskSubChxGroupEn(PTEC_ChannelGroup SetChannelGroup,uint32_t SetSubChannel); 关闭对分组对指定通道事件的订阅 void PTE_SetTaskSubChxGroupDis(PTEC_ChannelGroup SetChannelGroup,uint32_t SetSubChannel); 设置多个PTE通道映射到某个PTE分组 void PTE_SetTaskChxGroup(PTEC_ChannelGroup SetChannelGroup,uint32_t SetChannel); 21.2.2 示例代码 21.2.3 使用示例 下面代码将以GPIOTE模块初始化一个IO检测这个IO的电平状态，触发另外三个GPIOTE模块翻转三个IO的电平状态这个应用场景为例，展示GPIOTE模块和PTE模块的使用。 GPIO 使用 CHANNEL1接收IO7触发事件，IO需要设置为输入模式，开启GPIO中断使能，外部IO上拉，设置中断模式为下降沿触发，使用GPIOTE的0 2 3三个通道映射GIO_GPIO_24、25、26三个IO，当GPIO7触发下降沿事件时，GPIOTE的0 2 3三个通道会翻转GIO_GPIO_24、25、26三个IO的电平状态。 void pte_gpiote_test(void) { SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_GPIO0); SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_GPIO1); SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_GPIOTE); PINCTRL_Pull(GIO_GPIO_7, PINCTRL_PULL_UP); GIO_ConfigIntSource(GIO_GPIO_7, GIO_INT_EN_LOGIC_LOW_OR_FALLING_EDGE, GIO_INT_EDGE); GPIOTE_Configuration(GPIOTE_CHANNEL_0,GPIOTE_CHANNEL_TASK, GIO_GPIO_24, 0); GPIOTE_Configuration(GPIOTE_CHANNEL_2,GPIOTE_CHANNEL_TASK, GIO_GPIO_25, 0); GPIOTE_Configuration(GPIOTE_CHANNEL_3,GPIOTE_CHANNEL_TASK, GIO_GPIO_26, 0); GPIOTE_Configuration(GPIOTE_CHANNEL_1,GPIOTE_CHANNEL_EVENT, GIO_GPIO_7, 0); PTE_ConfigTask(PTE_GPIOTE_MODULE, PTE_TASK_GPIOTE_TOGGLE_CH0, PTE_CHANNEL_0, 1); PTE_ConfigTask(PTE_GPIOTE_MODULE, PTE_TASK_GPIOTE_TOGGLE_CH2, PTE_CHANNEL_0, 1); PTE_ConfigTask(PTE_GPIOTE_MODULE, PTE_TASK_GPIOTE_TOGGLE_CH3, PTE_CHANNEL_0, 1); PTE_ConfigEvent(PTE_GPIOTE_MODULE, PTE_EVENT_GPIOTE_CH1_INPUT_INT, PTE_CHANNEL_0, 1); PTE_ChxEnable(1 &lt;&lt; PTE_CHANNEL_0); } void main(void) { pte_gpiote_test(); while(1); } 使用该代码测试，按下GPIO7对应的按键，GPIO24、GPIO25和GPIO26会翻转状态，LED灯会亮起和熄灭。 "],["ch-gpiote.html", "22 GPIOTE简介 （GPIO tasks and events） 22.1 GPIOTE 功能描述 22.2 使用方法", " 22 GPIOTE简介 （GPIO tasks and events） 22.1 GPIOTE 功能描述 GPIOTE（GGPIO tasks and events）模块提供了使用任务和事件访问GPIO引脚的功能。每个GPIOTE通道可以分配给一个引脚。 GPIOTE块使GPIO可以在PIN状态更改时生成事件，该事件可用于通过PTE系统执行任务。 GPIO也可以接收PTE系统事件改变IO状态。 GPIOTE系统可以理解为GPIO系统的扩展，GPIO模块无法直接和PTE系统交互，通过GPIOTE系统，可以和PTE系统进行交互，从而实现PTE监听GPIO的输入事件和控制GPIO的输出状态的功能。 22.1.1 模块特性 三个GPIO任务（SET CLR TOGGLE）可选。 三个GPIO任务可以在每个GPIOTE的通道上使用。 每个GPIOTE通道可以根据输入管脚的中断状态生成输入事件。 可以在每个GPIOTE通道中配置引脚的初始值输出电平（仅作为任务模式时，GPIO OUT生效）。 共有8个GPIOTE通道与PTE系统相连，每个通道可以配置为任务或事件模式。 每个GPIOTE通道可以配置一个IO映射。 22.1.2 连接特性 所有的GPIO都与GPIOTE块相连接，任意的IO都可作为GPIOTE模块的输入输出源，选取的8个GPIOTE通道可作为PTE模块的任务/事件访问通道。 GPIOTE模块作为连接PTE总线通道的外设，可由PTEC模块进行全局控制。 22.1.3 设计概述 GPIOTE 模块会接管GPIO模块的输入输出特性，通过GPIOTE模块，可以实现对GPIO的输入事件监听和输出状态控制。当GPIOTE模块接管GPIO模块后，GPIO模块的寄存器设置失效。无法控制对应IO的模式和电平状态。 当IO映射到GPIOTE通道： GIOTE通道模式设定为关闭时：GPIO的输入输出模式和外部电平状态取决于GPIO模块的内部设置。 GIOTE通道模式设定为事件时：对应的GPIO设置为输入模式，GPIOTE模块会监听GPIO的输入状态，当状态变化时，GPIOTE模块会触发事件，并通知PTE系统。 GIOTE通道模式设定为任务时：对应的GPIO设置为输出模式，GPIOTE模块会根据任务类型对GPIO进行输出控制。并且GPIO的默认输出状态取决于GPIOTE模块的配置。 22.2 使用方法 22.2.1 API概述 GPIOTE模块属于GPIO的扩展，连接到PTE模块，因此API接口放置于peripheral_pte.c文件中。 初始化GPIOTE模块配置,配置对应的通道和设置的IO模式以及设置默认输出电平： void GPIOTE_Configuration(GPIOTE_Channel channel, GPIOTE_Mode mode, uint8_t pin, uint8_t out_level); 22.2.2 使用示例 GPIOTE模块需要配置PTE模块进行使用，对应示例可参考PTE模块的使用DEMO。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
