[["index.html", "ING916XX 系列芯片外设开发者手册 1 版本历史", " ING916XX 系列芯片外设开发者手册 Ingchips Technology Co., Ltd. 1 版本历史 版本 信息 日期 0.1 初始版本 2022-xx-xx "],["ch-overview.html", "2 概览 2.1 缩略语及术语 2.2 参考文档", " 2 概览 欢迎使用 INGCHIPS 918xx/916xx 软件开发工具包 （SDK）. ING916XX 系列芯片支持蓝牙 5.3 规范，内置高性能 32bit RISC MCU（支持 DSP 和 FPU）、Flash、低功耗 PMU， 以及丰富的外设、高性能低功耗 BLE RF 收发机。BLE 发射功率。 本文介绍 SoC 外设及其开发方法。每个章节介绍一种外设，各种外设与芯片数据手册之外设一一对应， 基于 API 的兼容性、避免误解等因素，存在以下例外： PINCTRL 对应于数据手册之 IOMUX PCAP 对应于数据手册之 PCM SYSCTRL 是一个“虚拟”外设，负责管理各种 SoC 功能，组合了几种相关的硬件模块 SDK 外设驱动的源代码开放，其中包含很多常数，而且几乎没有注释 —— 这是有意为之，开发者只需要关注头文件，而不要尝试修改源代码。 2.1 缩略语及术语 表 2.1: 缩略语 缩略语 说明 ADC 模数转换器（Analog-to-Digital Converter） DMA 直接存储器访问（Direct Memory Access） EFUSE 电编程熔丝（Electronic Fuses） FIFO 先进先出队列（First In First Out） FOTA 固件空中升级（Firmware Over-The-Air） GPIO 通用输入输出（General-Purpose Input/Output） I2C 集成电路间总线（Inter-Integrated Circuit） I2S 集成电路音频总线（Inter-IC Sound） IR 红外线（Infrared） PCAP 脉冲捕捉（Pulse CAPture） PDM 脉冲密度调制（Pulse Density Modulation） PTE 外设触发引擎（Peripheral Trigger Engine） PWM 脉宽调制信号（Pulse Width Modulation） QDEC 正交解码器（Quadrature Decoder） RTC 实时时钟（Real-time Clock） SPI 串行外设接口（Serial Peripheral Interface） UART 通用异步收发器（Universal Asynchronous Receiver/Transmitter） USB 通用串行总线（Universal Serial Bus） 2.2 参考文档 Bluetooth SIG1 ING916XX 系列芯片数据手册2 https://www.bluetooth.com/↩︎ http://www.ingchips.com/product/70.html↩︎ "],["ch-adc.html", "3 ADC简介 3.1 功能描述 3.2 使用方法 3.3 编程指南", " 3 ADC简介 ADC全称Analog-to-Digital Converter，即模数转换器。 其主要作用是通过PIN测量电压，并将采集到的电压模拟信号转换成数字信号。 3.1 功能描述 3.1.1 特点 最多12个单端输入通道或4个差分输入通道 14位分辨率 电压输入范围（0~3.6V） 支持APB总线 采样频率可编程 支持单一转换模式 支持回路转换模式，每个通道均可启用或禁用 3.1.2 ADC模式 校准模式（calibration）：用于校准ADC采样精度。分为单端模式校准和差分模式校准，两种模式校准互相独立 转换模式（conversion）：用于正常工作状态下的模数转换 根据ADC输入模式完成对应的模式校准，之后在转换模式下进行正常模数转换。 3.1.3 ADC输入模式 单端输入（single end）：使用单个输入引脚，采用ADC内部的参考电压 差分输入（differential）：使用一组输入引脚分别作为参考电压 一般来说，差分输入有利于避免共模干扰的影响，结果相对准确。 3.1.4 ADC转换模式 单次转换（single）：单次转换在使能转换通道，采样和转换后，ADC将停止，数据将被拉入 FIFO 连续转换（continuous）：连续转换在逐个使能通道，采样并转换后，经过 loop-delay 时间后循环进行操作，ADC不会停止直到手动关闭 3.1.5 ADC通道 ADC共12个channel，即ch0-ch11。 其中ch0-ch7是通用通道，ch8-ch11是内部通道，可以用来采集内部信号。 具体通道的输入连接引脚如下： 表 3.1: ADC输入连接引脚 通道 连接引脚 ch0 GPIO7 ch1 GPIO8 ch2 GPIO9 ch3 GPIO10 ch4 GPIO11 ch5 GPIO12 ch6 GPIO13 ch7 GPIO14 ch8 diag_hv_soc ch9 VREF12_ADC_IN ch10 VCC ch11 V18_FLASH ch0-ch7可以配置成为4对差分输入通道，配置后将对应差分的通道0-3。 注意： 配置ADC输入模式为差分模式下则只有ch0-ch3以及ch8-ch11。 3.1.6 PGA ADC的PGA默认是开启的，目前使用时不支持关闭。 ADC的PGA有8个增益值，其大小为 2^n(n=0-7) ，但是目前增益值n=6,7暂不支持配置。 对于PGA增益值配置，目前ch0-ch7可以配置的增益值为 2^n(n=0-5) ch8-ch11增益值暂不支持配置，其增益值固定为2. 3.2 使用方法 3.2.1 输入电压范围 不同ADC输入模式下的输入电压要求如下： 单端模式：VIN ∈ [VREFP/2-VREFP/PGA_GAIN, VREFP/2+VREFP/PGA_GAIN] 差分模式：VINP-VINN ∈ [-VREFP/PGA_GAIN, VREFP/PGA_GAIN]，且VINP， VINN&gt;=0 其中PGA_GAIN是PGA的增益值 注意： 请务必保证输入电压满足以上的范围要求，过大、过小的输入电压可能会使ADC不能正常工作甚至造成损坏芯片的严重后果。 3.2.2 采样率 采样率和时钟、loop-delay大小有关，其计算关系如下： SAMPLERATE=ADC_CLK/(loop-delay+16) 3.2.3 方法概述 方法概述为：时钟配置，ADC校准，ADC参数配置和中断（DMA中断）注册。 3.2.3.1 时钟配置 当前ADC所用时钟源为 clock slow 经过分频得到的ADC工作时钟 当前ADC工作时钟可以配置为1M、2M、4M和6M。高于6M的时钟暂不支持配置 注意： 由于ADC工作时钟只可以取以上特定值，ADC时钟必须经过 clock slow 分频。故在同时使用和ADC同时钟源模块时，如IR，可能出现时钟配置冲突的现象。开发者在实际使用时需要格外注意，具体请参考916时钟树（图 3.1）。 图 3.1: 916时钟树ADC模块部分截图 3.2.3.2 ADC校准 ADC校准包含精度校准和内部参考电压校准 ADC精度校准接口：ADC_Calibration 内部参考电压校准接口：ADC_VrefCalibration 在进行ADC转换之前需要进行ADC精度校准，如果需要计算采集电压则需要进行内部参考电压校准 ADC精度校准需要明确ADC输入模式（单端/差分），两种模式需要分别进行精度校准 3.2.3.3 ADC参数配置 ADC参数配置接口：ADC_ConvCfg 涉及参数有：ADC转换模式、ADC输入模式、PGA增益值、PGA开关（目前不支持关闭）、采样通道、data触发中断数、data触发DMA搬运数和 loop-delay data触发中断数和data触发DMA搬运数决定了搬运ADC数据的方式。前者用触发中断的方式，后者用触发DMA搬运的方式 对于中断/DMA搬运方式选择上，建议如下： 一般在小数据量情况下，如定时采集温度，建议采用触发中断并CPU读数的方式 一般大数据量采样，如模拟麦克风采样，建议采用DMA搬运方式或者乒乓搬运，可以大大提高数据搬运处理效率 3.2.3.4 ADC数据处理 ADC数据处理的推荐方法为： 1. 调用ADC_PopFifoData（或DMA搬运buff）读取FIFO中的ADC原始数据 2. 调用ADC_GetDataChannel得到原始数据中的数据所属通道（如需要） 3. 调用ADC_GetData得到原始数据中的ADC数据 4. 调用ADC_GetVol通过ADC数据计算得到其对应的电压值（如需要） 也可以通过调用ADC_ReadChannelData接口直接得到指定通道的ADC数据。但这样会丢弃其他通道数据，请谨慎使用。其可以作为辅助接口使用，非主要方式。 3.2.4 注意点 一般来说配置ADC时钟频率越高，其工作效率越好。较为推荐使用4M、6M工作时钟，性能稳定 ADC时钟选择需要根据实际设备采样率选择，如模拟mic，应参考mic操作手册来选择对应ADC时钟频率 差分输入电压需要控制范围为0~3.6V 如果需要计算采集电压建议周期性地进行参考电压校准 目前暂不支持用户自己输入参考电压值，只能用内部电压值作为参考电压 PGA增益值的选择需要结合实际设备，可以参考具体设备的使用手册或者测试电压范围计算得到。注意不能超过参考电压阈值 data触发中断数和data触发DMA搬运数应该一个为0，一个非0,。如果两值都非0则优先选择触发中断的方式 通过ADC数据计算得到的电压值会被限制在0到正参考电压之间 3.3 编程指南 3.3.1 驱动接口 此处列举几个较为常用的接口： ADC_ConvCfg：ADC转换标准配置接口 ADC_Calibration：ADC校准标准配置接口 ADC_VrefCalibration：内部参考电压校准接口 ADC_Reset：ADC复位接口 ADC_Start：ADC使能接口 ADC_AdcClose：ADC关闭接口 ADC_GetFifoEmpty：读取FIFO是否为空接口 ADC_PopFifoData：读取FIFO原始数据接口 ADC_GetDataChannel：读取原始数据中通道号接口 ADC_GetData：读取原始数据中ADC数据接口 ADC_ReadChannelData：读取特定通道ADC数据接口 ADC_GetVol：读取ADC数据对应电压值接口 还有部分接口不推荐直接使用，在此不进行介绍，详见对应驱动程序头文件声明。 3.3.2 代码示例 3.3.2.1 触发中断搬运 下面展示用ADC中断进行数据搬运的基本用法： 以下ADC设置参数仅供参考，具体参数请结合实际需要进行配置。 #define ADC_CHANNEL ADC_CH_0 #define ADC_CLK_MHZ 6 static uint32_t ADC_cb_isr(void *user_data) { uint32_t data = ADC_PopFifoData(); SADC_channelId channel = ADC_GetDataChannel(data); if (channel == ADC_CHANNEL) { uint16_t sample = ADC_GetData(data); // do something with &#39;sample&#39; } return 0; } void test(void) { SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_ADC); SYSCTRL_SetAdcClkDiv(24 / ADC_CLK_MHZ); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_ADC); ADC_Calibration(SINGLE_END_MODE); ADC_ConvCfg(SINGLE_MODE, PGA_GAIN_4, 1, ADC_CHANNEL, 1, 0, SINGLE_END_MODE, 0); platform_set_irq_callback(PLATFORM_CB_IRQ_ADC, ADC_cb_isr, 0); ADC_Start(1); } 以上代码展示了配置ADC时钟，逻辑复位、ADC校准、ADC转换配置，并在触发的ADC中断程序里获取到最终的 sample 数值。 当然，由于使用单一ADC通道，可以直接获取特定通道的ADC数据，代码如下： static uint32_t ADC_cb_isr(void *user_data) { uint16_t sample = ADC_ReadChannelData(ADC_CHANNEL); // do something with &#39;sample&#39; return 0; } 在只有单个通道数据时或者只需要单一通道数据时可以采用以上方式，多通道采样有丢数据的风险。 3.3.2.2 连续中断搬运 以上代码展示的是单次搬运情况，如果是多次搬运，建议采用以下两种读数方案： 1. 读数并结合调用ADC_GetFifoEmpty接口判断FIFO状态，读数直到FIFO为空为止 2. 每次读取的数据量等于配置的data触发中断数 方案1代码示例： static uint32_t ADC_cb_isr(void *user_data) { while (!ADC_GetFifoEmpty()) { uint16_t sample = ADC_ReadChannelData(ADC_CHANNEL); // do something with &#39;sample&#39; } return 0; } 方案2代码示例： #define INT_TRIGGER_NUM 8 static uint32_t ADC_cb_isr(void *user_data) { uint8_t i = 0; while (i &lt; INT_TRIGGER_NUM) { uint16_t sample = ADC_ReadChannelData(ADC_CHANNEL); // do something with &#39;sample&#39; i++; } return 0; } CPU资源方面，方案2节省了每次读数调用接口的开销，建议优选 实际效果方面以上两种方案均可，开发者可以自行选用。 3.3.2.3 获取电压值 获取电压值需要在上面例子中加入参考电压校准，并调用接口计算电压值，如下： #define ADC_CHANNEL ADC_CH_0 #define ADC_CLK_MHZ 6 static uint32_t ADC_cb_isr(void *user_data) { uint16_t sample = ADC_ReadChannelData(ADC_CHANNEL); float voltage = ADC_GetVol(sample); return 0; } void test(void) { SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_ADC); SYSCTRL_SetAdcClkDiv(24 / ADC_CLK_MHZ); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_ADC); ADC_Calibration(SINGLE_END_MODE); ADC_VrefCalibration(); // calibrate the referenced voltage ADC_ConvCfg(SINGLE_MODE, PGA_GAIN_4, 1, ADC_CHANNEL, 1, 0, SINGLE_END_MODE, 0); platform_set_irq_callback(PLATFORM_CB_IRQ_ADC, ADC_cb_isr, 0); ADC_Start(1); } voltage即为最终计算得到的采样电压值。 3.3.2.4 ADC &amp; DMA乒乓搬运 ADC结合DMA乒乓搬运数据的方式是一种推荐的标准用法，其优点主要是节省CPU资源，提高处理数据的效率。 下面展示DMA乒乓搬运ADC数据并转换成电压的实例： #include &quot;pingpong.h&quot; #define ADC_CHANNEL ADC_CH_0 #define DMA_CHANNEL 0 #define ADC_CLK_MHZ 6 static DMA_PingPong_t PingPong; static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(DMA_CHANNEL); DMA_ClearChannelIntState(DMA_CHANNEL, state); uint32_t *buff = DMA_PingPongIntProc(&amp;PingPong, DMA_CHANNEL); uint32_t tranSize = DMA_PingPongGetTransSize(&amp;PingPong); for (uint32_t i = 0; i &lt; tranSize; ++i) { if (ADC_GetDataChannel(buff[i]) != ADC_CHANNEL) continue; uint16_t sample = ADC_GetData(buff[i]); float voltage = ADC_GetVol(sample); } return 0; } void test(void) { SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ITEM_APB_DMA)); SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_ADC); SYSCTRL_SetAdcClkDiv(24 / ADC_CLK_MHZ); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_ADC); ADC_Calibration(DIFFERENTAIL_MODE); ADC_VrefCalibration(); ADC_ConvCfg(CONTINUES_MODE, PGA_GAIN_4, 1, ADC_CHANNEL, 0, 8, DIFFERENTAIL_MODE, 6000); SYSCTRL_SelectUsedDmaItems(1 &lt;&lt; 9); DMA_PingPongSetup(&amp;PingPong, SYSCTRL_DMA_ADC, 80, 8); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); DMA_PingPongEnable(&amp;PingPong, DMA_CHANNEL); ADC_Start(1); } "],["ch-dma.html", "4 DMA简介 4.1 功能描述 4.2 使用方法 4.3 编程指南", " 4 DMA简介 DMA全称direct memory access，即直接存储器访问。 其主要作用是不占用CPU大量资源，在AMBA AHB总线上的设备之间以硬件方式高速有效地传输数据。 4.1 功能描述 4.1.1 特点 符合AMBA、AHB和APB4标准 最多8个DMA通道 最多16个硬件握手请求/确认配对 支持8/16/32/64位宽的数据传输 支持24-64位地址宽度 支持成链传输数据 4.1.2 搬运方式 单次数据块搬运：DMA使用单个通道，一次使能将数据从SRC到DST位置搬运一次 成串多数据块搬运：DMA使用单个通道，一次使能按照DMA链表信息依次将数据从SRC到DST位置搬运多次或循环搬运。 其根本区别是有无注册有效的DMA链表。 4.1.3 搬运类型 memory到memory搬运 memory到peripheral搬运 peripheral到memory搬运 peripheral到peripheral搬运 4.1.4 中断类型 IntErr：错误中断表示DMA传输发生了错误而触发中断，主要包括总线错误、地址没对齐和传输数据宽度没对齐等。 IntAbt：终止传输中断会在终止DMA通道传输时产生。 IntTC：TC中断会在没有产生IntErr和IntAbt的情况下完成一次传输时产生。 4.1.5 数据地址类型 Increment address Decrement address Fixed address 如果Increment则DMA从地址由小到大搬运数据，相反的Decrement则由大到小搬运。fixed地址适用于外设FIFO的寄存器搬运数据。 4.1.6 数据方式 normal mode handshake mode 一般外设寄存器选择用握手方式。 选择握手方式要和外设协商好SrcBurstSize，当前支持2^n(n = 0-7)大小的SrcBurstSize。 4.1.7 数据位宽 DMA传输要求传输两端的数据类型一致，支持数据类型有： Byte transfer Half-word transfer Word transfer Double word transfer 覆盖所有常见数据类型。 4.2 使用方法 4.2.1 方法概述 首先确认数据搬运需求是单次搬运还是成串搬运，搬运类型memory和peripheral的关系。 4.2.1.1 单次搬运 1. 注册DMA中断 2. 定义一个DMA_Descriptor变量用来配置DMA通道寄存器 3. 根据数据搬运类型选择DMA寄存器配置接口，正确调用驱动接口配置DMA寄存器 4. 使能DMA通道开始搬运 4.2.1.2 成串搬运 1. 注册一个或多个DMA中断 2. 定义多个DMA_Descriptor变量用来配置DMA通道寄存器 3. 根据数据搬运类型选择DMA寄存器配置接口，正确调用驱动接口配置DMA寄存器 4. 将多个DMA_Descriptor变量首尾相连成串，类似链表 5. 使能DMA通道开始搬运 4.2.2 注意点 定义DMA_Descriptor变量需要8字节对齐，否则DMA搬运不成功 成串搬运如果配置多个DMA中断则需要在每个中断里使能DMA，直到最后一次搬运完成 对于从外设搬运需要确认外设是否支持DMA 建议从外设搬运选择握手方式，并与外设正确协商burstSize burstSize尽量取较大值，有利于减少DMA中断次数提高单次中断处理效率。但burstSize太大可能最后一次不能搬运丢弃较多数据 建议设置从外设搬运总数据量为burstSize的整数倍或采用乒乓搬运的方式 在DMA从外设搬运的情况下，正确的操作顺序是先配置并使能好DMA，再使能外设开始产生数据 4.3 编程指南 4.3.1 驱动接口 DMA_PrepareMem2Mem：memory到memory搬运标准DMA寄存器配置接口 DMA_PreparePeripheral2Mem：Peripheral到memory搬运标准DMA寄存器配置接口 DMA_PrepareMem2Peripheral：memory到Peripheral搬运标准DMA寄存器配置接口 DMA_PreparePeripheral2Peripheral：Peripheral到Peripheral搬运标准DMA寄存器配置接口 DMA_Reset：DMA复位接口 DMA_GetChannelIntState：DMA通道中断状态获取接口 DMA_ClearChannelIntState：DMA通道清中断接口 DMA_EnableChannel：DMA通道使能接口 DMA_AbortChannel：DMA通道终止接口 4.3.2 代码示例 4.3.2.1 单次搬运 下面以memory到memory单次搬运展示DMA的基本用法： #define CHANNEL_ID 0 char src[] = &quot;hello world!&quot;; char dst[20]; DMA_Descriptor test __attribute__((aligned (8))); static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); printf(&quot;dst = %s\\n&quot;, dst); return 0; } void DMA_Test(void) { DMA_Reset(); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); DMA_PrepareMem2Mem(&amp;test[0], dst, src, strlen(src), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_EnableChannel(CHANNEL_ID, &amp;test); } 最终会在DMA中断程序里面将搬运到dst中的“hello world!”字符串打印出来。 4.3.2.2 成串搬运 下面以memory到memory两块数据搬运拼接字符串展示DMA成串搬运的基本用法： #define CHANNEL_ID 0 char src[] = &quot;hello world!&quot;; char src1[] = &quot;I am a chinese.&quot;; char dst[100]; DMA_Descriptor test[2] __attribute__((aligned (8))); static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); printf(&quot;dst = %s\\n&quot;, dst); return 0; } void DMA_Test(void) { DMA_Reset(); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); test[0].Next = &amp;test[1]; // make a DMA link chain test[1].Next = NULL; DMA_PrepareMem2Mem(&amp;test[0], dst, src, strlen(src), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_PrepareMem2Mem(&amp;test[1], dst + strlen(src), src1, sizeof(src1), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_EnableChannel(CHANNEL_ID, &amp;test[0]); } 最终将会打印出“hello world!I am a chinese.”字符串。 4.3.2.3 DMA乒乓搬运 DMA乒乓搬运是一种DMA搬运的特殊用法，其主要应用场景是将外设FIFO中数据循环搬运到memory中并处理。 可实现“搬运”和“数据处理”分离，从而大大提高程序处理数据的效率。 对于大量且连续的数据搬运，如音频，我们推荐选用DMA乒乓搬运的方式。 4.3.2.3.1 DMA乒乓搬运接口 在最新SDK中我们已将DMA乒乓搬运封装成标准接口，方便开发者调用，提高开发效率。 使用时请添加 pingpong.c文件，并包含 pingpong.h文件。 DMA_PingPongSetup：DMA乒乓搬运建立接口 DMA_PingPongIntProc：DMA乒乓搬运标准中断处理接口 DMA_PingPongGetTransSize：获取DMA乒乓搬运数据量接口 DMA_PingPongEnable：DMA乒乓搬运使能接口 DMA_PingPongDisable：DMA乒乓搬运去使能接口 4.3.2.3.2 DMA乒乓搬运示例 下面将以最常见的DMA乒乓搬运I2s数据为例展示DMA乒乓搬运的用法。 I2s的相关配置不在本文的介绍范围内，默认I2s已经配置好，DMA和I2s协商burstSize=8。 #include &quot;pingpong.h&quot; #define CHANNEL_ID 0 DMA_PingPong_t PingPong; static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); // call &#39;DMA_PingPongIntProc&#39; to get the pointer of data-buff. uint32_t *rr = DMA_PingPongIntProc(&amp;PingPong, CHANNEL_ID); uint32_t i = 0; // call &#39;DMA_PingPongGetTransSize&#39; to kwon how much data in data-buff. uint32_t transSize = DMA_PingPongGetTransSize(&amp;PingPong); while (i &lt; transSize) { // do something with data &#39;rr[i]&#39; i++; } return 0; } void DMA_Test(void) { // call &#39;DMA_PingPongSetup&#39; to setup ping-pong DMA. DMA_PingPongSetup(&amp;PingPong, SYSCTRL_DMA_I2S_RX, 100, 8); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); // call &#39;DMA_PingPongEnable&#39; to start ping-pong DMA transmission. DMA_PingPongEnable(&amp;PingPong, CHANNEL_ID); I2S_ClearRxFIFO(APB_I2S); I2S_DMAEnable(APB_I2S, 1, 1); I2S_Enable(APB_I2S, 0, 1); // Enable I2s finally } 停止DMA乒乓搬运可以调用以下接口： void Stop(void) { // call &#39;DMA_PingPongEnable&#39; to disable ping-pong DMA transmission. DMA_PingPongDisable(&amp;PingPong, CHANNEL_ID); I2S_Enable(APB_I2S, 0, 0); I2S_DMAEnable(APB_I2S, 0, 0); } "],["efuseselectronic-fuses.html", "5 eFuses(electronic fuses) 5.1 功能概述 5.2 使用说明", " 5 eFuses(electronic fuses) 5.1 功能概述 Efuse是一种片内一次性可编程存储器，可以在断电后保持数据，并且编程后无法被再次修改。 ING916系列提供128bit EFUSE，支持按bit编程或者按Word编程，bit的默认值是0，通过编程可以写成1 5.2 使用说明 5.2.1 模块初始化 void setup_peripherals_efuse_module(void) { // 打开clock，并且reset模块 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_EFUSE)); SYSCTRL_ResetBlock(SYSCTRL_ITEM_APB_EFUSE); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_EFUSE); } 5.2.2 按bit编程 void peripherals_efuse_write_bit(void) { // 提供需要编程的bit位置,0到127之间 EFUSE_UnLock(APB_EFUSE, EFUSE_UNLOCK_FLAG); EFUSE_WriteEfuseDataBitToOne(APB_EFUSE, pos);//pos is bit position from 0 to 127 //写操作完成 //如果要读取，需要reset模块 SYSCTRL_ResetBlock(SYSCTRL_ITEM_APB_EFUSE); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_EFUSE); //设置读取flag EFUSE_SetRdFlag(APB_EFUSE); //等待数据读取标志 while(!EFUSE_GetDataValidFlag(APB_EFUSE)); //读取数据 platform_printf(&quot;word 0: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 0));//bit 0 - 31 platform_printf(&quot;word 1: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 1));//bit 32 - 63 platform_printf(&quot;word 2: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 2));//bit 64 - 95 platform_printf(&quot;word 3: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 3));//bit 96 - 127 } 5.2.3 按word编程 void peripherals_efuse_write_word(void) { // 提供需要编程的word位置,0到3之间,每个word 32bit，一共128bit // EFUSE_PROGRAMWORDCNT_0代表word 0 // data是要写入的32bit数据 EFUSE_WriteEfuseDataWord(APB_EFUSE, EFUSE_PROGRAMWORDCNT_0, data); //写操作完成 //如果要读取，需要reset模块 SYSCTRL_ResetBlock(SYSCTRL_ITEM_APB_EFUSE); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_EFUSE); //设置读取flag EFUSE_SetRdFlag(APB_EFUSE); //等待数据读取标志 while(!EFUSE_GetDataValidFlag(APB_EFUSE)); //读取数据 platform_printf(&quot;word 0: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 0));//bit 0 - 31 platform_printf(&quot;word 1: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 1));//bit 32 - 63 platform_printf(&quot;word 2: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 2));//bit 64 - 95 platform_printf(&quot;word 3: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 3));//bit 96 - 127 } "],["ch-gpio.html", "6 通用输入输出（GPIO） 6.1 功能概述 6.2 使用说明", " 6 通用输入输出（GPIO） 6.1 功能概述 GPIO 模块常用于驱动 LED 或者其它指示器，控制片外设备，感知数字信号输入，检测信号边沿， 或者从低功耗状态唤醒系统。ING916XX 系列芯片内部支持最多 42 个 GPIO，通过 PINCTRL 可将 GPIO \\(n\\) 引出到芯片 IO 管脚 \\(n\\)。 特性： 每个 GPIO 都可单独配置为输入或输出 每个 GPIO 都可作为中断请求，中断触发方式支持边沿触发（上升、下降单沿触发，或者双沿触发） 和电平触发（高电平或低电平） 硬件去抖 在硬件上存在 两个 GPIO 模块，每个模块包含 21 个 GPIO，相应地定义了两个 SYSCTRL_Item： typedef enum { SYSCTRL_ITEM_APB_GPIO0 , SYSCTRL_ITEM_APB_GPIO1 , // ... } SYSCTRL_Item; 注意按照所使用的 GPIO 管脚打开对应的 GPIO 模块。 6.2 使用说明 6.2.1 设置 IO 方向 在使用 GPIO 之前先按需要配置 IO 方向： 需要用于输出信号时：配置为输出 需要用于读取信号时：配置为输入 需要用于生产中断请求时：配置为输入 需要高阻态时：配置为高阻态 使用 GIO_SetDirection 配置 GPIO 的方向。GPIO 支持四种方向： typedef enum { GIO_DIR_INPUT, // 输入 GIO_DIR_OUTPUT, // 输出 GIO_DIR_BOTH, // 同时支持输入、输出 GIO_DIR_NONE // 高阻态 } GIO_Direction_t; 如无必要，不要使用 GIO_DIR_BOTH。 6.2.2 读取输入 使用 GIO_ReadValue 读取某个 GPIO 当前输入的电平信号，例如读取 GPIO 0 的输入： uint8_t value = GIO_ReadValue(GIO_GPIO_0); 使用 GIO_ReadAll 可以同时读取所有 GPIO 当前输入的电平信号。其返回值的第 \\(n\\) 比特 （第 0 比特为最低比特）对应 GPIO \\(n\\) 的输入；如果 GPIO \\(n\\) 当前不支持输入，那么第 \\(n\\) 比特为 0： uint64_t GIO_ReadAll(void); 6.2.3 设置输出 设置单个输出 使用 GIO_WriteValue 设置某个 GPIO 输出的电平信号，例如使 GPIO 0 输出高电平（1）： GIO_WriteValue(GIO_GPIO_0, 1); 同时设置所有输出 通过 GIO_WriteAll 可同时设置所有 GPIO 输出的电平信号： void GIO_WriteAll(const uint64_t value); 将若干输出置为高电平 通过 GIO_SetBits 可同时将若干 GPIO 输出置为高电平： void GIO_SetBits(const uint64_t index_mask); 比如要将 GPIO 0、5 置为高电平，那么 index_mask 为 (1 &lt;&lt; 0) | (1 &lt;&lt; 5)。 将若干输出置为低电平 通过 GIO_ClearBits 可同时将若干 GPIO 输出置为低电平： void GIO_ClearBits(const uint64_t index_mask); index_mask 的使用与 GIO_SetBits 相同。 6.2.4 配置中断请求 使用 GIO_ConfigIntSource 配置 GPIO 生成中断请求。 void GIO_ConfigIntSource( const GIO_Index_t io_index, // GPIO 编号 const uint8_t enable, // 使能的边沿或者电平类型组合 const GIO_IntTriggerType_t type // 触发类型 ); 其中的 enable 为以下两个值的组合（0 表示禁止产生中断请求）： typedef enum { ...LOGIC_LOW_OR_FALLING_EDGE = ..., // 低电平或者下降沿 ...LOGIC_HIGH_OR_RISING_EDGE = ... // 高电平或者上升沿 } GIO_IntTriggerEnable_t; 触发类型有两种： typedef enum { GIO_INT_EDGE, // 边沿触发 GIO_INT_LOGIC // 电平触发 } GIO_IntTriggerType_t; 例如将 GPIO 0 配置为上升沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为双沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE | ..._HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为高电平触发 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_LOGIC); 6.2.5 处理中断状态 用 GIO_GetIntStatus 获取某个 GPIO 上的中断触发状态，返回非 0 值表示该 GPIO 上产生了中断请求；用 GIO_GetAllIntStatus 一次性获取所有 GPIO 的中断触发状态， 第 \\(n\\) 比特（第 0 比特为最低比特）对应 GPIO \\(n\\) 上的中断触发状态。 GPIO 产生中断后，需要消除中断状态方可再次触发。用 GIO_ClearIntStatus 消除某个 GPIO 上中断状态，用 GIO_ClearAllIntStatus 一次性清除所有 GPIO 上可能存在的中断触发状态。 6.2.6 输入去抖 使用 GIO_DebounceCtrl 配置输入去抖参数，每个 GPIO 硬件模块使用单独的参数： void GIO_DebounceCtrl( uint8_t group_mask, // 比特 0 为 1 时配置模块 0 // 比特 1 为 1 时配置模块 1 uint8_t clk_pre_scale, GIO_DbClk_t clk // 防抖时钟选择 ); 所谓去抖就是过滤掉长度小于 (clk_pre_scale + 1) 个防抖时钟周期的“毛刺”。 防抖时钟共有 2 种： typedef enum { GIO_DB_CLK_32K, // 使用 32k 时钟 GIO_DB_CLK_PCLK, // 使用快速 PCLK } GIO_DbClk_t; 快速 PCLK 的具体频率参考 SYSCTRL。 通过 GIO_DebounceEn 为单个 GPIO 使能去抖。例如要在 GPIO 0 上启用硬件去抖，忽略宽度小于 \\(5/32768 \\approx 0.15 (ms)\\) 的“毛刺”： GIO_DebounceCtrl(1, 4, GIO_DB_CLK_32K); GIO_DebounceEn(GIO_GPIO_0, 1); 6.2.7 低功耗保持状态 所有 GPIO 可以在芯片进入低功耗状态后保持状态。根据功能的不同，存在两种类型的 GPIO，表 6.1 列举了所有的 A 型 GPIO，其它 GPIO 为 B 型。 表 6.1: A 型 GPIO GPIO 0 5 6 21 22 23 36 37 对于 A 型 GPIO 使用 GIO_EnableRetentionGroupA 使能或禁用 A 型 GPIO 的低功耗状态保持功能。 使能状态保持功能时，IOMUX 与之相关的所有配置都被锁存，即使处于各种低功耗状态下。使能后， 对这些 GPIO 的配置再做修改无法生效。只有禁用保持功能后，才会生效。 使能后，低功耗状态下这些 GPIO 不掉电。 void GIO_EnableRetentionGroupA(uint8_t enable); 对于 B 型 GPIO 使用 GIO_EnableRetentionGroupB 使能或禁用 B 型 GPIO 的低功耗状态保持功能。 使能状态保持功能时，与之相关的配置（以及输出值 —— 对于 IO 方向为输出的 GPIO）都被锁存，即使处于各种低功耗状态下。 使能后，对这些 GPIO 的配置再做修改无法生效。只有禁用保持功能后，才会生效。 void GIO_EnableRetentionGroupB(uint8_t enable); 使用 GIO_EnableHighZGroupB 使能或禁用 B 型 GPIO 的低功耗高阻功能。使能该功能后， IO 方向为输出的 B 型 GPIO 处于高阻状态，对这些 GPIO 的配置再做修改无法生效。只有禁用保持功能后，才会生效。 void GIO_EnableHighZGroupB(uint8_t enable); 这些功能只支持对所有 GPIO 同时使能或禁用，不能对单个 GPIO 分别控制。 6.2.8 睡眠唤醒源 一部分 GPIO 支持作为低功耗状态的唤醒源：出现指定的电平信号时，将系统从低功耗状态下唤醒。 对于深度睡眠（DEEP Sleep），这些 GPIO （\\(\\{0..17, 21..25, 29..37\\}\\)）可作为唤醒源，其中包含所有的 A 型 GPIO 和部分 B 型 GPIO。 对于更深度的睡眠（DEEPER Sleep），所有的 A 型 GPIO 可作为唤醒源。 深度睡眠唤醒源 使用 GIO_EnableDeepSleepWakeupSource 使能（或停用）某个 GPIO 的唤醒功能。 其中，io_index 应该为支持该功能的 GPIO 的编号；level 为触发电平，1 为高电平唤醒，0 为低电平唤醒； 触发电平与上下拉应该相互配合： 高电平唤醒时，使用下拉；低电平唤醒时，使用上拉。 对于 A 型 GPIO，忽略 pull 参数，其上下拉由 PINCTRL_Pull 控制。 对于 B 型 GPIO，这里的上下拉配置仅用于低功耗状态。对于这种 GPIO， 建议正常状态时的上下拉与这里的配置保持一致，以免由于配置切换产生“毛刺”。 int GIO_EnableDeepSleepWakeupSource( GIO_Index_t io_index, // GPIO 编号 uint8_t enable, // 使能(1)/禁用(0) uint8_t level, // 触发唤醒的电平 pinctrl_pull_mode_t pull // 上下拉配置 ); 任意一个唤醒源检测到唤醒电平就会将系统从低功耗状态唤醒。 更深度睡眠唤醒源 使用 GIO_EnableDeeperSleepWakeupSourceGroupA 使能（或停用）A 型 GPIO 的更深度睡眠唤醒功能。 其中，level 为触发电平，1 为高电平唤醒，0 为低电平唤醒。 使能后，所有 IO 方向为输入的 A 型 GPIO 都将作为唤醒源。任意一个唤醒源检测到唤醒电平就会将系统从低功耗状态唤醒。 void GIO_EnableDeeperSleepWakeupSourceGroupA( uint8_t enable, // 使能(1)/禁用(0) uint8_t level // 触发唤醒的电平 ); "],["i2c功能概述.html", "7 I2C功能概述 7.1 I2C使用说明 7.2 场景1：Master读Slave，不使用DMA 7.3 场景2：Master写Slave，不使用DMA 7.4 场景3：Master读Slave，使用DMA 7.5 场景4：Master写Slave，使用DMA 7.6 场景5：Master写Slave + Master读Slave 7.7 I2C 时钟配置", " 7 I2C功能概述 两个I2C模块 支持Master/Slave模式 支持7bit/10bit地址 支持速率调整 支持DMA 7.1 I2C使用说明 针对916系列，IIC master有两种使用方式可以选择： 方法1：以blocking的方式操作I2C（读写操作完成后API才会返回），针对I2C Master读取外设的场景。 方法2：使用I2C中断操作I2C，需要在中断中操作读写的数据。 IIC Slave 则需要使用方法2，以中断方式操作。 7.1.1 方法1（blocking） 参考：\\ING_SDK\\sdk\\src\\BSP\\iic.c 包含API： /** * @brief Init an I2C peripheral * * @param[in] port I2C peripheral ID */ void i2c_init(const i2c_port_t port); /** * @brief Write data to an I2C slave * * @param[in] port I2C peripheral ID * @param[in] addr address of the slave * @param[in] byte_data data to be written * @param[in] length data length * @return 0 if success else non-0 (e.g. time out) */ int i2c_write(const i2c_port_t port, uint8_t addr, const uint8_t *byte_data, int16_t length); /** * @brief Read data from an I2C slave * * @param[in] port I2C peripheral ID * @param[in] addr address of the slave * @param[in] write_data data to be written before reading * @param[in] write_len data length to be written before reading * @param[in] byte_data data to be read * @param[in] length data length to be read * @return 0 if success else non-0 (e.g. time out) */ int i2c_read(const i2c_port_t port, uint8_t addr, const uint8_t *write_data, int16_t write_len, uint8_t *byte_data, int16_t length); 使用方法： 初始化IIC模块 setup_peripherals_i2c_pin(); i2c_init(I2C_PORT_0); setup_peripherals_i2c_pin()的使用请参考该文档中配置pin的描述(不需要配置IIC中断)。 写数据 i2c_write(I2C_PORT_0, ADDRESS, write_data, DATA_CNT); 当读操作完成后API才会返回，为了避免长时间等待ACK等意外情况，使用I2C_HW_TIME_OUT来控制blocking的时间。 读数据 i2c_read(I2C_PORT_0, ADDRESS, write_data, DATA_CNT, read_data, DATA_CNT); 如果write_data不为空，则会首先执行写操作，然后再执行读操作。 7.1.2 方法2（Interrupt） IIC slave 以及 IIC Master方法2的使用请参考场景5。 以下场景中均以I2C0为例，如果需要I2C1则可以根据情况修改 7.2 场景1：Master读Slave，不使用DMA 其中I2C配置为Master读操作，Slave收到地址后，将数据返回给Master，CPU操作读写，没有使用DMA。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 7.2.1 I2C Master配置 // 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (10) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 7.2.1.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(I2C_SCL,PINCTRL_PULL_UP); PINCTRL_Pull(I2C_SDA,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); PINCTRL_SetPadMux(I2C_SCL,IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(I2C_SDA,IO_SOURCE_I2C0_SDA_OUT); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.2.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和fifo满中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_FULL)); } 7.2.1.3 I2C中断实现 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); // FIFO 满之后，触发中断，此时需要将所有数据都读出来 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){break;} read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } } //传输结束后，触发中断，读取完剩下的数据 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 7.2.1.4 I2C master触发传输 void peripheral_i2c_send_data(void) { // 设置方向，Master读取 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_SLAVE2MASTER); // 设置每次传输的大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 7.2.1.5 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 在需要时候触发I2C读取，peripheral_i2c_send_data() 检查中断状态 7.2.2 I2C Slave配置 // 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (10) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 7.2.2.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(I2C_SCL,PINCTRL_PULL_UP); PINCTRL_Pull(I2C_SDA,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); PINCTRL_SetPadMux(I2C_SCL,IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(I2C_SDA,IO_SOURCE_I2C0_SDA_OUT); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.2.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 7.2.2.3 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave 收到匹配的地址，触发中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { // 判断是读操作还是写操作 dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 如果是读操作，则会触发empty中断，此时需要填写需要发送的数据，直到FIFO满 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){break;} I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } } // 传输结束，清理打开的中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 7.2.2.4 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 检查中断状态，在中断中发送数据，I2C_STATUS_CMPL中断代表传输结束 7.3 场景2：Master写Slave，不使用DMA 其中I2C配置为Master写操作，Slave收到地址后，将从Master读取数据，CPU操作读写，没有使用DMA。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 7.3.1 I2C Master配置 // 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (10) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 7.3.1.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(I2C_SCL,PINCTRL_PULL_UP); PINCTRL_Pull(I2C_SDA,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); PINCTRL_SetPadMux(I2C_SCL,IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(I2C_SDA,IO_SOURCE_I2C0_SDA_OUT); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.3.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和fifo空中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } 7.3.1.3 I2C中断实现 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); // 传输结束，触发中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } // empty FIFO 中断，填写需要发送的数据，数据全部发送之后，关掉I2C_INT_FIFO_EMPTY if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){break;} I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } // if its the last, disable empty int if(write_data_cnt == DATA_CNT) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 7.3.1.4 I2C master触发传输 void peripheral_i2c_send_data(void) { // 设置方向，Master写 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_MASTER2SLAVE); // 设置每次传输的大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 7.3.1.5 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 在需要时候发送I2C数据，peripheral_i2c_send_data() 检查中断状态 7.3.2 I2C Slave配置 // 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (10) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 7.3.2.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(I2C_SCL,PINCTRL_PULL_UP); PINCTRL_Pull(I2C_SDA,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); PINCTRL_SetPadMux(I2C_SCL,IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(I2C_SDA,IO_SOURCE_I2C0_SDA_OUT); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.3.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 7.3.2.3 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave 收到匹配的地址，触发中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { // 判断是读操作还是写操作 dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 等待FIFO FULL，读取FIFO直到FIFO变空 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){break;} read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } } // 传输结束，读取FIFO中剩余的数据，清除相关中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { for(;read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 7.3.2.4 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 检查中断状态，I2C_STATUS_CMPL中断代表传输结束 7.4 场景3：Master读Slave，使用DMA 其中I2C配置为Master读操作，Slave收到地址后，将数据返回给Master，DMA操作读写。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 7.4.1 I2C Master配置 // 测试数据，每次传输23个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (23) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 7.4.1.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(I2C_SCL,PINCTRL_PULL_UP); PINCTRL_Pull(I2C_SDA,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); PINCTRL_SetPadMux(I2C_SCL,IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(I2C_SDA,IO_SOURCE_I2C0_SDA_OUT); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.4.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)); } 7.4.1.3 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 7.4.1.4 I2C中断实现 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 7.4.1.5 I2C master DMA设置 // 注意此处是I2C0 void peripherals_i2c_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_I2C0,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 7.4.1.6 I2C master触发传输 void peripheral_i2c_send_data(void) { // I2C DMA 功能打开 I2C_DmaEnable(APB_I2C0,1); // 设置传输方向，Master读 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_SLAVE2MASTER); // 设置需要传输的数据大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 配置DMA #define I2C_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_i2c_rxfifo_to_dma(I2C_DMA_RX_CHANNEL, read_data, sizeof(read_data)); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 7.4.1.7 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候触发I2C读取，peripheral_i2c_send_data() 检查中断状态 7.4.2 I2C Slave配置 // 测试数据，每次传输23个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (23) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 7.4.2.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(I2C_SCL,PINCTRL_PULL_UP); PINCTRL_Pull(I2C_SDA,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); PINCTRL_SetPadMux(I2C_SCL,IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(I2C_SDA,IO_SOURCE_I2C0_SDA_OUT); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.4.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 7.4.2.3 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 7.4.2.4 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave收到了匹配的地址，触发中断，判断方向 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { // 设置DMA，发送数据 peripherals_i2c_write_data_dma_setup(); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 传输结束，关闭DMA if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_DmaEnable(APB_I2C0,0); I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 7.4.2.5 I2C Slave 发送数据DMA设置 // 此处配置的是I2C0 void peripherals_i2c_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_I2C0,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_i2c_write_data_dma_setup(void) { // 设置DMA #define I2C_DMA_TX_CHANNEL (0)//DMA channel 0 peripherals_i2c_dma_to_txfifo(I2C_DMA_TX_CHANNEL, write_data, sizeof(write_data)); // 更新需要传输的数据 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 打开I2C DMA I2C_DmaEnable(APB_I2C0,1); } 7.4.2.6 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 初始化DMA，setup_peripherals_dma_module() 检查中断状态，在中断中设置DMA发送数据，I2C_STATUS_CMPL中断代表传输结束 7.5 场景4：Master写Slave，使用DMA 其中I2C配置为Master写操作，Slave收到地址后，读取Master发送的数据，DMA操作读写。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 7.5.1 I2C Master配置 // 测试数据，每次传输23个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (23) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 7.5.1.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(I2C_SCL,PINCTRL_PULL_UP); PINCTRL_Pull(I2C_SDA,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); PINCTRL_SetPadMux(I2C_SCL,IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(I2C_SDA,IO_SOURCE_I2C0_SDA_OUT); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.5.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)); } 7.5.1.3 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 7.5.1.4 I2C中断实现 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 7.5.1.5 I2C master DMA设置 // 注意此处是I2C0 void peripherals_i2c_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_I2C0,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 7.5.1.6 I2C master触发传输 void peripheral_i2c_send_data(void) { // I2C DMA 功能打开 I2C_DmaEnable(APB_I2C0,1); // 设置传输方向，Master读 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_MASTER2SLAVE); // 设置需要传输的数据大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 配置DMA #define I2C_DMA_TX_CHANNEL (0)//DMA channel 0 peripherals_i2c_dma_to_txfifo(I2C_DMA_TX_CHANNEL, write_data, sizeof(write_data)); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 7.5.1.7 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候触发I2C读取，peripheral_i2c_send_data() 检查中断状态 7.5.2 I2C Slave配置 // 测试数据，每次传输23个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (23) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 7.5.2.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(I2C_SCL,PINCTRL_PULL_UP); PINCTRL_Pull(I2C_SDA,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); PINCTRL_SetPadMux(I2C_SCL,IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(I2C_SDA,IO_SOURCE_I2C0_SDA_OUT); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 7.5.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 7.5.2.3 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 7.5.2.4 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave收到了匹配的地址，检查传输方向 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { // 设置DMA读取数据 peripherals_i2c_read_data_dma_setup(); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 传输结束，关闭DMA if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_DmaEnable(APB_I2C0,0); I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 7.5.2.5 I2C Slave 发送数据DMA设置 // 此处配置的是I2C0 void peripherals_i2c_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_I2C0,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_i2c_read_data_dma_setup(void) { // 设置DMA #define I2C_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_i2c_rxfifo_to_dma(I2C_DMA_RX_CHANNEL, read_data, sizeof(read_data)); // 更新需要传输的数据 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 打开I2C DMA I2C_DmaEnable(APB_I2C0,1); } 7.5.2.6 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 初始化DMA，setup_peripherals_dma_module() 检查中断状态，在中断中设置DMA读取数据，I2C_STATUS_CMPL中断代表传输结束 7.6 场景5：Master写Slave + Master读Slave 其中I2C操作为，首先执行写操作然后再执行读操作，CPU操作读写，没有使用DMA。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 7.6.1 I2C Master配置 // 测试数据，每次传输8个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (8) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 7.6.1.1 配置Pin IO的配置请参考场景1。 7.6.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和addr hit中断 // 对于master来说，如果有slave响应了地址，则会有I2C_INT_ADDR_HIT中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1&lt;&lt;I2C_INT_ADDR_HIT)); } 7.6.1.3 I2C中断实现 首先定义一个变量，如果为1，代表是master的写操作，否则为master的读操作。 uint8_t master_write_flag = 0; static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); // 传输结束中断，代表DATA_CNT个字节接收或者发射完成 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { // master写DATA_CNT个字节成功 if(master_write_flag) { platform_printf(&quot;wr cmp %d\\n&quot;, I2C_CtrlGetDataCnt(APB_I2C0)); I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } else// master读DATA_CNT个字节成功 { // 将剩余的fifo中的数据读出来 for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // debug trace platform_printf(&quot;rd cmp %d &quot;,read_data_cnt); for(i=0;i&lt;DATA_CNT;i++){platform_printf(&quot; 0x%x -&quot;, read_data[i]);}; printf(&quot;\\n&quot;); // prepare for next read_data_cnt = 0; } } // 有slave响应了master的地址 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { // 打开相应中断，主要是用来填写或者读取fifo if(master_write_flag) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } else { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_FULL)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); platform_printf(&quot;addr hit\\n&quot;); } // 该中断在master_write_flag==1打开，代表fifo为空，需要填充待发送的数据 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { if(master_write_flag) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { //platform_printf(&quot;ept: %d \\n&quot;,write_data_cnt); if(I2C_FifoFull(APB_I2C0)){break;} I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } // if its the last, disable empty int if(write_data_cnt == DATA_CNT) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } } // 该中断在master_write_flag==0打开，FIFO 满之后，触发中断，此时需要将所有数据都读出来 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { if(!master_write_flag) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){break;} read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } platform_printf(&quot;rd full %d \\n&quot;, read_data_cnt); } } return 0; } 7.6.1.4 I2C master写传输 void peripheral_i2c_write_data(void) { master_write_flag = 1; // 设置方向，Master写 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_MASTER2SLAVE); // 设置每次传输的大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 7.6.1.5 I2C master读传输 void peripheral_i2c_read_data(void) { master_write_flag = 0; I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_SLAVE2MASTER); I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 7.6.1.6 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 在需要时候触发I2C写数据，peripheral_i2c_write_data()，I2C_STATUS_CMPL代表结束 当写结束后，可以触发I2C读取，peripheral_i2c_read_data()，I2C_STATUS_CMPL代表结束 检查中断状态 7.6.2 I2C Slave配置 7.6.2.1 配置Pin IO的配置请参考场景1。 7.6.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 7.6.2.3 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave 收到匹配的地址，触发中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { // 判断是读操作还是写操作 dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { master_write_flag = 1; I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); platform_printf(&quot;addr wr 0x%x\\n&quot;, APB_I2C0-&gt;IntEn); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { master_write_flag = 0; I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); //示例： slave 此时应将要发送的数据准备好 write_data_cnt = 0; memset(write_data, 0x44, sizeof(write_data)); platform_printf(&quot;addr rd \\n&quot;); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 如果是读操作，则会触发empty中断，此时需要填写需要发送的数据，直到FIFO满 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { // master read if(!master_write_flag) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){break;} I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } platform_printf(&quot;rd empty %d \\n&quot;, write_data_cnt); } } // 如果是写操作，FIFO满之后会触发该中断，slave应读取fifo数据 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { // master write if(master_write_flag) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){break;} read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } platform_printf(&quot;wr full %d \\n&quot;, read_data_cnt); } } // 传输结束，清理打开的中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { // master write， 此时应读取fifo中剩余的数据 if(master_write_flag) { for(;read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } // debug trace platform_printf(&quot;wr cmp %d &quot;,read_data_cnt); for(i=0;i&lt;DATA_CNT;i++){platform_printf(&quot; 0x%x -&quot;, read_data[i]);}; printf(&quot;\\n&quot;); read_data_cnt = 0; } else//master写操作，清理中断 { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } write_data_cnt = 0; platform_printf(&quot;rd cmp \\n &quot;); } } return 0; } 7.6.2.4 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 检查中断状态，在中断中发送数据，I2C_STATUS_CMPL中断代表传输结束 如果是读操作，slave应该在master_write_flag=0之后准备好数据写到fifo 7.7 I2C 时钟配置 I2C时钟配置使用API： /** * @brief Set clk frequency for controller. * @param[in] I2C_BASE base address * @param[in] option see I2C_ClockFrequenyOptions */ void I2C_ConfigClkFrequency(I2C_TypeDef *I2C_BASE, I2C_ClockFrequenyOptions option); 其中option中定义了几个可选项 typedef enum { I2C_CLOCKFREQUENY_NULL, I2C_CLOCKFREQUENY_STANDARD,//up to 100kbit/s I2C_CLOCKFREQUENY_FASTMODE,//up to 400kbit/s I2C_CLOCKFREQUENY_FASTMODE_PLUS,//up to 1Mbit/s I2C_CLOCKFREQUENY_MANUAL } I2C_ClockFrequenyOptions; 如果选择MANUAL,需要手动配置相关寄存器来生成需要的时钟 I2C_BASE-&gt;TPM : multiply factor, width 5bit, 所有setup中的时间参数都会被乘以（TPM+1） I2C_BASE-&gt;Setup: 使用I2C_ConfigSCLTiming()配置该寄存器 scl_hi：高电平持续时间，width 9bit，default 0x10 scl_ratio: 低电平持续时间因子，width 1bit，default 1 hddat：SCL拉低后SDA的保持时间，width 5bit，default 5 sp: 可以被过滤的脉冲毛刺宽度，width 3bit，default 1 sudat: 释放SCL之前的数据建立时间，width 5bit，default 5 高电平持续时间计算： SCL high period = (2 * pclk) + (2 + sp + scl_hi) * pclk * (TPM + 1) 其中pclk为I2C模块的系统时钟，默认为24M 如果sp = 1, pclk = 42ns, TPM = 3, scl_hi = 150 : SCL high period = (2 * 42) + (2 + 1 + 150) * 42 * (3 + 1) = 25788ns 低电平持续时间计算： SCL low period = (2 * pclk) + (2 + sp + scl_hi * (scl_ratio+1)) * pclk * (TPM + 1) 如果sp = 1, pclk = 42ns, TPM = 3, scl_hi = 150, scl_ratio = 0 : SCL low period = (2 * 42) + (2 + 1 + 150 * 1) * 42 * (3 + 1) = 25788ns 毛刺抑制宽度： spike suppression width = sp * pclk * (TPM + 1) 如果sp = 1, pclk = 42ns, TPM = 3: spike suppression width = 1 * 42 * (3 + 1) = 168ns SCL之前的数据建立时间：setup time = (2 * pclk) + (2 + sp + sudat) * pclk * (TPM + 1) 如果sp = 1, pclk = 42ns, TPM = 3, sudat = 5: setup time = (2 * 42) + (2 + 1 + 5) * 42 * (3 + 1) = 1428ns 协议对SCL之前的数据建立时间要求为： standard mode: 最小250ns - fast mode: 最小100ns - fast mode plus: 最小50ns SCL拉低后SDA的保持时间 hold time = (2 * pclk) + (2 + sp + hddat) * pclk * (TPM + 1) 如果sp = 1, pclk = 42ns, TPM = 3, hddat = 5: hold time = (2 * 42) + (2 + 1 + 5) * 42 * (3 + 1) = 1428ns 协议对SCL拉低后SDA的保持时间要求为： standard mode: 最小300ns - fast mode: 最小300ns - fast mode plus: 最小0ns "],["ch-I2s.html", "8 I2s简介 8.1 功能描述 8.2 使用方法 8.3 编程指南", " 8 I2s简介 I2S（inter-IC sound）总线是数字音频专用总线。它有四个引脚，两个数据引脚(DOUT和DIN)，一个位率时钟引脚(BCLK)和一个左右通道选择引脚(LRCLK)。 另外，通过ING91682A的MCLK输出，它可用于给外部 DAC/ADC 芯片提供时钟（可选）。 8.1 功能描述 8.1.1 特点 遵从 I2S 协议标准，支持12S标准模式和左对齐模式 支持PCM(脉冲编码调制)时序 可编程的主从模式 可配置的LRCLK和BCLK极性 可配置数据位宽 独立发送和接收FIFO TX和RX的FIFO深度分别为16*32bit 支持立体声和单声道模式 可配置的采样频率 TX和RX分别支持DMA搬运 8.1.2 I2s角色 在 I2S 总线上，提供时钟和通道选择信号的器件是 MASTER，另一方则为 SLAVER。 MASTER和SLAVE都可以进行数据收发。 8.1.3 I2s工作模式 I2S 有两种工作模式：一种是立体声音频模式，另外一种是话音模式。 8.1.4 串行数据 串行数据是以高位（MSB）在前，低位（LSB）在后的方式进行传送的。 如果音频codec发送的位数多于I2S控制器的接收位数，I2S控制器会将低位多余的位数忽略掉； 如果音频codec发送的位数小于I2S控制器接收位数，I2S控制器将后面的位补零。 8.1.5 时钟分频 916芯片可选用系统24MHz时钟或者PLL作为I2s时钟源。 位率时钟（BCLK）可以通过对功能时钟进行分频得到； 通道选择时钟（LRCLK）即音频数据的采样频率可以通过对BCLK进行分频得到。 音频 Codec 中对采样频率 LRCLK 要求精度比较高，我们在计算分频时应该首先根据不同的采样频率计算得到对应的 MCLK 和 BCLK。 8.1.5.1 时钟分频计算 计算示例： 假设当前codec采用16K采样频率，mic要求一帧64位（参考具体的mic使用手册）。 有以下关系： f_bclk = clk/(2*b_div) f_lrclk = f_bclk/(2*lr_div) 其中clk为codec时钟，f_bclk、f_lrclk分别为BCLK和LRCLK，b_div、lr_div分别为BCLK和LRCLK的分频系数。 BCLK和LRCLK之间的关系是可变的，但是BCLK必须大于等于LRCLK的48倍。即lr_div&gt;=24。 支持lr_div = 32，DATA_LEN = 32位的配置，其他情况下lr_div - DATA_LEN &gt; 3。 通过f_lrclk = 16000，lr_div = 32计算出f_bclk = 1.024MHz。也就是clk = 2.048*b_div。 clk通过时钟源分频得到必定是整数，b_div也同样是整数，通过计算得知在384MHz内只有当b_div = 125时clk = 256MHz为整数。 故需要将PLL时钟配置为256MHz，b_div = 125可以得到16K采样率。 8.1.6 i2s存储器 采用两个深度为16，宽度为32bit的FIFO分别存储接收、发送的音频数据。 有如下规则： 音频数据位宽为16bit时，每32bit存储两个音频数据，高16bit存储左声道数据，低16bit存储右声道数据。 音频数据位宽大于16bit时，每32bit存储一个音频数据，低地址存储左声道数据，高地址存储右声道数据。 8.2 使用方法 8.2.1 方法概述 I2s使用方法总结为：时钟配置，I2s配置（包括采样率）和数据处理。 数据发送： 1. I2s引脚GPIO配置 2. 配置外部 codec 芯片，使其处于工作模式 3. 写相应配置寄存器 4. 将数据写入TX_MEM 5. 使能I2s 6. 等待中断产生 7. 读取状态寄存器，将数据写入TX_MEM 8. 传输完毕，关闭 I2S 数据接收： 1. I2s引脚GPIO配置 2. 配置外部 codec 芯片，使其处于工作模式 3. 写相应配置寄存器 4. 使能I2s 5. 等待中断产生 6. 读取状态寄存器，读取 RX_MEM 中数据 7. 传输完毕，关闭 I2S I2S控制器操作流程图如下： 图 8.1: I2S控制器操作流程图 如果需要用到DMA搬运则需要在使能I2s之前配置DMA并使能。 8.2.2 注意点 I2s时钟源可以选择晶振24M时钟和PLL时钟，要注意是选择哪一个时钟源 I2s数据可能会进行采样，需要注意具体的数据结构以及对应的数据处理，如是否需要数据移位等 当前I2s支持的发送/接收数据位宽为16-32bit，需要查阅mic文档或其他使用手册来确定数据位宽，否则不能正常工作 配置DMA要在使能I2s之前完成，使能I2s一定是最后一步 建议采用DMA乒乓搬运的方式来传输I2s数据 8.3 编程指南 8.3.1 驱动接口 I2S_ConfigClk：I2s时钟配置接口 I2S_Config：I2s配置接口 I2S_ConfigIRQ：I2s中断配置接口 I2S_DMAEnable：I2s DMA使能接口 I2S_Enable：I2s使能接口 I2S_PopRxFIFO、I2S_PushTxFIFO：I2s FIFO读写接口 I2S_ClearRxFIFO、I2S_ClearTxFIFO：I2s清FIFO接口 I2S_GetIntState、I2S_ClearIntState：I2s获取中断、清中断接口 I2S_GetRxFIFOCount、I2S_GetTxFIFOCount：I2s获取FIFO数据数量接口 I2S_DataFromPDM：I2s获取PDM数据接口 8.3.2 代码示例 下面将通过实际代码展示I2s的基本配置及使用代码。 8.3.2.1 I2s配置 #define I2S_PIN_BCLK 21 #define I2S_PIN_IN 22 #define I2S_PIN_LRCLK 35 void I2sSetup(void) { // pinctrl &amp; GPIO mux PINCTRL_SetPadMux(I2S_PIN_BCLK, IO_SOURCE_I2S_BCLK_OUT); PINCTRL_SetPadMux(I2S_PIN_IN, IO_SOURCE_I2S_DATA_IN); PINCTRL_SelI2sIn(IO_NOT_A_PIN, IO_NOT_A_PIN, I2S_PIN_IN); PINCTRL_SetPadMux(I2S_PIN_LRCLK, IO_SOURCE_I2S_LRCLK_OUT); PINCTRL_Pull(IO_SOURCE_I2S_DATA_IN, PINCTRL_PULL_DOWN); // CLK &amp; Register SYSCTRL_ConfigPLLClk(6, 128, 2); // sorce clk PLL = 256MHz SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_1 + 4); // I2s_Clk = 51.2MHz I2S_ConfigClk(APB_I2S, 25, 32); // F_bclk = 1.024MHz, F_lrclk = 16K I2S_ConfigIRQ(APB_I2S, 0, 1, 0, 10); I2S_DMAEnable(APB_I2S, 0, 0); I2S_Config(APB_I2S, I2S_ROLE_MASTER, I2S_MODE_STANDARD, 0, 0, 0, 1, 24); // I2s interrupt platform_set_irq_callback(PLATFORM_CB_IRQ_I2S, cb_isr, 0); } 8.3.2.2 I2s使能 I2s使能分3种情况：I2s发送、I2s接收、使用DMA搬运 接收： void I2sStart(void) { I2S_ClearRxFIFO(APB_I2S); I2S_Enable(APB_I2S, 0, 1); } 发送： uint8_t sendSize = 10; uint32_t sendData[10]; void I2sStart(void) { int i; I2S_ClearTxFIFO(APB_I2S); // push data into TX_FIFO first for (i = 0; i &lt; sendSize; i++) { I2S_PushTxFIFO(APB_I2S, sendData[i]); } I2S_Enable(APB_I2S, 0, 1); } 使用DMA（接收）： #define CHANNEL_ID 0 DMA_Descriptor test __attribute__((aligned (8))); void I2sStart(uint32_t data) { DMA_EnableChannel(CHANNEL_ID, &amp;test); I2S_ClearRxFIFO(APB_I2S); I2S_DMAEnable(APB_I2S, 1, 1); I2S_Enable(APB_I2S, 0, 1); } 无论哪种情况都必须最后一步使能I2s，否则I2s工作异常。 8.3.2.3 I2s中断 接收： uint32_t cb_isr(void *user_data) { uint32_t state = I2S_GetIntState(APB_I2S); I2S_ClearIntState(APB_I2S, state); int i = I2S_GetRxFIFOCount(APB_I2S); while (i) { uint32_t data = I2S_PopRxFIFO(APB_I2S); i--; // do something with data } return 0; } 发送： uint8_t sendSize = 10; uint32_t sendData[10]; uint32_t cb_isr(void *user_data) { uint32_t state = I2S_GetIntState(APB_I2S); I2S_ClearIntState(APB_I2S, state); int i; for (i = 0; i &lt; sendSize; i++) { I2S_PushTxFIFO(APB_I2S, sendData[i]); } return 0; } 8.3.2.4 I2s &amp; DMA乒乓搬运 下面以经典的DMA乒乓搬运I2s接收数据为例展示I2s实际使用方法。 这里我们采用16K采样率，单个数据帧固定64位，和DMA协商握手、burstSize=8、一次搬运80个数据。 #include &quot;pingpong.h&quot; #define I2S_PIN_BCLK 21 #define I2S_PIN_IN 22 #define I2S_PIN_LRCLK 35 #define CHANNEL_ID 0 DMA_PingPong_t PingPong; static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); uint32_t *rr = DMA_PingPongIntProc(&amp;PingPong, CHANNEL_ID); uint32_t i = 0; uint32_t transSize = DMA_PingPongGetTransSize(&amp;PingPong); while (i &lt; transSize) { // do something with data &#39;rr[i]&#39; i++; } return 0; } void I2sSetup(void) { // pinctrl &amp; GPIO mux PINCTRL_SetPadMux(I2S_PIN_BCLK, IO_SOURCE_I2S_BCLK_OUT); PINCTRL_SetPadMux(I2S_PIN_IN, IO_SOURCE_I2S_DATA_IN); PINCTRL_SelI2sIn(IO_NOT_A_PIN, IO_NOT_A_PIN, I2S_PIN_IN); PINCTRL_SetPadMux(I2S_PIN_LRCLK, IO_SOURCE_I2S_LRCLK_OUT); PINCTRL_Pull(IO_SOURCE_I2S_DATA_IN, PINCTRL_PULL_DOWN); // CLK &amp; Register SYSCTRL_ConfigPLLClk(6, 128, 2); // sorce clk PLL = 256MHz SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_1 + 4); // I2s_Clk = 51.2MHz I2S_ConfigClk(APB_I2S, 25, 32); // F_bclk = 1.024MHz, F_lrclk = 16K I2S_ConfigIRQ(APB_I2S, 0, 1, 0, 8); I2S_DMAEnable(APB_I2S, 0, 0); I2S_Config(APB_I2S, I2S_ROLE_MASTER, I2S_MODE_STANDARD, 0, 0, 0, 1, 24); // setup DMA DMA_PingPongSetup(&amp;PingPong, SYSCTRL_DMA_I2S_RX, 100, 8); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); // start working DMA_PingPongEnable(&amp;PingPong, CHANNEL_ID); I2S_ClearRxFIFO(APB_I2S); I2S_DMAEnable(APB_I2S, 1, 1); I2S_Enable(APB_I2S, 0, 1); } DMA（乒乓搬运）的具体用法请参见本手册DMA一节。 更加系统化的I2s代码请参考SDK中voice_remote_ctrl例程。 "],["ir-红外.html", "9 IR 红外 9.1 功能概述 9.2 使用说明", " 9 IR 红外 9.1 功能概述 支持红外发射&amp;接收 时序可调整，支持多种编码 9.2 使用说明 9.2.1 参数(不同编码的时间参数) //32KHz 调制时钟 #define FCLK 32000 //NEC 载波频率38KHz #define NEC_WAVE_FREQ 38000 // RC5 载波频率36KHz #define RC5_WAVE_FREQ 36000 // 计算载波频率发生器数据，由此产生如38KHz NEC的载波，NEC与TC9012通用38KHz载波 #define IR_WAVE_NEC_TC9012_FREQ (OSC_CLK_FREQ/NEC_WAVE_FREQ) #define IR_WAVE_RC5_FREQ (OSC_CLK_FREQ/RC5_WAVE_FREQ) //通过FCLK产生各种协议每bit位调制周期最小单位，如NEC协议中，560us为最小调制周期，NEC：bit 0：560us载波+560us不载波，bit 1：560 us载波+560*3 us不载波 #define NEC_UINT (FCLK*560/1000000+1) #define TC9012_UINT (FCLK*260/1000000+1) #define RC5_UINT (FCLK*889/1000000+1) //不必要的参数 #define INESSENTIAL 0 typedef struct { uint16_t timer1;//发送模式下，表示引导码低电平时间：如NEC为16*UNIT = 9ms，接收模式下与timer2组成检测引导码低电平窗口 uint16_t timer2;//发送模式下，表示重复码低电平时间：如NEC为4*UNIT = 2.25ms，接收模式下与timer1组成检测引导码低窗口 uint16_t timer3;//发送模式下，表示引导码高电平时间：如NEC为8*UNIT = 4.5ms，接收模式下与timer4组成检测引导码高电平+低电平窗口 uint16_t timer4;//发送模式下，表示重复码高电平时间：如NEC为UNIT = 560us，接收模式下与timer3组成检测引导码高电平+低电平窗口 uint16_t timer5;//接收时接收超时定时器，发射不必关注 uint16_t btimer1;//逻辑 0 的bit时长：如NEC = 2*UINT = 1.12ms. uint16_t btimer2;//逻辑 1 的bit时长：如NEC = 4*UINT = 2.25ms. uint16_t bit_cycle;//发射模式下：bit调制周期最小单位，如NEC为560us，接收模式下为bit检测超时时间 uint16_t carry_low;//载波低电平时长，与carry_high组合形成占空比可调的载波波形，如NEC为38KHz 30%占空比载波则carry_low = 2/3*载波周期，carry_high = 1/3*载波周期 uint16_t carry_high;//载波高电平时长，与carry_low组合形成占空比可调的载波波形，如NEC为38KHz 30%占空比载波则carry_low = 2/3*载波周期，carry_high = 1/3*载波周期 }Ir_mode_param_t; //由于发送和接收初始化不同参数 定义结构体表示接收发送初始化参数。 typedef struct{ Ir_mode_param_t param_tx; Ir_mode_param_t param_rx; }Ir_type_param_t; //定义初始化数据，初始化函数体根据不同协议自动从此表适配参数 const static Ir_type_param_t t_ir_type_param_table[] = { {//NEC param { //TX 16*NEC_UINT-1,4*NEC_UINT-1,8*NEC_UINT-1,1*NEC_UINT-1,INESSENTIAL, 2*NEC_UINT-1, 4*NEC_UINT-1,1*NEC_UINT-1,IR_WAVE_NEC_TC9012_FREQ*2/3,IR_WAVE_NEC_TC9012_FREQ*1/3}, { //RX 14*NEC_UINT-1,18*NEC_UINT-1,22*NEC_UINT-1,26*NEC_UINT-1,0xfff, INESSENTIAL,2*NEC_UINT-1,0x7f,INESSENTIAL,INESSENTIAL}, }, {//TC9012 param { //TX 16*TC9012_UINT-1,8*TC9012_UINT-1,16*TC9012_UINT-1,2*TC9012_UINT-1,INESSENTIAL, 4*TC9012_UINT-1,6*TC9012_UINT-1,2*TC9012_UINT-1,IR_WAVE_NEC_TC9012_FREQ*2/3,IR_WAVE_NEC_TC9012_FREQ*1/3}, { //RX 28*TC9012_UINT-1,36*TC9012_UINT-1,44*TC9012_UINT-1,32*TC9012_UINT-1,0xfff,INESSENTIAL, 4*TC9012_UINT-1,0x7f,INESSENTIAL,INESSENTIAL}, }, {//RC5 param { //TX 2*RC5_UINT-1,2*RC5_UINT-1,INESSENTIAL,INESSENTIAL,INESSENTIAL,2*RC5_UINT-1, INESSENTIAL,1*RC5_UINT,IR_WAVE_RC5_FREQ*2/3,IR_WAVE_RC5_FREQ*1/3}, { //RX 1*RC5_UINT-2,1*RC5_UINT,3*RC5_UINT-1,5*RC5_UINT-1,INESSENTIAL,1*RC5_UINT-3, 1*RC5_UINT-1,2*RC5_UINT-1,INESSENTIAL,INESSENTIAL}, } }; 9.2.2 红外发射接收 9.2.2.1 配置pin #define IR_DOUT GIO_GPIO_10 #define IR_DIN GIO_GPIO_11 void setup_peripherals_ir_module(void) { // 打开时钟 // 大于等于GPIO 18则使用SYSCTRL_ClkGate_APB_GPIO1， 否则是SYSCTRL_ClkGate_APB_GPIO0 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ClkGate_APB_GPIO0) | (1 &lt;&lt; SYSCTRL_ClkGate_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ClkGate_APB_IR) | (1 &lt;&lt; SYSCTRL_ClkGate_APB_PinCtrl)); PINCTRL_SelIrIn(IR_DIN); PINCTRL_SetPadMux(IR_DOUT,IO_SOURCE_IR_DATA_OUT); platform_set_irq_callback(PLATFORM_CB_IRQ_IR_INT, IRQHandler_IR_INT, NULL); } 9.2.2.2 配置模块 static void user_ir_device_init(IR_IrMode_e mode,IR_TxRxMode_e tx_rx_mode) { IR_CtrlSetIrMode(APB_IR,mode); IR_CtrlSetTxRxMode(APB_IR,tx_rx_mode); IR_CtrlSetIrIntEn(APB_IR); if(IR_TXRX_MODE_TX_MODE == tx_rx_mode) { IR_TxConfigIrTxPol(APB_IR); IR_TxConfigCarrierCntClr(APB_IR); IR_TxConfigIrIntEn(APB_IR); IR_CarryConfigSetIrCarryLow(APB_IR,t_ir_type_param_table[mode].param_tx.carry_low); //30% pwm IR_CarryConfigSetIrCarryHigh(APB_IR,t_ir_type_param_table[mode].param_tx.carry_high); IR_TimeSetIrTime1(APB_IR,t_ir_type_param_table[mode].param_tx.timer1); IR_TimeSetIrTime2(APB_IR,t_ir_type_param_table[mode].param_tx.timer2); IR_TimeSetIrTime3(APB_IR,t_ir_type_param_table[mode].param_tx.timer3 ); IR_TimeSetIrTime4(APB_IR,t_ir_type_param_table[mode].param_tx.timer4); IR_CtrlIrSetBitTime1(APB_IR,t_ir_type_param_table[mode].param_tx.btimer1); IR_CtrlIrSetBitTime2(APB_IR,t_ir_type_param_table[mode].param_tx.btimer2); IR_CtrlIrSetIrBitCycle(APB_IR,t_ir_type_param_table[mode].param_tx.bit_cycle); } else{ IR_CtrlSetIrEndDetectEn(APB_IR);//end code detect en IR_CtrlIrUsercodeVerify(APB_IR); IR_CtrlIrDatacodeVerify(APB_IR); IR_TimeSetIrTime1(APB_IR,t_ir_type_param_table[mode].param_rx.timer1); IR_TimeSetIrTime2(APB_IR,t_ir_type_param_table[mode].param_rx.timer2); IR_TimeSetIrTime3(APB_IR,t_ir_type_param_table[mode].param_rx.timer3); IR_TimeSetIrTime4(APB_IR,t_ir_type_param_table[mode].param_rx.timer4); IR_TimeSetIrTime5(APB_IR,t_ir_type_param_table[mode].param_rx.timer5); IR_CtrlIrSetBitTime1(APB_IR,t_ir_type_param_table[mode].param_rx.btimer1); IR_CtrlIrSetBitTime2(APB_IR,t_ir_type_param_table[mode].param_rx.btimer2); IR_CtrlIrSetIrBitCycle(APB_IR,t_ir_type_param_table[mode].param_rx.bit_cycle); } IR_CtrlEnable(APB_IR); } 9.2.2.3 IR 中断(以及IR接收) static uint32_t IRQHandler_IR_INT(void *user_data) { if(IR_FsmGetIrTransmitOk(APB_IR)) ;//platform_printf(&quot;int ir send ok\\n&quot;); if(IR_FsmGetIrTxRepeat(APB_IR)) ;//platform_printf(&quot;int ir repeat ok\\n&quot;); if(IR_FsmGetIrReceivedOk(APB_IR)) { uint32_t value = IR_RxCodeGetIrRxUsercode(APB_IR) &lt;&lt;16 | IR_RxCodeGetIrRxDatacode(APB_IR); platform_printf(&quot;Received:0x%x\\n&quot;,value); } if(IR_FsmGetIrRepeat(APB_IR)) ; IR_FsmClearIrInt(APB_IR); return 0; } 9.2.2.4 IR 发射 static int ir_transmit_fun(uint16_t addr,uint16_t data) //ir hard transmit data { IR_TxCodeSetIrTxUsercode(APB_IR,addr); IR_TxCodeSetIrTxDatacode(APB_IR,data); IR_CleanIrTxRepeatMode(APB_IR);//must clearn the repeat mode reg IR_TxConfigTxStart(APB_IR); //while(!IR_FsmGetIrTransmitOk(APB_IR)); return 0; } static int ir_transmit_repeat(void) //ir hard transmit repeat { IR_CtrlIrTxRepeatMode(APB_IR); IR_TxConfigTxStart(APB_IR); // while(!IR_FsmGetIrTransmitOk(APB_IR)); return 0; } "],["ch-keyscan.html", "10 硬件键盘扫描控制器（KEYSCAN） 10.1 功能概述 10.2 使用说明 10.3 应用举例", " 10 硬件键盘扫描控制器（KEYSCAN） 10.1 功能概述 特性： 可配置矩阵，最大支持16行15列或者15行16列的键盘矩阵。 每个单独的行或者列可以设置启用或者禁用。 可配置时钟。 支持输入硬件去抖动，去抖时间可配置。 支持配置扫描间隔和释放时间，支持多按键同时按下。 支持中断和DMA。 10.2 使用说明 以4行*4列的键盘矩阵为例： 10.2.1 键盘矩阵的软件描述 typedef struct { KEYSCAN_InColIndex_t in_col; GIO_Index_t gpio; } KEYSCAN_InColList; typedef struct { KEYSCAN_OutRowIndex_t out_row; GIO_Index_t gpio; } KEYSCAN_OutRowList; KEYSCAN_OutRowList key_out_row[] = { {KEY_OUT_ROW_6, GIO_GPIO_32}, // 第1行 {KEY_OUT_ROW_7, GIO_GPIO_33}, // 第2行 {KEY_OUT_ROW_5, GIO_GPIO_31}, // 第3行 {KEY_OUT_ROW_0, GIO_GPIO_23}, // 第4行 }; #define key_out_row_num (sizeof(key_out_row) / sizeof(key_out_row[0])) KEYSCAN_InColList key_in_col[] = { {KEY_IN_COL_11, GIO_GPIO_11}, // 第1列 {KEY_IN_COL_12, GIO_GPIO_12}, // 第2列 {KEY_IN_COL_13, GIO_GPIO_13}, // 第3列 {KEY_IN_COL_14, GIO_GPIO_14}, // 第4列 }; #define key_in_col_num (sizeof(key_in_col) / sizeof(key_in_col[0])) 第1行按键接到了GPIO32，映射到KEYSCAN模块的ROW6。 第1列按键接到了GPIO11，映射到KEYSCAN模块的COL11。 以此类推4行4列的键盘阵列。 注意：KEYSCAN的ROW和COL不是随意映射到GPIO，映射关系参考管脚管理（PINCTRL）说明文档。 10.2.2 KEYSCAN模块初始化 typedef struct { KEYSCAN_InColList *col; int col_num; KEYSCAN_OutRowList *row; int row_num; KEYSCAN_Ctx *ctx; uint8_t fifo_num_trig_int; uint8_t dma_num_trig_int; uint8_t dma_en; uint8_t int_trig_en; uint16_t release_time; uint16_t scan_interval; uint8_t debounce_counter; } KEYSCAN_SetStateStruct; /** * @brief Initialize keyscan module * * @param[in] keyscan_set Initial parameter struct */ void KEYSCAN_Initialize(KEYSCAN_SetStateStruct* keyscan_set); 10.2.3 获取扫描到的按键 KEYSCAN模块使能扫描后会按照行和列的配置开始扫描。模块有FIFO缓存扫描数据。每次扫描循环结束，FIFO中压入1个0x400标志完成一次扫描。 可以配置FIFO中数据个数触发中断或者DMA触发中断： void KEYSCAN_SetFifoNumTrigInt(uint32_t trig_num); void KEYSCAN_SetDmaNumTrigInt(uint32_t trig_num); 获取FIFO是否为空的状态和数据： /** * @brief Check keyscan FIFO empty or not * * @return 0: FIFO have data; 1: empty */ uint8_t KEYSCAN_GetIntStateFifoEmptyRaw(void); /** * @brief GET keyscan FIFO data * * @return 0~4 bits: col; 5~9 bits: row; 10 bit: scan cycle end flag */ uint16_t KEYSCAN_GetKeyData(void); 按键FIFO原始数据的0~4位是按下按键所在的KEYSCAN模块中的col，5~9位是row，注意这个值并不是键盘矩阵中的行和列，可以用下面接口将原始数据解析为键盘矩阵中的行和列： /** * @brief Transfer keyscan FIFO raw data to keyboard array row and col * * @param[in] keyscan_set Initial parameter struct * @param[in] key_data keyscan FIFO raw data * @param[in] row pressed key&#39;s row in keyboard array * @param[in] col pressed key&#39;s col in keyboard array * @return 0: scan cycle end data; * 1: find key pressed, *row and *col are key position in keyboard array */ uint8_t KEYSCAN_KeyDataToRowColIdx(KEYSCAN_SetStateStruct* keyscan_set, uint32_t key_data, uint8_t *row, uint8_t *col); 10.3 应用举例 10.3.1 初始化KEYSCAN模块 KEYSCAN_OutRowList key_out_row[] = { {KEY_OUT_ROW_6, GIO_GPIO_32}, {KEY_OUT_ROW_7, GIO_GPIO_33}, {KEY_OUT_ROW_5, GIO_GPIO_31}, {KEY_OUT_ROW_0, GIO_GPIO_23}, }; #define key_out_row_num (sizeof(key_out_row) / sizeof(key_out_row[0])) KEYSCAN_InColList key_in_col[] = { {KEY_IN_COL_11, GIO_GPIO_11}, {KEY_IN_COL_12, GIO_GPIO_12}, {KEY_IN_COL_13, GIO_GPIO_13}, {KEY_IN_COL_14, GIO_GPIO_14}, }; #define key_in_col_num (sizeof(key_in_col) / sizeof(key_in_col[0])) static KEYSCAN_SetStateStruct keyscan_set = {0}; static KEYSCAN_Ctx key_ctx = {0}; static uint32_t keyscan_cb_isr(void *user_data); static void setup_peripherals_keyscan() { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ITEM_APB_KeyScan); SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl); SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl); keyscan_set.col = key_in_col; keyscan_set.col_num = key_in_col_num; keyscan_set.row = key_out_row; keyscan_set.row_num = key_out_row_num; keyscan_set.ctx = &amp;key_ctx; keyscan_set.fifo_num_trig_int = 1; keyscan_set.release_time = 110; keyscan_set.scan_interval = 0xFFFF; keyscan_set.debounce_counter = 50; keyscan_set.dma_num_trig_int = 0x10; keyscan_set.dma_en = 0; keyscan_set.int_trig_en = 1; KEYSCAN_Initialize(&amp;keyscan_set); platform_set_irq_callback(PLATFORM_CB_IRQ_KEYSCAN, keyscan_cb_isr, 0); return; } 10.3.2 中断数据处理 static uint8_t key_state_buf[2][key_out_row_num][key_in_col_num] = {0}; static uint8_t key_state_last_index = 0; static uint8_t key_state_now_index = 1; static void printf_key_state(void) { int row, col; for (row = 0; row &lt; key_out_row_num; row++) { for (col = 0; col &lt; key_in_col_num; col++) { if (key_state_buf[key_state_now_index][row][col] != key_state_buf[key_state_last_index][row][col]) { printf(&quot;row%u col%u %s\\r\\n&quot;, row + 1, col + 1, key_state_buf[key_state_now_index][row][col] == 0 ? &quot;release&quot; : &quot;press&quot;); } } } if (key_state_now_index == 0) { key_state_now_index = 1; key_state_last_index = 0; } else { key_state_now_index = 0; key_state_last_index = 1; } for (row = 0; row &lt; key_out_row_num; row++) { for (col = 0; col &lt; key_in_col_num; col++) { key_state_buf[key_state_now_index][row][col] = 0; } } return; } static void key_state_clear(void) { int row, col; for (row = 0; row &lt; key_out_row_num; row++) { for (col = 0; col &lt; key_in_col_num; col++) { key_state_buf[0][row][col] = 0; key_state_buf[1][row][col] = 0; } } } static uint32_t keyscan_cb_isr(void *user_data) { uint32_t key_data; uint8_t key_scan_row; uint8_t key_scan_col; uint8_t row = 0; uint8_t col = 0; static uint8_t have_key_pressed = 0; static uint8_t no_key_pressed_cnt = 0; while (KEYSCAN_GetIntStateFifoEmptyRaw() == 0) { key_data = KEYSCAN_GetKeyData(); if (KEYSCAN_KeyDataToRowColIdx(&amp;keyscan_set, key_data, &amp;row, &amp;col)) { key_state_buf[key_state_now_index][row - 1][col - 1] = 1; have_key_pressed = 1; } else { if (have_key_pressed == 1) { have_key_pressed = 0; no_key_pressed_cnt = 0; } else { } switch (no_key_pressed_cnt) { case 0: // have key pressed no_key_pressed_cnt++; printf_key_state(); break; case 1: // all key released no_key_pressed_cnt++; printf_key_state(); key_state_clear(); break; case 2: break; default: break; } } } return 0; } 10.3.3 效果 "],["ch-PDM.html", "11 PDM简介 11.1 功能描述 11.2 使用方法 11.3 编程指南", " 11 PDM简介 PDM全称pulse density modulation，即脉冲密度调制。 PDM模块处理来自外部音频前端(如数字麦克风)的脉冲密度调制信号的输入。该模块生成PDM时钟，支持双通道数据输入。 11.1 功能描述 11.1.1 特点 支持双通道，数据输入相同 16kHz输出采样率，24位采样 HW抽取过滤器 时钟和输出采样率之间的可选比为64或80 支持DMA和I2S的样本缓冲 11.1.2 PDM &amp; PCM PDM和PCM同为用数字信号表示模拟信号的音频数据调制方法，其主要区别是： PDM不像PCM等间隔采样 PDM只有1位非0即1的输出，而PCM采样结果可以是Nbit PDM使用远高于PCM采样率的时钟频率进行采样 PDM逻辑相对PCM复杂 PDM只需要2根信号线，即时钟线和数据线；PCM需要4根线 11.2 使用方法 11.2.1 方法概述 PDM使用方法分为PDM结合I2s使用和PDM数据直接DMA搬运两种。 PDM结合I2s： 1. PDM引脚GPIO配置（时钟、数据） 2. 外部时钟配置，使其处于工作模式 3. 写相应配置寄存器 4. 配置I2s数据源为PDM，配置I2s时钟、寄存器、中断 5. 使能PDM，使能I2s 6. 等待I2s中断产生 7. 读取状态寄存器，读取RX_MEM中数据 8. 传输完毕，关闭PDM和I2S PDM数据DMA搬运： 1. PDM引脚GPIO配置（时钟、数据） 2. 外部时钟配置，使其处于工作模式 3. 写相应配置寄存器 4. 配置DMA寄存器、中断 5. 使能DMA，使能PDM 6. 等待DMA中断产生 7. 传输完毕，关闭PDM和DMA 其中I2s和DMA相关配置不在本节介绍内容范围内，可参考本手册对应章节。 11.2.2 注意点 I2s时钟源可以选择晶振24M时钟和PLL时钟，要注意是选择哪一个时钟源 建议选择晶振24M作为时钟源，这样可以获得较好的准确度和防抖动效果 需要查阅数字麦克风数据手册了解其时钟要求，并正确配置PDM时钟频率 结合I2s使用时要先使能PDM最后开启I2s 结合DMA使用时要先使能DMA最后开启PDM 建议采用DMA乒乓搬运的方式 11.3 编程指南 11.3.1 驱动接口 PDM_Config：PDM配置接口 PDM_Start：PDM使能接口 PDM_DmaEnable：PDM使能DMA接口 11.3.2 代码示例 下面以PDM结合I2s使用和PDM数据直接DMA搬运两种方式来展示PDM的具体使用方法。 已知现有mic使用的时钟频率为3M，I2s采样率16K。 11.3.2.1 PDM结合I2s： #define PDM_PIN_MCLK 28 #define PDM_PIN_IN 29 static uint32_t I2s_isr(void *user_data) { uint32_t state = I2S_GetIntState(APB_I2S); I2S_ClearIntState(APB_I2S, state); int i = I2S_GetRxFIFOCount(APB_I2S); while (i) { // do something with these data i--; } } void audio_input_setup(void) { // GPIO &amp; Pin Ctrl PINCTRL_SetPadMux(PDM_PIN_MCLK, IO_SOURCE_PDM_DMIC_MCLK); PINCTRL_SetPadMux(PDM_PIN_IN, IO_SOURCE_PDM_DMIC_IN); PINCTRL_SelPdmIn(PDM_PIN_IN); // PDM clock configuration, 3M SYSCTRL_SetPdmClkDiv(8, 1); SYSCTRL_SelectTypeAClk(SYSCTRL_ITEM_APB_PDM, SYSCTRL_CLK_ADC_DIV); // PDM register configuration PDM_Config(APB_PDM, 0, 1, 1, 1, 0); // I2s configuration, bclk=2.4M, samplerate=16K, data from PDM I2S_DataFromPDM(1); I2S_ConfigClk(APB_I2S, 5, 75); I2S_ConfigIRQ(APB_I2S, 0, 1, 0, 10); I2S_DMAEnable(APB_I2S, 0, 0); I2S_Config(APB_I2S, I2S_ROLE_MASTER, I2S_MODE_STANDARD, 0, 1, 0, 1, 24); // I2s interruption platform_set_irq_callback(PLATFORM_CB_IRQ_I2S, I2s_isr, 0); // enable I2s and PDM I2S_ClearRxFIFO(APB_I2S); PDM_Start(APB_PDM, 1); I2S_Enable(APB_I2S, 0, 1); } 上面示例涉及到的关于I2s配置参考手册的I2s章节： 11.3.2.2 PDM数据DMA搬运 #define PDM_PIN_MCLK 28 #define PDM_PIN_IN 29 #define CHANNEL_ID 0 uint32_t buff[80]; DMA_Descriptor test __attribute__((aligned (8))); static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); DMA_EnableChannel(CHANNEL_ID, &amp;test); // do something with data in buff } void DMA_SetUp(void) { DMA_Reset(1); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); test.Next = NULL; DMA_PreparePeripheral2RAM(&amp;test, buff, SYSCTRL_DMA_PDM, 80, DMA_ADDRESS_INC, 0 | 1 &lt;&lt; 24); DMA_EnableChannel(CHANNEL_ID, &amp;test); } void audio_input_setup(void) { //GPIO &amp; Pin Ctrl PINCTRL_SetPadMux(PDM_PIN_MCLK, IO_SOURCE_PDM_DMIC_MCLK); PINCTRL_SetPadMux(PDM_PIN_IN, IO_SOURCE_PDM_DMIC_IN); PINCTRL_SelPdmIn(PDM_PIN_IN); // PDM clock configuration, 3M SYSCTRL_SetAdcClkDiv(8); SYSCTRL_SelectTypeAClk(SYSCTRL_ITEM_APB_PDM, SYSCTRL_CLK_ADC_DIV); // PDM register configuration PDM_Config(APB_PDM, 0, 1, 1, 0, 0); PDM_DmaEnable(APB_PDM, 1, 0); // DMA setup DMA_SetUp(); // enable DMA and PDM PDM_DmaEnable(APB_PDM, 1, 1); PDM_Start(APB_PDM, 1); } 建议采用DMA乒乓搬运的方法进行数据搬运，具体讲解参考手册DMA章节。 "],["ch-pinctrl.html", "12 管脚管理（PINCTRL） 12.1 功能概述 12.2 使用说明", " 12 管脚管理（PINCTRL） 12.1 功能概述 PINCTRL 模块管理芯片所有 IO 管脚的功能，包括外设 IO 的映射，上拉、下拉选择，输入模式控制， 输出驱动能力设置等。 每个 IO 管脚都可以配置为数字或模拟模式，当配置为数字模式时，特性如下： 每个 IO 管脚可以映射多种不同功能的外设 每个 IO 管脚都支持上拉或下拉 每个 IO 管脚都支持施密特触发输入方式 每个 IO 管脚支持四种输出驱动能力 鉴于片内外设丰富、IO 管脚多，进行管脚全映射并不现实，为此，PINCTRL 尽量保证灵活性的前提下做了一定取舍、优化。 部分常用外设的输入、输出功能管脚可与 \\(\\{{0 .. 17, 21, 22, 31, 34, 35\\}}\\) 这 23 个常用 IO 之间任意连接（全映射）， 这部分常用外设功能管脚总结于表 12.1。 表 12.2 列出了其它外设功能管脚支持映射到哪些 IO 管脚上。 除此以外，所有 IO 管脚都可以配置为 GPIO 或者 DEBUG 模式。GPIO 模式的输入、输出方向由 GIO_SetDirection 控制。 DEBUG 模式为保留功能，具体功能暂不开放。 表 12.1: 支持与常用 IO 全映射的常用功能管脚 外设 功能管脚 I2C I2C0_SCL_I, I2C0_SCL_O, I2C0_SDA_I, I2C0_SDA_O, I2C1_SCL_I, I2C1_SCL_O, I2C1_SDA_I, I2C1_SDA_O I2S I2S_BCLK_I, I2S_BCLK_O, I2S_DIN, I2S_DOUT, I2S_LRCLK_I, I2S_LRCLK_O IR IR_DATIN, IR_DATOUT, IR_WAKEUP PCAP PCAP0_IN, PCAP1_IN, PCAP2_IN, PCAP3_IN, PCAP4_IN, PCAP5_IN PDM PDM_DMIC_IN, PDM_DMIC_MCLK QDEC QDEC_INDEX, QDEC_PHASEA, QDEC_PHASEB SPI0 SPI0_CLK_IN, SPI0_CLK_OUT, SPI0_CSN_IN, SPI0_CSN_OUT, SPI0_HOLD_IN, SPI0_HOLD_OUT, SPI0_MISO_IN, SPI0_MISO_OUT, SPI0_MOSI_IN, SPI0_MOSI_OUT, SPI0_WP_IN, SPI0_WP_OUT SPI SPI1_CLK_IN, SPI1_CLK_OUT, SPI1_CSN_IN, SPI1_CSN_OUT, SPI1_HOLD_IN, SPI1_HOLD_OUT, SPI1_MISO_IN, SPI1_MISO_OUT, SPI1_MOSI_IN, SPI1_MOSI_OUT, SPI1_WP_IN, SPI1_WP_OUT SWD SWDO, SW_TCK, SW_TMS UART0 UART0_CTS, UART0_RTS, UART0_RXD, UART0_TXD UART1 UART1_CTS, UART1_RTS, UART1_RXD, UART1_TXD 表 12.2: 其它外设功能管脚的映射关系 外设功能管脚 可连接到的 IO 管脚 KEY_IN_COL_0 0, 23 KEY_IN_COL_1 1, 24 KEY_IN_COL_2 2, 25 KEY_IN_COL_3 3, 29 KEY_IN_COL_4 4, 30 KEY_IN_COL_5 5, 31 KEY_IN_COL_6 6, 32 KEY_IN_COL_7 7, 33 KEY_IN_COL_8 8, 34 KEY_IN_COL_9 9, 35 KEY_IN_COL_10 10, 36 KEY_IN_COL_11 11, 37 KEY_IN_COL_12 12, 38 KEY_IN_COL_13 13, 39 KEY_IN_COL_14 14, 40 KEY_IN_COL_15 15, 41 KEY_IN_COL_16 16 KEY_IN_COL_17 17 KEY_IN_COL_18 21 KEY_IN_COL_19 22 KEY_OUT_ROW_0 0, 23 KEY_OUT_ROW_1 1, 24 KEY_OUT_ROW_2 2, 25 KEY_OUT_ROW_3 3, 29 KEY_OUT_ROW_4 4, 30 KEY_OUT_ROW_5 5, 31 KEY_OUT_ROW_6 6, 32 KEY_OUT_ROW_7 7, 33 KEY_OUT_ROW_8 8, 34 KEY_OUT_ROW_9 9, 35 KEY_OUT_ROW_10 10, 36 KEY_OUT_ROW_11 11, 37 KEY_OUT_ROW_12 12, 38 KEY_OUT_ROW_13 13, 39 KEY_OUT_ROW_14 14, 40 KEY_OUT_ROW_15 15, 41 KEY_OUT_ROW_16 16 KEY_OUT_ROW_17 17 KEY_OUT_ROW_18 21 KEY_OUT_ROW_19 22 ANT_SW0 0, 3, 6, 9, 12, 15, 21, 34 ANT_SW1 1, 4, 7, 10, 13, 16, 22, 35 ANT_SW2 2, 5, 8, 11, 14, 17, 31 ANT_SW3 0, 3, 6, 9, 12, 15, 21, 34 ANT_SW4 1, 4, 7, 10, 13, 16, 22, 35 ANT_SW5 2, 5, 8, 11, 14, 17, 31 ANT_SW6 0, 3, 6, 9, 12, 15, 21, 34 ANT_SW7 1, 4, 7, 10, 13, 16, 22, 35 PA_RXEN 11, 12, 13, 14, 15, 16, 17, 34, 35 PA_TXEN 4, 5, 6, 7, 8, 9, 10, 34, 35 TIMER0_PWM_0A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 TIMER0_PWM_0B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 TIMER0_PWM_1A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 TIMER0_PWM_1B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 TIMER1_PWM_0A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 TIMER1_PWM_0B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 TIMER1_PWM_1A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 TIMER1_PWM_1B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 TIMER2_PWM_0A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 TIMER2_PWM_0B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 TIMER2_PWM_1A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 TIMER2_PWM_1B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 PWM_0A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 PWM_0B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 PWM_1A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 PWM_1B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 PWM_2A 0, 2, 4, 6, 8, 10, 12, 14, 16, 21, 31, 35 PWM_2B 1, 3, 5, 7, 9, 11, 13, 15, 17, 22, 34 QDEC_EXT_IN_CLK 3, 9 QDEC_TIMER_EXT_IN1_A 1, 7 QDEC_TIMER_EXT_IN2_A 2, 8 QDEC_TIMER_EXT_IN2_B 5, 11 QDEC_TIMER_EXT_OUT0_A 0, 6 QDEC_TIMER_EXT_OUT1_A 1, 7 QDEC_TIMER_EXT_OUT2_A 2, 8 QDEC_TIMER_EXT_OUT0_B 3, 9 QDEC_TIMER_EXT_OUT1_B 4, 10 QDEC_TIMER_EXT_OUT2_B 5, 11 SPI0_CLK_IN 19 SPI0_CLK_OUT 19 SPI0_CSN_IN 18 SPI0_CSN_OUT 18 SPI0_HOLD_IN 20 SPI0_HOLD_OUT 20 SPI0_MISO_IN 27 SPI0_MISO_OUT 27 SPI0_MOSI_IN 28 SPI0_MOSI_OUT 28 SPI0_WP_IN 26 SPI0_WP_OUT 26 SPI2AHB_CS 16 SPI2AHB_DI 17 SPI2AHB_DO 17 SPI2AHB_SCLK 15 12.2 使用说明 12.2.1 为外设配置 IO 管脚 将外设输出连接到 IO 管脚 通过 PINCTRL_SetPadMux 将外设输出连接到 IO 管脚。 注意按照表 12.1 和 表 12.2 确认硬件是否支持。对于不支持的配置，显然无法生效，函数将返回非 0 值。 int PINCTRL_SetPadMux( const uint8_t io_pin_index, // IO 序号 (0 .. IO_PIN_NUMBER - 1) const io_source_t source // IO 源 ); 例如将 IO 管脚 10 配置为 GPIO 模式： PINCTRL_SetPadMux(10, IO_SOURCE_GPIO); 将 IO 管脚连接到外设的输入 对于有些外设的输入同样通过 PINCTRL_SetPadMux 配置。对于另一些输入， PINCTRL 为不同的外设分别提供了 API 用以配置输入。比如 UART 的数据输入 RXD 和用于硬件流控的 CTS，需要通过 PINCTRL_SelUartIn 配置 ： int PINCTRL_SelUartIn( uart_port_t port, // UART 序号 uint8_t io_pin_rxd, // 连接到 RXD 输入的 IO 管脚 uint8_t io_pin_cts); // 连接到 CTS 输入的 IO 管脚 对于不需要配置的输入，可在对应的参数上填入值 IO_NOT_A_PIN。 表 12.3 罗列了为各外设提供的输入配置函数。 表 12.3: 各外设的输入配置函数 外设 配置函数 KeyScan PINCTRL_SelKeyScanColIn I2C PINCTRL_SelI2cIn I2S PINCTRL_SelI2sIn IR PINCTRL_SelIrIn PDM PINCTRL_SelPdmIn PCAP PINCTRL_SelPCAPIn QDEC PINCTRL_SelQDECIn SWD PINCTRL_SelSwIn SPI PINCTRL_SelSpiIn UART PINCTRL_SelUartIn USB PINCTRL_SelUSB 12.2.2 配置上拉、下拉 IO 管脚的上拉、下拉模式通过 PINCTRL_Pull 配置： void PINCTRL_Pull( const uint8_t io_pin_index, // IO 管脚序号 const pinctrl_pull_mode_t mode // 模式 ); 表 12.4 列出了各管脚默认的上下拉配置。 表 12.4: 管脚上下拉默认配置 管脚 默认配置 1 上拉 2 上拉 3 上拉 4 上拉 15 下拉 16 下拉 17 下拉 其它 禁用上下拉 12.2.3 配置驱动能力 通过 PINCTRL_SetDriveStrength 配置 IO 管脚的驱动能力： void PINCTRL_SetDriveStrength( const uint8_t io_pin_index, const pinctrl_drive_strength_t strength); 默认驱动能力共分 4 档，分别为 \\(2mA\\)、\\(4mA\\)、\\(8mA\\)、\\(12mA\\)。除了 IO1 驱动能力默认为 \\(12mA\\) 之外， 其它管脚驱动能力默认 \\(8mA\\)。 12.2.4 配置天线切换控制管脚 支持最多 8 个管脚用于天线切换控制，相应地，天线切换模板（switching pattern）内每个数字包含 8 个比特， 取值范围为 \\(0..255\\)。这 8 个比特可依次通过 IO_SOURCE_ANT_SW0、……、IO_SOURCE_ANT_SW7 选择。 例如，查表 12.2 可知管脚 0 能够映射为 ANT_SW0，即比特 0。 通过下面这行代码就可将管脚 0 映射为 ANT_SW0： PINCTRL_SetPadMux(0, IO_SOURCE_ANT_SW0); 通过函数 PINCTRL_EnableAntSelPins 可批量配置用于天线切换控制的管脚： int PINCTRL_EnableAntSelPins( int count, // 数目 const uint8_t *io_pins); // 管脚数组 管脚数组 io_pins 里的第 n 个元素代表第 n 个比特所要映射的管脚。如果不需要为某个比特配置管脚，则在 io_pins 的对应位置填入 IO_NOT_A_PIN。比如，只选用第 0、第 2 等两个比特用作控制，分别映射到管脚 0 和 5： const uint8_t io_pins[] = {0, IO_NOT_A_PIN, 5}; PINCTRL_EnableAntSelPins(sizeof(io_pins), io_pins); 12.2.5 配置模拟模式 通过以下 3 步可将一个管脚配置为模拟模式： 配置为 GPIO 模式； 禁用上下拉； 将 GPIO 配置为高阻态。 函数 PINCTRL_EnableAnalog 封装了以上步骤： void PINCTRL_EnableAnalog(const uint8_t io_index); 模拟模式适用于以下几种外设。 USB 函数 PINCTRL_SelUSB() 内部封装了 PINCTRL_EnableAnalog，开发者不需要再为 USB 管脚调用该函数配置模拟模式。 ADC 开发者需要调用该函数使能某管脚的 ADC 输入功能。支持 ADC 输入功能的管脚如表 12.5 所示。 表 12.5: 支持 ADC 输入的管脚 管脚 单端模式 差分模式 7 AIN 0 AIN 0 P 8 AIN 1 AIN 0 N 9 AIN 2 AIN 1 P 10 AIN 3 AIN 1 N 11 AIN 4 AIN 2 P 12 AIN 5 AIN 2 N 13 AIN 6 AIN 3 P 14 AIN 7 AIN 3 N "],["pte简介.html", "13 PTE简介 13.1 功能描述 13.2 使用方法 13.3 编程指南", " 13 PTE简介 PTE全称Peripheral trigger engine，即外设触发引擎。 其主要作用是使外围设备可以通过其他外围设备或事件独立于CPU进行自主交互。PTE允许外围设备之间可以精确触发。 13.1 功能描述 13.1.1 特点 支持APB总线触发 支持4通道PTE 支持复用触发源或复用触发地址 支持产生CPU中断 13.1.2 PTE原理图 图 13.1: PTE原理图 13.1.3 功能 PTE具有不同外设之间的可编程内部通道，可以从src外设触发dst外设。PTE可以不依赖CPU而通过硬件的方式触发任务，因此任务可以在同步DFF所占用的周期内启动。 src外设通过pte_in_mask配置，dst外设通过pte_out_mask配置。在SOC中集成了4个PTE通道，每个通道可以通过通道使能信号来启用/禁用。 当DFF为高时PTE中断将挂起。在清除PTE中断之前，src外设中断必须被清除，否则另一个启动脉冲将发送到dst外设，这可能会产生未知的错误。 13.2 使用方法 13.2.1 方法概述 PTE使用方法总结为：建议不使用PTE中断，在dst外设中断里清PTE中断（或关闭PTE通道）。 1. 配置触发外设和被触发外设以及相应中断（被触发外设中断一定要有） 2. 配置要使用的PTE通道寄存器以及中断（建议不使用PTE中断） 3. 使能触发外设，等待PTE中断（如定义）和被触发外设来中断 4. 在PTE中断中清PTE mask（如定义） 5. 在被触发外设中断中清PTE中断（如定义），如果只触发一次则直接关闭PTE通道 13.2.2 注意点 不清src中断会循环通过PTE触发dst外设，使程序陷入死循环 不清PTE中断会循环触发dst外设，使程序陷入死循环 PTE中断优先级低容易被打断，在极端情况下如果dst外设来中断非常快会出问题（一般不会） 使用PTE中断会更多占用CPU资源并增加触发过程操作复杂度、增加出错风险，中断处理程序完全可以在src和dst中断中完成，所以强烈建议不要使用PTE中断 13.3 编程指南 13.3.1 src&amp;dst外设 当前PTE支持的src外设定义在SYSCTRL_PTE_SRC_INT中： typedef enum { SYSCTRL_PTE_I2C0_INT = 0, SYSCTRL_PTE_I2C1_INT = 1, SYSCTRL_PTE_SARADC_INT = 2, SYSCTRL_PTE_I2S_INT = 3, SYSCTRL_PTE_DMA_INT = 4, SYSCTRL_PTE_IR_INT = 5, SYSCTRL_PTE_KEYSCANNER_INT = 6, SYSCTRL_PTE_PWMC0_INT = 7, SYSCTRL_PTE_PWMC1_INT = 8, SYSCTRL_PTE_PWMC2_INT = 9, SYSCTRL_PTE_TIMER0_INT = 10, SYSCTRL_PTE_TIMER1_INT = 11, SYSCTRL_PTE_TIMER2_INT = 12, SYSCTRL_PTE_GPIO0_INT = 13, SYSCTRL_PTE_GPIO1_INT = 14, SYSCTRL_PTE_UART0_INT = 15, SYSCTRL_PTE_UART1_INT = 16, SYSCTRL_PTE_SPI0_INT = 17, SYSCTRL_PTE_SPI1_INT = 18, SYSCTRL_PTE_SPIFLASH = 19, SYSCTRL_PTE_RCT_CNT = 20, SYSCTRL_PTE_IR_WAKEUP = 21, SYSCTRL_PTE_USB_INT = 22, SYSCTRL_PTE_QDEC_INT = 23, SYSCTRL_PTE_SRC_INT_MAX = 24, } SYSCTRL_PTE_SRC_INT; dst外设定义在SYSCTRL_PTE_DST_EN中： typedef enum { SYSCTRL_PTE_I2C0_EN = 0, SYSCTRL_PTE_I2C1_EN = 1, SYSCTRL_PTE_SARADC_EN = 2, SYSCTRL_PTE_I2S_TX_EN = 3, SYSCTRL_PTE_I2S_RX_EN = 4, SYSCTRL_PTE_IR_EN = 5, SYSCTRL_PTE_KEYSCANNER_EN = 6, SYSCTRL_PTE_PWMC0_EN = 7, SYSCTRL_PTE_PWMC1_EN = 8, SYSCTRL_PTE_PWMC2_EN = 9, SYSCTRL_PTE_TIMER0_CH0_EN = 10, SYSCTRL_PTE_TIMER0_CH1_EN = 11, SYSCTRL_PTE_TIMER1_CH0_EN = 12, SYSCTRL_PTE_TIMER1_CH1_EN = 13, SYSCTRL_PTE_TIMER2_CH0_EN = 14, SYSCTRL_PTE_TIMER2_CH1_EN = 15, SYSCTRL_PTE_DST_EN_MAX = 16, } SYSCTRL_PTE_DST_EN; 通过PTE连接的src外设和dst外设需要在已注册枚举中选取。 13.3.2 驱动接口 PTE_ConnectPeripheral：PTE外设连接接口 PTE_EnableChennel：PTE通道使能接口 PTE_ChennelClose：PTE通道关闭接口 PTE_IrqProcess：PTE标准中断程序接口 PTE_OutPeripheralContinueProcess：dst外设中断标准PTE中继触发接口 PTE_OutPeripheralEndProcess：dst外设中断标准PTE结束接口 13.3.3 代码示例 下面以Timer0通过PTE通道0触发Timer1为例展示PTE的具体使用方法。 src外设和dst外设配置方法不在本文档介绍范围内，我们默认Timer0和Timer1已经配置好并注册好中断。 uint32_t Timer0Isr(void *user_data) { TMR_IntClr(APB_TMR0); return 0; } uint32_t Timer1Isr(void *user_data) { TMR_IntClr(APB_TMR1); PTE_OutPeripheralContinueProcess(0); return 0; } // 仅供参考，不建议注册PTE中断 uint32_t PTE0Isr(void *user_data) { PTE_IrqProcess(0); return 0; } void PTE_Test(void) { PTE_ConnectPeripheral(SYSCTRL_PTE_CHENNEL_0, SYSCTRL_PTE_TIMER0_INT, SYSCTRL_PTE_TIMER1_CH0_EN); TMR_Enable(APB_TMR0); } 上面示例会保留PTE通道0并等待下一次触发。如果想要触发之后直接关闭通道代码如下： uint32_t Timer1Isr(void *user_data) { TMR_IntClr(APB_TMR1); PTE_OutPeripheralEndProcess(0); return 0; } 关闭通道会断开Timer0和Timer1的连接，再次触发需要重新建立连接。 "],["ch-pwm.html", "14 增强型脉宽调制发生器（PWM） 14.1 PWM 工作模式 14.2 PCAP 14.3 PWM 使用说明 14.4 PCAP 使用说明", " 14 增强型脉宽调制发生器（PWM） 增强型脉宽调制发生器具有两大功能：生成脉宽调制信号（PWM），捕捉外部脉冲输入（PCAP）。 增强型脉宽调制发生器具备 3 个通道，每个通道都可以单独配置为 PWM 或者 PCAP 模式。 每个通道拥有独立的 FIFO。FIFO 里的每个存储单元为 2 个 20bit 数据。 FIFO 深度为 4，即最多存储 4 个单元，共 \\(8 \\times 20bit\\) 数据。 这里的 20bit 位宽是因为本硬件模块内部 PWM 使用的各计数器都是 20 比特。 可根据 FIFO 内的数据量触发中断或者 DMA 传输。 说明：TIMER 也支持生成脉宽调制信号，但是可配置的参数较简单，不支持死区等。 PWM 特性： 最多支持 3 个 PWM 通道，每一个通道包含 A、B 两个输出 每个通道参数独立 支持死区 支持通过 DMA 更新 PWM 配置 PCAP 特性： 支持 3 个 PCAP 通道，每一个通道包含两个输入 支持捕捉上升沿、下降沿 支持通过 DMA 读取数据 14.1 PWM 工作模式 PWM 使用的时钟频率可配置，请参考 SYSCTRL。 每个 PWM 通道支持以下多种工作模式： typedef enum { ..._UP_WITHOUT_DIED_ZONE = ..., ..._UP_WITH_DIED_ZONE = ..., ..._UPDOWN_WITHOUT_DIED_ZONE = ..., ..._UPDOWN_WITH_DIED_ZONE = ..., ..._SINGLE_WITHOUT_DIED_ZONE = ..., ..._DMA = ..., } PWM_WorkMode_t; 14.1.1 最简单的模式：UP_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH &lt;= cnt; B = !A; } 14.1.2 UP_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH，DZONE_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH + DZONE_TH &lt;= cnt; B = DZONE_TH &lt;= cnt &lt; HIGH_TH); } 14.1.3 UPDOWN_WITHOUT_DIED_ZONE 此模式需要的门限参数与 UP_WITHOUT_DIED_ZONE 相同。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH &lt;= cnt &lt;= PERA_TH + HIGH_TH; B = !A; } 14.1.4 UPDOWN_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH。 以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH + DZONE_TH &lt;= cnt &lt;= PERA_TH + HIGH_TH; B = (cnt &lt; PERA_TH - HIGH_TH) || (cnt &gt; PERA_TH + HIGH_TH + DZONE_TH); } 14.1.5 SINGLE_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。此模式只产生一个脉冲，以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt++; A = HIGH_TH &lt;= cnt &lt; PERA_TH; B = !A; } 以上伪代码仅用于辅助描述硬件行为，与实际行为可以存在微小差异。 14.1.6 DMA 模式 此模式支持通过 DMA 实时更新门限。 14.1.7 输出控制 对于每个通道的每一路输出，另有 3 个参数控制最终的两路输出：掩膜、停机输出值、反相。 最终的输出以伪代码描述如下： output_control(v) { if (掩膜 == 1) return A 路输出 0、B 路输出 1; if (本通道已停机) return 停机输出值; if (反相) v = !v; return v; } 14.2 PCAP PCAP 每个通道包含两路输入。PCAP 内部有一个单独的 32 比特计数器3， 当检测到输入信号变化（包含上升沿和下降沿）时，PCAP 将计数器的值及边沿变化信息作为一个存储单元压入 FIFO： struct data0 { uint32_t cnt_high:12; uint32_t p_cap_0_p:1; // A 路出现上升沿 uint32_t p_cap_0_n:1; // A 路出现下降沿 uint32_t p_cap_1_p:1; // B 路出现上升沿 uint32_t p_cap_1_n:1; // B 路出现下降沿 uint32_t tag:4; uint32_t padding:12; }; struct data1 { uint32_t cnt_low:20; uint32_t padding:12; }; 通过复位整个模块可以清零 PCAP 计数器。 14.3 PWM 使用说明 14.3.1 启动与停止 共有两个开关与 PWM 的启动和停止有关：使能（Enable）、停机控制（HaltCtrl）。只有当 Enable 为 1， HaltCtrl 为 0 时，PWM 才真正开始工作。 相关的 API 为： // 使能 PWM 通道 void PWM_Enable( const uint8_t channel_index, // 通道号 const uint8_t enable // 使能或禁用 ); // PWM 通道停机控制 void PWM_HaltCtrlEnable( const uint8_t channel_index, // 通道号 const uint8_t enable // 停机(1) 或运转(0) ); 14.3.2 配置工作模式 void PWM_SetMode( const uint8_t channel_index, // 通道号 const PWM_WorkMode_t mode // 模式 ); 14.3.3 配置门限 // 配置 PERA_TH void PWM_SetPeraThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 DZONE_TH void PWM_SetDiedZoneThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 HIGH_TH void PWM_SetHighThreshold( const uint8_t channel_index, const uint8_t multi_duty_index, // 对于 ING916XX，此参数无效 const uint32_t threshold); 各门限值最大支持 0xFFFFF，共 20 个比特。 14.3.4 输出控制 // 掩膜控制 void PWM_SetMask( const uint8_t channel_index, // 通道号 const uint8_t mask_a, // A 路掩膜 const uint8_t mask_b // B 路掩膜 ); // 配置停机输出值 void PWM_HaltCtrlCfg( const uint8_t channel_index, // 通道号 const uint8_t out_a, // A 路停机输出值 const uint8_t out_b // B 路停机输出值 ); // 反相 void PWM_SetInvertOutput( const uint8_t channel_index, // 通道号 const uint8_t inv_a, // A 路是否反相 const uint8_t inv_b // B 路是否反相 ); 14.3.5 综合示例 下面的例子将 channel_index 通道配置成输出频率为 frequency、占空比为 (on_duty)% 的方波， 涉及 3 个关键参数： 生成这种最简单的 PWM 信号需要的模式为 UP_WITHOUT_DIED_ZONE； PERA_TH 控制输出信号的频率，设置为 PWM_CLOCK_FREQ / frequency； HIGH_TH 控制信号的占空比，设置为 PERA_TH * (100 - on_duty) % void PWM_SetupSimple( const uint8_t channel_index, const uint32_t frequency, const uint16_t on_duty) { uint32_t pera = PWM_CLOCK_FREQ / frequency; uint32_t high = pera &gt; 1000 ? pera / 100 * (100 - on_duty) : pera * (100 - on_duty) / 100; PWM_HaltCtrlEnable(channel_index, 1); PWM_Enable(channel_index, 0); PWM_SetPeraThreshold(channel_index, pera); PWM_SetHighThreshold(channel_index, 0, high); PWM_SetMode(channel_index, PWM_WORK_MODE_UP_WITHOUT_DIED_ZONE); PWM_SetMask(channel_index, 0, 0); PWM_Enable(channel_index, 1); PWM_HaltCtrlEnable(channel_index, 0); } 14.3.6 使用 DMA 实时更新配置 使用 DMA 能够实时更新配置（相当于工作在 UP_WITHOUT_DIED_ZONE，但是每个循环使用不同的参数）： 每当 PWM 计数器计完一圈回零时，自动使用来自 DMA 的数据更新配置。 这些数据以 2 个 uint32_t 为一组，依次表示 HIGH_TH 和 PERA_TH。 void PWM_DmaEnable( const uint8_t channel_index, // 通道号 uint8_t trig_cfg, // DMA 请求触发门限 uint8_t enable // 使能 ); 当 PWM 内部 FIFO 数据少于 trig_cfg，PWM 请求 DMA 传输数据。PWM FIFO 深度为 8 ，可以存储 8 个 32 比特数据（只有低 20 比特有效，其余比特忽略），相当于 4 组 PWM 配置， 所以 trig_cfg 的取值范围为 \\(0..7\\)。 14.4 PCAP 使用说明 14.4.1 配置 PCAP 模式 要启用 PCAP 模式，需要 5 个步骤： 关闭整个模块的时钟（参考 SYSCTRL） 使用 PCAP_Enable 使能 PCAP 模式 void PCAP_Enable( const uint8_t channel_index // 通道号 ); 使用 PCAP_EnableEvents 选择要检测的事件 void PCAP_EnableEvents( const uint8_t channel_index, uint8_t events_on_0, uint8_t events_on_1); events 为下面两个事件的组合： enum PCAP_PULSE_EVENT { PCAP_PULSE_RISING_EDGE = 0x1, PCAP_PULSE_FALLING_EDGE = 0x2, }; 比如在通道 1 的 A 路输入上同时检测、上报上升沿和下降沿： PCAP_EnableEvents(1, PCAP_PULSE_RISING_EDGE | PCAP_PULSE_FALLING_EDGE, ...); 打开整个模块的时钟（参考 SYSCTRL） 配置 DMA 传输 当 PCAP 通道 FIFO 内存储的数据多于或等于 trig_cfg 时，请求 DMA 传输数据。trig_cfg 的取值范围为 \\(0..7\\)。 void PCAP_DmaEnable( const uint8_t channel_index, // 通道号 uint8_t trig_cfg, // DMA 请求触发门限 uint8_t enable // 使能 ); 使能计数器 void PCAP_CounterEnable( uint8_t enable // 使能(1)/禁用(0) ); 14.4.2 读取计数器 uint32_t PCAP_ReadCounter(void); 所有 6 路输入共有此计数器。↩︎ "],["ch-qdec.html", "15 QDEC简介 15.1 功能描述 15.2 使用方法 15.3 编程指南", " 15 QDEC简介 QDEC全称Quadrature Decoder，即正交解码器。 其作用是用来解码来自旋转编码器的脉冲序列，以提供外部设备运动的步长和方向。 15.1 功能描述 15.1.1 特点 可配置时钟 支持过滤器 支持APB总线 支持DMA 15.1.2 正转和反转 QDEC是通过采集到phase_a、phase_b相邻两次的数值变化来判断外设的运动方向。 顺时针采集数据如图所示： 图 15.1: QDEC顺时针采集数据 逆时针采集数据如图所示： 图 15.2: QDEC逆时针采集数据 在QDEC数据上，如果引脚配置和连接正确，顺时针转动则采集到的数据逐渐增大，逆时针则数据逐渐减小。 15.2 使用方法 15.2.1 方法概述 方法概述为：GPIO选配，时钟配置，QDEC参数配置以及数据处理。 15.2.1.1 GPIO选择 驱动接口：PINCTRL_SelQDECIn QDEC的GPIO选择，请参考《ING91682X_BLE5.3_芯片数据手册》中的“IO引脚控制器Pin Controller”一节 对phase_a、phase_b选定要配置的GPIO口，并调用PINCTRL_SelQDECIn接口进行配置。 15.2.1.2 时钟配置 驱动接口：SYSCTRL_SelectQDECClk 当前QDEC可以选择使用的时钟源为HCLK时钟或者sclk_slow时钟 对所选用的时钟源还需要进行一次分频，分频系数范围为1-1023，默认值为2 这里需要特别注意的是： 请务必配置pclk时钟频率不大于qdec时钟源频率 注意： 如果配置pclk频率大于qdec时钟源频率，会出现qdec参数配置失败从而不能正常工作的现象。 为了方便开发者使用，可以直接调用下面提供的接口来配置pclk时钟符合上述要求： static void QDEC_PclkCfg(void) { if ((APB_SYSCTRL-&gt;QdecCfg &gt;&gt; 15) &amp; 1) return; uint32_t hclk = SYSCTRL_GetHClk(); uint32_t slowClk = SYSCTRL_GetSlowClk(); uint8_t div = hclk / slowClk; if (hclk % slowClk) div++; if (!(div &gt;&gt; 4)) SYSCTRL_SetPClkDiv(div); } 开发者可以将以上代码拷贝到程序里，在配置qdec之前调用即可。 15.2.1.3 QDEC参数配置 驱动接口：QDEC_EnableQdecDiv、QDEC_QdecCfg 共有3个参数需要配置：qdec_clk_div、filter和miss 其含义分别如下： qdec_clk_div：用于控制qdec结果上报频率。即多少个时钟周期上报一次采样结果 filter：用于过滤filter×时钟周期时长以内的毛刺 miss：用于控制qdec可以自动补偿的最大miss结果数。例如由于滚轮转动过快，导致两次采样中变换了不止一个结果，则此时会自动补偿最多miss个结果。 注意： 对于miss值的配置需要格外注意，miss值的设置主要考虑到可能由于转动速度过快导致有数据丢失的情况，但此补偿机制容易受设备信号质量影响。对于信号质量较差的设备，如毛刺较多，则不建议加入miss，否则可能出现“采样数据跳变”和“换向迟钝”的问题。对于此类设备，此处建议采用较大工作时钟，不加入miss进行采样。测试证明此种方式也可以有较为出色的采样效果。 对于miss值配置此处建议先加入较小的miss值（如miss=1）测试效果，如果有数据跳变或者换向迟钝则采用较大工作时钟（如HCLK时钟），不加miss进行采样。 开发者如果在调试qdec过程中出现数据跳变和换向迟钝的问题，建议进行以下几方面尝试： 1. 如选用sclk_slow作为时钟源，检查是否有配置pclk频率小于qdec工作频率 2. 改用较小工作时钟 3. 采用较小的miss值（如miss=1）和较大的filter值 4. 采用较大工作时钟（如HCLK时钟），不加miss进行采样 如果偶尔有较小的数据跳变，如5以内，则属于正常情况。 15.2.2 注意点 phase_a、phase_b引脚配置注意区分正反，交换引脚则得到相反的转向 配置pclk时钟可能会影响其他外设，请参考916时钟树进行正确配置 qdec采样快慢和时钟正相关，和qdec_clk_div大小无关，qdec_clk_div只控制对结果的上报频率 qdec上报结果会同时触发qdec中断或者DMA_REQ，qdec_clk_div设置过低会占用较多CPU资源 filter建议选择较大值，受毛刺影响较小，稳定性较好 15.3 编程指南 15.3.1 驱动接口 QDEC_QdecCfg：qdec标准配置接口 QDEC_EnableQdecDiv：qdec_clk_div设置使能接口 QDEC_ChannelEnable：qdec通道使能接口 QDEC_GetData：qdec获取数据接口 QDEC_GetDirection：qdec获取转向接口 QDEC_Reset：qdec复位接口 15.3.2 代码示例 下面一段代码展示了qdec全部配置并循环读数： static void QDEC_PclkCfg(void) { if ((APB_SYSCTRL-&gt;QdecCfg &gt;&gt; 15) &amp; 1) return; uint32_t hclk = SYSCTRL_GetHClk(); uint32_t slowClk = SYSCTRL_GetSlowClk(); uint8_t div = hclk / slowClk; if (hclk % slowClk) div++; if (!(div &gt;&gt; 4)) SYSCTRL_SetPClkDiv(div); } void test(void) { // setup qdec SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_PinCtrl | SYSCTRL_ITEM_APB_QDEC); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_PinCtrl | SYSCTRL_ITEM_APB_QDEC); PINCTRL_SelQDECIn(16, 17); // set GPIO16=phase_a, GPIO17=phase_b SYSCTRL_SelectQDECClk(SYSCTRL_CLK_SLOW, 100); QDEC_PclkCfg(); // set pclk not bigger than sclk_slow QDEC_EnableQdecDiv(QDEC_DIV_1024); QDEC_QdecCfg(50, 1); QDEC_ChannelEnable(1); // print qdec data and direction when rotate the mouse wheel manually uint16_t preData = 0; uint16_t data = 0; uint8_t dir; while(1) { data = QDEC_GetData(); dir = QDEC_GetDirection(); if (data != preData) { if (dir) { printf(&quot;data: %d, %s\\n&quot;, data, &quot;anticlockwise&quot;); } else { printf(&quot;data: %d, %s\\n&quot;, data, &quot;clockwise&quot;); } } preData = data; } } 当手动转动鼠标滚轮时，会打印出收到的qdec数据和转向。 qdec的详细使用请参考HID mouse例程。 "],["ch-rtc.html", "16 实时时钟（RTC） 16.1 功能描述 16.2 使用说明", " 16 实时时钟（RTC） 16.1 功能描述 实时时钟是一个独立的定时器。RTC模块拥有一组连续计数的计数器，在相应的软件配置下， 可提供时钟日历的功能。修改计数器的值可以重新设置系统当前的时间和日期。 16.2 使用说明 16.2.1 RTC使能 使用 RTC_Enable 使能RTC。 void RTC_Enable(uint8_t enable); 16.2.2 获取当前日期 使用 RTC_GetTime 获取当前时间（包括时分秒）。 uint16_t RTC_GetTime( uint8_t *hour, uint8_t *minute, uint8_t *second ); 16.2.3 修改日期 使用 RTC_ModifyTime 修改当前时间。 void RTC_ModifyTime( uint16_t day, uint8_t hour, uint8_t minute, uint8_t second ); 16.2.4 配置闹钟 使用 RTC_ConfigAlarm void RTC_ConfigAlarm( uint8_t hour, uint8_t minute, uint8_t second ); 16.2.5 配置中断请求 使用 RTC_EnableIRQ 配置并使能RTC中断请求。 void RTC_EnableIRQ(uint32_t mask); 其中的 mask 为RTC中断类型，一共有六种： typedef enum { RTC_IRQ_ALARM = 0x04, RTC_IRQ_DAY = 0x08, RTC_IRQ_HOUR = 0x10, RTC_IRQ_MINUTE = 0x20, RTC_IRQ_SECOND = 0x40, RTC_IRQ_HALF_SECOND = 0x80, } rtc_irq_t; 例如将 RTC 设置为alarm中断 RTC_EnableIRQ(RTC_IRQ_ALARM); 例如将 RTC 设置为day中断 RTC_EnableIRQ(RTC_IRQ_DAY); 例如将 RTC 设置为hour中断 RTC_EnableIRQ(RTC_IRQ_HOUR); 例如将 RTC 设置为minute中断 RTC_EnableIRQ(RTC_IRQ_MINUTE); 例如将 RTC 设置为second中断 RTC_EnableIRQ(RTC_IRQ_SECOND); 例如将 RTC 设置为half-second中断 RTC_EnableIRQ(RTC_IRQ_HALF_SECOND); 16.2.6 获取当前中断状态 使用 RTC_GetIntState 获取当前RTC的中断状态。 uint32_t RTC_GetIntState(void); 16.2.7 清除中断 使用 RTC_ClearIntState 清除当前RTC的中断状态。 void RTC_ClearIntState(uint32_t state); 16.2.8 处理中断状态 用 RTC_GetIntState 获取RTC上的中断触发，返回非 0 值表示RTC上产生了中断请求；RTC产生中断后， 需要消除中断状态方可再次触发。利用 RTC_ClearIntState可清除RTC的中断触发状态。 "],["spi功能概述.html", "17 SPI功能概述 17.1 SPI使用说明 17.2 场景1：只读只写不带DMA 17.3 场景2：只读只写并且使用DMA 17.4 场景3：同时读写不带DMA 17.5 场景4：同时读写并且使用DMA 17.6 SPI使用其他配置", " 17 SPI功能概述 两个SPI模块 支持SPI主&amp;从模式 支持Quad SPI，可以从外挂Flash执行代码 独立的RX&amp;TX FIFO，深度为8个word 支持DMA 17.1 SPI使用说明 以下场景中均以SPI1为例，如果需要SPI0则可以根据情况修改 17.2 场景1：只读只写不带DMA 其中SPI主配置为只写模式，SPI从配置为只读模式，CPU操作读写，没有使用DMA 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 17.2.1 SPI主配置 17.2.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 17.2.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考”peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_ONLY;// SPI只写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 17.2.1.3 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 17.2.1.4 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 填写数据到TX FIFO，这个例子中DATA_LEN等于FIFO的深度（8），如果大于8，可以分为多次发送 for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); } 17.2.1.5 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 17.2.2 SPI从配置 17.2.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 17.2.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考”peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_READ_ONLY;// SPI 只读 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 17.2.2.3 SPI 接收数据 uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1), i; if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { /* check if rx fifo still have some left data */ // 检查当前RX FIFO中有效值的个数，根据个数读取RX FIFO uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 17.2.2.4 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 观察SPI中断，中断触发代表当前传输结束 17.3 场景2：只读只写并且使用DMA 其中SPI主配置为只写模式，SPI从配置为只读模式，同时使用DMA进行读写 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 17.3.1 SPI主配置 17.3.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 17.3.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考”peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_ONLY;// SPI只写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 17.3.1.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 17.3.1.4 SPI DMA设置 // 此处是以SPI1为例 void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 17.3.1.5 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 17.3.1.6 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); // 初始化中已经设置了pParam.eWriteTransCnt，如果需要调整则可以调用这个API apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // DMA共有8个channel #define SPI_DMA_TX_CHANNEL (0)//DMA channel 0 // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 关闭 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,0); } 17.3.1.7 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 17.3.2 SPI从配置 17.3.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 17.3.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考”peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_READ_ONLY;// SPI 只读 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = 0; pParam.TxThres = 0; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 17.3.2.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 17.3.2.4 SPI DMA设置 // 此处是以SPI1为例 void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 17.3.2.5 SPI 接收数据 uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 打开SPI DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); // 功能等同于重新设置pParam.eReadTransCnt，代表一次传输的单位个数 apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); #define SPI_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 17.3.2.6 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { peripherals_spi_read_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 17.3.2.7 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 设置接收DMA，peripherals_spi_read_data() 观察SPI中断，中断触发代表当前接收结束 17.4 场景3：同时读写不带DMA 其中SPI主从都配置为同时读写模式，CPU操作读写，没有使用DMA 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 17.4.1 SPI主配置 17.4.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 17.4.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考”peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 17.4.1.3 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 17.4.1.4 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 填写数据到TX FIFO，这个例子中DATA_LEN等于FIFO的深度（8），如果大于8，可以分为多次发送接收， // 每次发送完8个单位，需要读取RX FIFO中的数据 for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 读取当前RX FIFO中有效值的个数，然后从RX FIFO中读取返回值 uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } } 17.4.1.5 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 17.4.2 SPI从配置 17.4.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 17.4.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考”peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 17.4.2.3 SPI 接收数据 void peripherals_spi_push_data(void) { for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } } uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1), i; if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { /* check if rx fifo still have some left data */ // 检查当前RX FIFO中有效值的个数，根据个数读取RX FIFO uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } // 根据需要填充下一次发送的SPI数据 peripherals_spi_push_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 17.4.2.4 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 根据需要填充TX FIFO，peripherals_spi_push_data() 观察SPI中断，中断触发代表当前传输结束 17.5 场景4：同时读写并且使用DMA 其中SPI主从配置为同时读写模式，同时使用DMA进行读写 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 // RX FIFO 和 TX FIFO 使用两个DMA channel #define SPI_DMA_TX_CHANNEL (0)//DMA channel 0 #define SPI_DMA_RX_CHANNEL (1)//DMA channel 1 17.5.1 SPI主配置 17.5.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 17.5.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考”peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 17.5.1.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 17.5.1.4 SPI DMA设置 // 此处是以SPI1为例 // 分别设置RX FIFO 和 TX FIFO的DMA void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 17.5.1.5 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 17.5.1.6 SPI 接收数据 uint32_t read_data[DATA_LEN] = {0,};//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向存储接收数据的地址 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 17.5.1.7 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_push_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); } void peripherals_spi_send_data(void) { // 分别设置接收和发射的DMA peripherals_spi_read_data(); peripherals_spi_push_data(); // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 关闭 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,0); } 17.5.1.8 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 17.5.2 SPI从配置 17.5.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 17.5.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考”peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = 0; pParam.TxThres = 0; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 17.5.2.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 17.5.2.4 SPI DMA设置 // 此处是以SPI1为例 // 分别设置RX FIFO 和 TX FIFO的DMA void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 17.5.2.5 SPI 接收数据 uint32_t read_data[DATA_LEN] = {0,};//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向存储接收数据的地址 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 17.5.2.6 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_push_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); } 17.5.2.7 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { // 根据情况决定是否需要准备下一次的接收和发射 peripherals_spi_read_data(); peripherals_spi_push_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 17.5.2.8 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 设置接收DMA，peripherals_spi_read_data(); 设置发射DMA，peripherals_spi_push_data(); 观察SPI中断，中断触发代表当前接收结束 17.6 SPI使用其他配置 17.6.1 SPI clock配置 17.6.1.1 默认配置 对于默认配置，spi时钟的配置通过 “pParam.eSclkDiv” 来实现，计算公式为： “spi interface clock / (2 * (eSclkDiv + 1))”，其中默认配置下，spi interface clock 为24M，因此可以得到不同时钟下的eSclkDiv： #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_6M (1) #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_4M (2) #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_3M (3) #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M4 (4) #define SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M (5) 详细请参考”peripheral_ssp.h” 17.6.1.2 HCLK配置 对于更高的时钟，则需要在配置”pParam.eSclkDiv”之前打开HCLK配置，打开方式如下： SYSCTRL_SelectHClk(SYSCTRL_CLK_PLL_DIV_1+3); SYSCTRL_SelectSpiClk(SPI_PORT_1,SYSCTRL_CLK_HCLK); 其中PLL为384M，“SYSCTRL_CLK_PLL_DIV_1+3”代表4分频（推荐配置），可以将spi interface clock 提高到384M/4 = 96M。在此基础上通过计算公式”spi interface clock / (2 * (eSclkDiv + 1))” 得到不同时钟下的eSclkDiv： #define SPI_INTERFACETIMINGSCLKDIV_HCLK_24M (1) #define SPI_INTERFACETIMINGSCLKDIV_HCLK_12M (3) 详细请参考”peripheral_ssp.h” 其中spi interface clock的大小可以在配置后，通过”SYSCTRL_GetClk()“来获取 ATTENTION : 此处的API使用均以SPI1（SPI_PORT_1）为例，具体使用请根据需要调整 17.6.2 QSPI 使用 QSPI的使用需要在以上的配置的基础上，做一些额外修改 #### pin 配置 QSPI用到了CLK,CS,MOSI,MISO,HOLD,WP,主从都需要配置为输入输出 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); PINCTRL_SetPadMux(SPI_MIC_WP, IO_SOURCE_SPI1_WP_OUT); PINCTRL_SetPadMux(SPI_MIC_HOLD, IO_SOURCE_SPI1_HOLD_OUT); 17.6.2.1 pParam 配置 QSPI的部分pParam参数需要修改为如下，同时Addr和Cmd需要打开 pParam.eQuadMode = SPI_DUALQUAD_QUAD_IO_MODE; pParam.SlaveDataOnly = SPI_SLVDATAONLY_DISABLE; pParam.eAddrEn = SPI_ADDREN_ENABLE; pParam.eCmdEn = SPI_CMDEN_ENABLE; 此外，主还需要切换读写Mode（读和写顺序执行，比如首先利用四线完成写操作，然后再读） pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ; 或者（在Write和Read之间添加dummy（默认为8个clk cycle）） pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_DUMMY_READ; 从则添加 pParam.eReadWriteMode = SPI_TRANSMODE_READ_WRITE; 或者（在Read和Write之间添加dummy（默认为8个clk cycle）） pParam.eReadWriteMode = SPI_TRANSMODE_READ_DUMMY_WRITE; "],["ch-sysctrl.html", "18 系统控制（SYSCTRL） 18.1 功能概述 18.2 使用说明", " 18 系统控制（SYSCTRL） 18.1 功能概述 SYSCTRL 负责管理、控制各种片上外设，主要功能有： 外设的复位 外设的时钟管理，包括时钟源、频率设置、门控等 DMA 规划 其它功能 18.1.1 外设标识 SYSCTRL 为外设定义了几种不同的标识。最常见的一种标识为： typedef enum { SYSCTRL_ITEM_APB_GPIO0 , SYSCTRL_ITEM_APB_GPIO1 , // ... SYSCTRL_ITEM_NUMBER, } SYSCTRL_Item; 这种标识用于外设的复位、时钟门控等。SYSCTRL_ResetItem 和 SYSCTRL_ClkGateItem 是 SYSCTRL_Item 的两个别名。 下面这种标识用于 DMA 规划： typedef enum { SYSCTRL_DMA_UART0_RX = 0, SYSCTRL_DMA_UART1_RX = 1, //... } SYSCTRL_DMA; 18.1.2 时钟树 从源头看，共有 4 个时钟源： 内部 32KiHz RC 时钟； 外部 32768Hz 晶体； 内部高速 RC 时钟（8M/16M/24M/32M/48M/64MHz 可调）； 外部 24MHz 晶体。 从 4 个时钟源出发，得到两组时钟： 32KiHz 时钟（clk_32k） 32k 时钟有两个来源：内部 32KiHz RC 电路，外部 32768Hz 晶体。 慢时钟 慢时钟有两个来源：内部高速 RC 时钟，外部 24MHz 晶体。 BLE 子系统中射频相关的部分固定使用外部 24MHz 晶体提供的时钟。 之后， PLL 输出（clk_pll） clk_pll 的频率 \\(f_{pll}\\) 可配置，受 \\(loop\\)、\\(div_{pre}\\) 和 \\(div_{output}\\) 等 3 个参数控制： \\[f_{vco}=\\frac{f_{in}\\times loop}{div_{pre}}\\] \\[f_{pll}=\\frac{f_{vco}}{div_{output}}\\] 这里，\\(f_{in}\\) 即慢时钟。要求 \\(f_{vco} \\in [60,600]MHz\\)， \\(f_{in}/div_{pre} \\in [2,24]MHz\\)。 sclk_fast 与 sclk_slow clk_pll 经过门控后的时钟称为 sclk_fast，慢时钟经过门控后称为 sclk_slow。 hclk sclk_fast 经过分频后得到 hclk。下列外设（包括 CPU）固定使用这个时钟4： DMA 片内 Flash QSPI USB5 其它内部模块如 AES、Cache 等 hclk 经过分频后得到 pclk。pclk 主要用于硬件内部接口。 sclk_slow 的进一步分频 sclk_slow 经过若干独立的分频器得到以下多种时钟： sclk_slow_pwm_div：专供 PWM 选择使用 sclk_slow_timer_div：供 TIMER0、TIMER1、TIMER2 选择使用 sclk_slow_ks_div：专供 KeyScan 选择使用 sclk_slow_adc_div：供 EFUSE、ADC、IR 选择使用 sclk_slow_pdm_div：专供 PDM 选择使用 sclk_fast 的进一步分频： sclk_fast 经过若干独立的分频器得到以下多种时钟： sclk_fast_i2s_div：专供 I2S 选择使用 sclk_fast_qspi_div：专供 SPI0 选择使用 sclk_fast_flash_div：专供片内 Flash 选择使用 sclk_fast_usb_div：专供 USB 使用 各硬件外设可配置的时钟源汇总如表 18.1。 表 18.1: 各硬件外设的时钟源 外设 时钟源 GPIO0、GPIO1 选择 sclk_slow 或者 clk_32k TMR0、TMR1、TMR2 独立配置 sclk_slow_timer_div 或者 clk_32k WDT clk_32k PWM sclk_slow_pwm_div 或者 clk_32k PDM sclk_slow_pdm_div QDEC 对 hclk 或者 sclk_slow KeyScan sclk_slow_ks_div 或者 clk_32k IR、ADC、EFUSE 独立配置 sclk_slow_adc_div 或者 sclk_slow DMA hclk SPI0 sclk_fast_qspi_div 或者 sclk_slow I2S sclk_fast_i2s_div 或者 sclk_slow UART0、UART1、SPI1 独立配置 hclk 或者 sclk_slow I2C0、I2C1 pclk 18.1.3 DMA 规划 由于 DMA 支持的硬件握手信号只有 16 种，无法同时支持所有外设。 因此需要事先确定将要的外设握手信号，并通过 SYSCTRL_SelectUsedDmaItems 接口声明。 一个外设可能具备一个以上的握手信号，需要注意区分。比如 UART0 有两个握手信号 UART0_RX 和 UART0_TX，分别用于触发 DMA 发送请求（通过 DMA 传输接收到的数据）和读取请求（向 DMA 请 求新的待发送数据）。外设握手信号定义在 SYSCTRL_DMA 内： typedef enum { SYSCTRL_DMA_UART0_RX = 0, SYSCTRL_DMA_UART1_RX = 1, // ... } SYSCTRL_DMA; 18.2 使用说明 18.2.1 外设复位 通过 SYSCTRL_ResetBlock 复位外设，通过 SYSCTRL_ReleaseBlock 释放复位。 void SYSCTRL_ResetBlock(SYSCTRL_ResetItem item); void SYSCTRL_ReleaseBlock(SYSCTRL_ResetItem item); 18.2.2 时钟门控 通过 SYSCTRL_SetClkGate 设置门控（即关闭时钟），通过 SYSCTRL_ClearClkGate 消除门控（即恢复时钟）。 void SYSCTRL_SetClkGate(SYSCTRL_ClkGateItem item); void SYSCTRL_ClearClkGate(SYSCTRL_ClkGateItem item); SYSCTRL_SetClkGateMulti 和 SYSCTRL_ClearClkGateMulti 可以同时控制多个外设的门控。 items 参数里的各个比特与 SYSCTRL_ClkGateItem 里的各个外设一一对应。 void SYSCTRL_SetClkGateMulti(uint32_t items); void SYSCTRL_ClearClkGateMulti(uint32_t items); 18.2.3 时钟配置 举例如下。 clk_pll 与 hclk 使用 SYSCTRL_ConfigPLLClk 配置 clk_pll： int SYSCTRL_ConfigPLLClk( uint32_t div_pre, uint32_t loop, uint32_t div_output); 例如，假设慢时钟配置为 24MHz，下面的代码将 hclk 配置为 220MHz 并读取到变量： SYSCTRL_ConfigPLLClk(6, 110, 1); SYSCTRL_SelectHClk(SYSCTRL_CLK_PLL_DIV_1 + 1); uint32_t SystemCoreClock = SYSCTRL_GetHClk(); 为硬件 I2S 配置时钟 使用 SYSCTRL_SelectI2sClk 为 I2S 配置时钟： void SYSCTRL_SelectI2sClk(SYSCTRL_ClkMode mode); SYSCTRL_ClkMode 的定为为： typedef enum { SYSCTRL_CLK_SLOW, // 使用 sclk_slow SYSCTRL_CLK_32k = ..., // 使用 32KiHz 时钟 SYSCTRL_CLK_HCLK, // 使用 hclk SYSCTRL_CLK_ADC_DIV = ..., // 使用 sclk_slow_adc_div SYSCTRL_CLK_PLL_DIV_1 = ..., // 对 sclk_fast 分频 SYSCTRL_CLK_SLOW_DIV_1 = ..., // 对 sclk_slow 分配 } SYSCTRL_ClkMode; 根据表 18.1 可知，I2S 可使用 _slk_slow： SYSCTRL_SelectI2sClk(SYSCTRL_CLK_SLOW); 或者独占一个分频器，对 sclk_fast 分频得到 sclk_fast_i2s_div，比如使用 sclk_fast 的 56 分频： SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_1 + 4); 读取时钟频率 使用 SYSCTRL_GetClk 可获得指定外设的时钟频率： uint32_t SYSCTRL_GetClk(SYSCTRL_Item item); 比如， // I2S 使用 PLL 的 5 分频 SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_1 + 4); // freq = sclk_fast 的频率 / 5 uint32_t freq = SYSCTRL_GetClk(SYSCTRL_ITEM_APB_I2S); 降低频率以节省功耗 降低系统各时钟的频率可以显著降低动态功耗。相关函数有： SYSCTRL_SelectHClk：选择 hclk SYSCTRL_SelectFlashClk：选择内部 Flash 时钟 SYSCTRL_SelectSlowClk：选择慢时钟 SYSCTRL_EnablePLL：开关 PLL 配置用于慢时钟的高速 RC 时钟 通过 SYSCTRL_EnableSlowRC 可以使能并配置内部高速 RC 时钟的频率模式： void SYSCTRL_EnableSlowRC( uint8_t enable, // 使能或禁用 SYSCTRL_SlowRCClkMode mode // 频率模式 ); 频率模式为： typedef enum { SYSCTRL_SLOW_RC_8M = ..., SYSCTRL_SLOW_RC_16M = ..., SYSCTRL_SLOW_RC_24M = ..., SYSCTRL_SLOW_RC_32M = ..., SYSCTRL_SLOW_RC_48M = ..., SYSCTRL_SLOW_RC_64M = ..., } SYSCTRL_SlowRCClkMode; 由于内部（芯片之间）、外部环境（温度）存在微小差异或变化，所以这个 RC 时钟的频率或存在一定误差， 需要通过进行调谐以尽量接近标称值。通过 SYSCTRL_AutoTuneSlowRC 可进行自动调谐7： uint32_t SYSCTRL_AutoTuneSlowRC(void); 这个函数返回的数据为调谐参数。如果认为有必要8，可以把此参数储存起来，后续系统重启后， 通过 SYSCTRL_TuneSlowRC 直接写入参数调谐频率。 温馨提示： 关闭 PLL 时，务必先将 CPU、Flash 时钟切换至慢时钟； 修改慢时钟配置时，需要保证 PLL 的输出、CPU 时钟等在支持的频率内； 推荐使用 SDK 提供的工具生成时钟配置代码，规避错误配置。 18.2.4 DMA 规划 使用 SYSCTRL_SelectUsedDmaItems 配置要使用的 DMA 握手信号： int SYSCTRL_SelectUsedDmaItems( uint32_t items // 各比特与 SYSCTRL_DMA 一一对应 ); 使用 SYSCTRL_GetDmaId 可获取为某外设握手信号的 DMA 信号 ID，如果返回 -1， 说明没有规划该外设握手信号9： int SYSCTRL_GetDmaId(SYSCTRL_DMA item); 18.2.5 电源相关 18.2.5.1 内核电压 使用 SYSCTRL_SetLDOOutput 配置内核 LDO 的输出电压（默认 \\(1.200V\\)）： void SYSCTRL_SetLDOOutput(int level); 其中 level 的表示方式为 SYSCTRL_LDO_OUTPUT_CORE_1V000、……、 SYSCTRL_LDO_OUTPUT_CORE_1V300，对应的电压范围是 \\([1.000 V, 1.300 V]\\)，以 \\(20mV\\) 步进。 此配置在低功耗模式下不会丢失。 18.2.5.2 内置 Flash 电压 使用 SYSCTRL_SetLDOOutputFlash 配置内部 Flash LDO 的输出电压（默认 \\(2.100V\\)）： void SYSCTRL_SetLDOOutputFlash(int level); 其中 level 的表示方式为 SYSCTRL_LDO_OUTPUT_FLASH_2V100、……、 SYSCTRL_LDO_OUTPUT_FLASH_3V100，对应的电压范围是 \\([2.100 V, 3.100 V]\\)，以 \\(100mV\\) 步进。 此配置在低功耗模式下不会丢失。 每个外设可单独对 hclk 门控。↩︎ 仅高速时钟。↩︎ \\(5=1 + 4\\)↩︎ 以 24MHz 晶体为参考。↩︎ 比如认为 SYSCTRL_AutoTuneSlowRC 耗时过长。↩︎ SYSCTRL_SelectUsedDmaItems 的 items 参数里对应的比特为 0↩︎ "],["ch-timer.html", "19 定时器（TIMER） 19.1 功能概述 19.2 使用说明", " 19 定时器（TIMER） 19.1 功能概述 定时器（TIMER）是由两个寄存器组成的，其中一个寄存器用来确定计数器的工作形式和功能， 另外一个计时器是用来控制单片机的启动和停止的，同时也设置了一个 19.2 使用说明 19.2.1 设置工作模式 在使用 TIMER 之前，需要使用 TMR_SetOpMode 按需设置TIMER的工作模式。 void TMR_SetOpMode( TMR_TypeDef *pTMR, uint8_t ch_id, uint8_t op_mode, uint8_t clk_mode, uint8_t pwm_park_value ); TIMER的工作模式有以下6种，分别三类：定时器、PWM、复用。 * 定时器功能包括：32bit单定时器、16bit双定时器、8bit四定时器 ```c #define TMR_CTL_OP_MODE_32BIT_TIMER_x1 1 // one 32bit timer #define TMR_CTL_OP_MODE_16BIT_TIMER_x2 2 // dual 16bit timers #define TMR_CTL_OP_MODE_8BIT_TIMER_x4 3 // four 8bit timers * PWM功能：16bit双计数器 ```c #define TMR_CTL_OP_MODE_16BIT_PWM 4 // PWM with two 16bit counters 定时器+PWM复用功能：8bit双计数器+16bit单定时器、 8bit双计数器+8bit双定时器 #define TMR_CTL_OP_MODE_8BIT_PWM_16BIT_TIMER_x1 6 // MIXED: PWM with two 8bit counters + one 16bit timer #define TMR_CTL_OP_MODE_8BIT_PWM_8BIT_TIMER_x2 7 // MIXED: PWM with two 8bit counters + dual 8bit timer 例如将TIMER1的通道0设置为TMR_CTL_OP_MODE_32BIT_TIMER_x1模式： TMR_SetOpMode(APB_TMR1, 0, TMR_CTL_OP_MODE_32BIT_TIMER_x1, TMR_CLK_MODE_APB, 0); TMR_SetReload(APB_TMR1, 0, TMR_GetClk(APB_TMR1, 0) / 10); TMR_Enable(APB_TMR1, 0, 0xf); TMR_IntEnable(APB_TMR1, 0, 0xf); 19.2.2 时钟频率 使用 TMR_GetClk 获取TIMER某个通道的时钟频率。 uint32_t TMR_GetClk( TMR_TypeDef *pTMR, uint8_t ch_id ); 19.2.3 重载值 使用 TMR_SetReload 设置TIMER某个通道的重载值。 void TMR_SetReload( TMR_TypeDef *pTMR, uint8_t ch_id, uint32_t value ); 在不同的TIMER模式中， value 的值分配如下表。 Table: (#tab:ch0-abbreviations) TIMER模式 bits[0:7] bits[8:15] bits[16:23] bits[24:31] TMR_CTL_OP_MODE_32BIT_TIMER_x1 Timer 0 Timer 0 Timer 0 Timer 0 TMR_CTL_OP_MODE_16BIT_TIMER_x2 Timer 0 Timer 0 Timer 1 Timer 1 TMR_CTL_OP_MODE_8BIT_TIMER_x4 Timer 0 Timer 1 Timer 2 Timer 3 TMR_CTL_OP_MODE_16BIT_PWM PWM low period PWM low period PWM high period PWM high period TMR_CTL_OP_MODE_8BIT_PWM_16BIT_TIMER_x1 Timer 0 Timer 0 PWM low period PWM low period TMR_CTL_OP_MODE_8BIT_PWM_8BIT_TIMER_x2 Timer 0 Timer 1 PWM low period PWM low period 19.2.4 使能 使用 TMR_Enable TIMER的某个通道。 void TMR_Enable( TMR_TypeDef *pTMR, uint8_t ch_id, uint8_t mask ); 19.2.5 比较 使用 TMR_GetCMP 。 uint32_t TMR_GetCMP( TMR_TypeDef *pTMR, uint8_t ch_id ); 19.2.6 配置中断请求 使用 TMR_IntEnable 配置并使能TIMER中断。 void TMR_IntEnable( TMR_TypeDef *pTMR, uint8_t ch_id, uint8_t mask ); 19.2.7 中断清除 使用 TMR_IntClr 清除某个TIMER的中断状态。 void TMR_IntClr( TMR_TypeDef *pTMR, uint8_t ch_id, uint8_t mask ); 19.2.8 获取中断 使用 TMR_IntHappened 获取某个TIMER的中断状态。 uint8_t TMR_IntHappened( TMR_TypeDef *pTMR, uint8_t ch_id ); "],["ch-uart.html", "20 通用异步收发传输器（UART） 20.1 功能概述 20.2 使用说明", " 20 通用异步收发传输器（UART） 20.1 功能概述 UART负责处理数据总线和串行口之间的串/并、并/串转换，并规定了相应的帧格式，通信双方只要采用相同的帧格式和波特率， 就能在未共享时钟信号的情况下，仅用两根信号线（RX和TX）完成通信过程。 特性： 异步串行通信，可为全双工、半双工、单发送（TX）或单接收（RX）模式； 支持5~8位数据位的配置，波特率几百bps至几百Kbbps； 可配置奇校验、偶校验或无校验位；可配置1、1.5或2位停止位； 将并行数据写入内存缓冲区，再通过FIFO逐位发送，接收时同理； 输出传输时，从低位到高位传输。 20.2 使用说明 20.2.1 设置波特率 使用 apUART_BaudRateSet 设置对应UART设备的波特率。 void apUART_BaudRateSet( UART_TypeDef* pBase, uint32_t ClockFrequency, uint32_t BaudRate ); 20.2.2 获取波特率 使用 apUART_BaudRateGet 获取对应UART设备的波特率。 uint32_t apUART_BaudRateGet ( UART_TypeDef* pBase, uint32_t ClockFrequency ); 20.2.3 接收错误查询 使用 apUART_Check_Rece_ERROR 查询接收产生的错误。 uint8_t apUART_Check_Rece_ERROR( UART_TypeDef* pBase ); 20.2.4 FIFO轮询模式 在轮询模式下，CPU通过检查线路状态寄存器中的位来检测事件： 使用 apUART_Check_Rece_ERROR 查询接收产生的错误字。 uint8_t apUART_Check_Rece_ERROR( UART_TypeDef* pBase ); 用 apUART_Check_RXFIFO_EMPTY查询RXFIFO是否为空。 uint8_t apUART_Check_RXFIFO_EMPTY( UART_TypeDef* pBase ); 使用 apUART_Check_RXFIFO_FULL查询RXFIFO是否已满。 uint8_t apUART_Check_RXFIFO_FULL( UART_TypeDef* pBase ); 使用 apUART_Check_TXFIFO_EMPTY 查询TXFIFO是否为空。 uint8_t apUART_Check_TXFIFO_EMPTY( UART_TypeDef* pBase ); 使用 apUART_Check_TXFIFO_FULL 查询TXFIFO是否已满。 uint8_t apUART_Check_TXFIFO_FULL( UART_TypeDef* pBase ); 20.2.5 发送数据 使用 UART_SendData 发送8bits数据。 void UART_SendData( UART_TypeDef* pBase, uint8_t Data ); 20.2.6 接收数据 使用 UART_ReceData 接收8bits数据。 uint8_t UART_ReceData( UART_TypeDef* pBase ); 20.2.7 配置中断请求 使用 apUART_Enable_TRANSMIT_INT 使能发送中断状态。 void apUART_Enable_TRANSMIT_INT( UART_TypeDef* pBase ); 使用 apUART_Disable_TRANSMIT_INT 禁用发送中断状态。 void apUART_Disable_TRANSMIT_INT( UART_TypeDef* pBase ); 使用 apUART_Enable_RECEIVE_INT 使能接收中断状态。 void apUART_Enable_RECEIVE_INT( UART_TypeDef* pBase ); 使用 apUART_Disable_RECEIVE_INT 禁用接收中断状态。 void apUART_Disable_RECEIVE_INT( UART_TypeDef* pBase ); 20.2.8 处理中断状态 uint8_t apUART_Get_ITStatus(UART_TypeDef* pBase,uint8_t UART_IT); uint32_t apUART_Get_all_raw_int_stat(UART_TypeDef* pBase); void apUART_Clr_RECEIVE_INT(UART_TypeDef* pBase); void apUART_Clr_TX_INT(UART_TypeDef* pBase); void apUART_Clr_NonRx_INT(UART_TypeDef* pBase); 20.2.9 UART初始化 两个设备使用UART通讯时，必须先约定好传输速率和一些数据位。 typedef struct UART_xStateStruct { // Line Control Register, UARTLCR_H UART_eWLEN word_length; // WLEN UART_ePARITY parity; // PEN, EPS, SPS uint8_t fifo_enable; // FEN uint8_t two_stop_bits; // STP2 // Control Register, UARTCR uint8_t receive_en; // RXE uint8_t transmit_en; // TXE uint8_t UART_en; // UARTEN uint8_t cts_en; //CTSEN uint8_t rts_en; //RTSEN // Interrupt FIFO Level Select Register, UARTIFLS uint8_t rxfifo_waterlevel; // RXIFLSEL uint8_t txfifo_waterlevel; // TXIFLSEL //UART_eFIFO_WATERLEVEL rxfifo_waterlevel; // RXIFLSEL //UART_eFIFO_WATERLEVEL txfifo_watchlevel; // TXIFLSEL // UART Clock Frequency uint32_t ClockFrequency; uint32_t BaudRate; } UART_sStateStruct; 定义函数 config_uart , void config_uart( uint32_t freq, uint32_t baud ); 在函数中，对UART_sStateStruct的各项参数初始化，并调用 apUART_Initialize 对UART进行初始化。 void config_uart(uint32_t freq, uint32_t baud) { UART_sStateStruct config; config.word_length = UART_WLEN_8_BITS; config.parity = UART_PARITY_NOT_CHECK; config.fifo_enable = 1; config.two_stop_bits = 0; config.receive_en = 1; config.transmit_en = 1; config.UART_en = 1; config.cts_en = 0; config.rts_en = 0; config.rxfifo_waterlevel = 1; config.txfifo_waterlevel = 1; config.ClockFrequency = freq; config.BaudRate = baud; apUART_Initialize(PRINT_PORT, &amp;config, 0); } 20.2.10 发送数据 使用 UART_SendData 发送数据。 void UART_SendData( UART_TypeDef* pBase, uint8_t Data ); 20.2.11 接收数据 使用 UART_ReceData 接收数据。 uint8_t UART_ReceData( UART_TypeDef* pBase ); 20.2.12 清空FIFO 使用 uart_empty_fifo 清空UART的FIFO。 static void uart_empty_fifo( UART_TypeDef* pBase ); 20.2.13 使能FIFO 使用 uart_enable_fifo 使能UART的FIFO。 static void uart_enable_fifo( UART_TypeDef* pBase ); 20.2.14 处理中断状态 用 apUART_Get_ITStatus 获取某个UART上的中断触发状态，返回非 0 值表示该 UART 上产生了中断请求；用 apUART_Get_all_raw_int_stat 一次性获取所有 UART 的中断触发状态， 第 \\(n\\) 比特（第 0 比特为最低比特）对应 UART \\(n\\) 上的中断触发状态。 UART产生中断后，需要消除中断状态方可再次触发。用 apUART_Clr_RECEIVE_INT 消除某个 UART上接收中断的状态， 用 apUART_Clr_TX_INT 消除某个 UART上发送中断的状态。用 apUART_Clr_NonRx_INT 消除某个 UART上除接收以外的中断状态。 20.2.15 DMA传输模式使能 DMA向CPU发出总线请求，CPU将总线交给DMA之后，由DMA控制数据的收发工作。 使用 UART_DmaEnable使能DMA工作模式。 void UART_DmaEnable( UART_TypeDef *pBase, uint8_t tx_enable, uint8_t rx_enable, uint8_t dma_on_err ); "],["universal-serial-bus-deviceusb.html", "21 Universal serial bus device（USB） 21.1 功能概述 21.2 使用说明", " 21 Universal serial bus device（USB） 21.1 功能概述 支持full-speed (12 Mbps) device模式 集成PHY Transceiver，内置上拉，软件可控 Endpoints: Endpoints 0: control endpoint Endpoints 1-5: 可以配置为in/out，以及control/isochronous/bulk/interrupt 支持USB suspend, resume, remote-wakeup 内置DMA方便数据传输 21.2 使用说明 21.2.1 USB软件结构 driver layer，USB的底层处理，不建议用户修改。 处理了大部分和应用场景无关的流程，提供了USB_IrqHandler，调用event handler。 位置：\\ING\\_SDK\\sdk\\src\\FWlib\\peripheral\\_usb.c bsp layer，处理场景相关的流程，需要用户提供event handler，并实现control和transfer相关处理。 位置：\\ING\\_SDK\\sdk\\src\\BSP\\bsp\\_usb_xxx.c 21.2.2 USB Device 状态 USB的使用首先需要配置USB CLK，USB IO以及PHY，并且初始化USB模块，此时USB为”NONE”状态，等待USB的reset中断（USB_IrqHandler）。 reset中断的触发代表USB cable已经连接，而且host已经检测到了device，在reset中断中，USB模块完成相关的USB初始化。并继续等待中断。 enumeration中断的触发代表device可以开始接收SOF以及control传输，device需要配置并打开endpoint 0，进入”DEFAULT”状态。 out中断的触发代表收到了host的get descriptor，用户需要准备好相应的descriptor，并配置相关的in endpoint。 out中断中的set address request会将device的状态切换为”ADDRESS”。 out中断中的set configuration会将device的状态切换为”CONFIGURED”。此时device可以开始在配置的endpoint上传输数据。 bus上的idle会自动触发suspend中断（用户需要在初始化中使能suspend中断），此时切换为”SUSPEND”状态。 idle之后任何bus上的活动将会触发resume中断（用户需要在初始化中使能resume中断）,用户也可以选择使用remote wakeup主动唤醒。 唤醒之后的usb将重新进入”CONFIGURED”状态，每1m（full-speed）将会收到1个SOF中断（用户需要在初始化中使能sof中断）。 typedef enum { USB_DEVICE_NONE, /* A USB device may be attached or detached from the USB */ USB_DEVICE_ATTACHED, /*USB devices may obtain power from an external source */ USB_DEVICE_POWERED, /* After the device has been powered, and reset is done */ USB_DEVICE_DEFAULT, /* All USB devices use the default address when initially powered or after the device has been reset. Each USB device is assigned a unique address by the host after attachment or after reset. */ USB_DEVICE_ADDRESS, /* Before a USB device function may be used, the device must be configured. */ USB_DEVICE_CONFIGURED, /* In order to conserve power, USB devices automatically enter the Suspended state when the device has observed no bus traffic for a specified period */ USB_DEVICE_SUSPENDED, USB_DEVICE_TEST_RESET_DONE }USB_DEVICE_STATE_E; 21.2.3 设置 IO 对于Ing91682,USB的DP/DM固定在GPIO16/17,IO初始化细节请参考ING_SDK\\sdk\\src\\BSP\\bsp\\_usb.c中的bsp_usb_init() // ATTENTION ! FIXED IO FOR USB on 916 series #define USB_PIN_DP GIO_GPIO_16 #define USB_PIN_DM GIO_GPIO_17 21.2.4 设置 PHY 使用SYSCTRL_USBPhyConfig()初始化PHY, 细节请参考ING_SDK\\sdk\\src\\BSP\\bsp\\_usb.c中的bsp_usb_init() /** * @brief Config USB PHY functionality * * @param[in] enable Enable(1)/Disable(0) usb phy module * @param[in] pull_sel DP pull up(0x1)/DM pull up(0x2)/DP&amp;DM pull down(0x3) */ void SYSCTRL_USBPhyConfig(uint8_t enable, uint8_t pull_sel); 21.2.5 USB 模块初始化 细节请参考ING_SDK\\sdk\\src\\BSP\\bsp\\_usb.c中的bsp_usb_init()。 USB模块首选需要打开USB中断并配置相应接口，其中USB_IrqHandler由driver提供不需要用户修改。 platform_set_irq_callback(PLATFORM_CB_IRQ_USB, USB_IrqHandler, NULL); 其次需要初始化USB模块以及相关状态信息，入参结构体中用户需要提供event handler，其余为可选项 /** * @brief interface API. initilize usb module and related variables, must be called before any usb usage * * @param[in] device callback function with structure USB_INIT_CONFIG_T. * When this function has been called your device is ready to be enumerated by the USB host. * @param[out] null. */ extern USB_ERROR_TYPE_E USB_InitConfig(USB_INIT_CONFIG_T *config); 21.2.6 event handler USB的用户层调用通过event handler来实现， 细节请参考ING_SDK\\sdk\\src\\BSP\\bsp\\_usb.c中的bsp_usb_event_handler()。 event handler需要包含对以下event事件的处理： USB_EVENT_EP0_SETUP 该event包含EPO(control endpoint)上的所有request，包括读取/设置 descriptor，设置address，set/clear feature等request，按照USB协议，device需要支持所有协议中的标准request。 descriptor需要按照协议格式准备，并且放置在4bytes对齐的全局地址，并通过USB_SendData()发送给host，在整个过程中，该全局地址和数据需要保持。（4bytes对齐是内部DMA搬运的要求，否则可能出现错误）。 对于没有data stage的request，event handler中不需要使用USB_SendData()/USB_RecvData()’。 对于不支持的request，需要设置status为： status = USB_ERROR_REQUEST_NOT_SUPPORT; 根据返回的status，driver判断当前request是否支持，否则按照协议发送stall给host。 对于包含data stage的out传输，driver将继续接收数据，数据将在USB_EVENT_EP_DATA_TRANSFER的ep0通知用户。 setup/data/status stage的切换将在driver内进行。 USB_EVENT_EP_DATA_TRANSFER 数据相关的处理，接收和发射数据。 参数包含ep number uint8_t ep; 以及数据处理类型，分别代表发送和接收transfer的结束。 typedef enum { /// Event send when a receive transfert is finish USB_CALLBACK_TYPE_RECEIVE_END, /// Event send when a transmit transfert is finish USB_CALLBACK_TYPE_TRANSMIT_END } USB_CALLBACK_EP_TYPE_T; USB_EVENT_DEVICE_RESET USB reset 中断的event，代表枚举的开始。 USB_EVENT_DEVICE_SOF SOF中断，每1m（full-speed）将会收到1个SOF中断（用户需要在初始化中使能sof中断）。 USB_EVENT_DEVICE_SUSPEND bus 进入idle状态后触发suspend，此时总线上没有USB活动。driver会关闭phy clock。 USB_EVENT_DEVICE_RESUME bus 上的任何USB活动将会触发wakeup中断。resume后driver打开phy clock，USB恢复到正常状态。 21.2.6.1 USB_EVENT_EP0_SETUP的实现 control以及枚举相关的流程实现需要通过USB_EVENT_EP0_SETUP event来进行。 默认的control endpoint是ep0, 所有request都会触发该event 如果场景不支持某个request，则需要设置status == USB_ERROR_REQUEST_NOT_SUPPORT。driver会据此发送stall。 如果场景需要处理某个request，则需要将status设置为非USB_ERROR_REQUEST_NOT_SUPPORT状态。 用户需要将所有descriptor保存在4bytes对齐的全局地址。以device descriptor为例 case USB_REQUEST_DEVICE_DESCRIPTOR_DEVICE: { size = sizeof(USB_DEVICE_DESCRIPTOR_REAL_T); size = (setup-&gt;wLength &lt; size) ? (setup-&gt;wLength) : size; status |= USB_SendData(0, (void*)&amp;DeviceDescriptor, size, 0); } break; 首先判断size，确保数据没有超出request要求，然后使用USB_SendData发送in transfer数据。其中DeviceDescriptor为device descriptor地址。 set address request需要配置device地址，因此在driver layer实现。 21.2.6.2 SUSPEND 的处理 SUSPEND状态下可以根据需求进行power saving，默认配置只关闭了phy clock，其余的USB power/clock处理需要根据场景在应用层中的low power mode中来实现。 21.2.6.3 remote wakeup 进入suspend的device可以选择主动唤醒，唤醒通过bsp_usb_device_remote_wakeup()连续发送10ms的resume signal来实现。 void bsp_usb_device_remote_wakeup(void) { USB_DeviceSetRemoteWakeupBit(U_TRUE); platform_set_timer(internal_bsp_usb_device_remote_wakeup_stop,16);// setup timer for 10ms, then disable resume signal } 21.2.7 常用driver API 21.2.7.1 send usb data 使用该API发送USB数据（包括setup data和应用数据），但需要在set config（打开endpoint）之后使用。 /** * @brief interface API. send usb device data packet. * * @param[in] ep, endpoint number, the highest bit represent direction, use USB_EP_DIRECTION_IN/OUT * @param[in] buffer, global buffer to hold data of the packet, it must be a DWORD-aligned address. * @param[in] size. it should be a value smaller than 512*mps(eg, for EP0, mps is 64byte, maximum packet number is 512, MPS is 64). * @param[in] flag. null * @param[out] return U_TRUE if successful, otherwise U_FALSE. */ extern USB_ERROR_TYPE_E USB_SendData(uint8_t ep, void* buffer, uint16_t size, uint32_t flag); 21.2.7.2 receive usb data 使用该API接收USB数据（包括setup data和应用数据），但需要在set config（打开endpoint）之后使用。 /** * @brief interface API. receive usb device data packet. * * @param[in] ep, endpoint number, the highest bit represent direction, use USB_EP_DIRECTION_IN/OUT * @param[in] buffer, global buffer to hold data of the packet, it must be a DWORD-aligned address. * @param[in] size. For OUT transfers, the Transfer Size field in the endpoint Transfer Size register must be a multiple * of the maximum packet size of the endpoint(eg, EP0 is 64byte), adjusted to the DWORD boundary * @param[in] flag. null * @param[out] return U_TRUE if successful, otherwise U_FALSE. */ extern USB_ERROR_TYPE_E USB_RecvData(uint8_t ep, void* buffer, uint16_t size, uint32_t flag); 21.2.7.3 enable/disable ep 正常处理中不需要使用该API，特殊情况下可以根据需求打开关闭某个特定的endpoint /** * @brief interface APIs. use this pair for enable/disable certain ep. * * @param[in] ep number with USB_EP_DIRECTION_IN/OUT. * @param[out] null */ extern void USB_EnableEp(uint8_t ep, USB_EP_TYPE_T type); extern void USB_DisableEp(uint8_t ep); 21.2.7.4 usb close USB的disable请使用bsp layer中的bsp_usb_disable() /** * @brief interface API. shutdown usb module and reset all status data. * * @param[in] null. * @param[out] null. */ extern void USB_Close(void); 21.2.7.5 usb stall /** * @brief interface API. set ep stall pid for current transfer * * @param[in] ep num with direction. * @param[in] U_TRUE: stall, U_FALSE: set back to normal * @param[out] null. */ extern void USB_SetStallEp(uint8_t ep, uint8_t stall); 21.2.7.6 usb In endpoint NAK /** * @brief interface API. use this api to set NAK on a specific IN ep * * @param[in] U_TRUE: enable NAK on required IN ep. U_FALSE: stop NAK * @param[in] ep: ep number with USB_EP_DIRECTION_IN/OUT. * @param[out] null. */ extern void USB_SetInEndpointNak(uint8_t ep, uint8_t enable); 21.2.8 example 0: WINUSB WinUSB 是适用于 USB 设备的通用驱动程序，随附在自 Windows Vista 起的所有 Windows 版本中。 对于某些通用串行总线 (USB) 设备（例如只有单个应用程序访问的设备），可以将 WinUSB (Winusb.sys) 安装在 设备的内核模式堆栈中作为 USB 设备的函数驱动程序而不是实现驱动程序。如果已将设备定义为 WinUSB 设备 ，Windows会自动加载Winusb.sys。 参考：\\ING\\_SDK\\sdk\\src\\BSP\\bsp_usb.c 首先调用bsp_usb_init()初始化USB模块,之后的USB活动则全部在bsp_usb_event_handler()中处理。 #define FEATURE_WCID_SUPPORT device需要在enumeration阶段提供WCID标识和相关descriptor。示例中的descriptor实现如下： #define USB_WCID_DESCRIPTOR_INDEX_4 \\ { \\ #define USB_WCID_DESCRIPTOR_INDEX_5 \\ { \\ 通过修改USB_STRING_PRODUCT来改变产品名称iproduct #define USB_STRING_PRODUCT {16,0x3,&#39;w&#39;,0,&#39;i&#39;,0,&#39;n&#39;,0,&#39;-&#39;,0,&#39;d&#39;,0,&#39;e&#39;,0,&#39;v&#39;,0} 第一个值是整个数组的长度，第二个值不变，之后是16bit unicode字符串 （每个符号占用两个字节），该示例中iproduct为’win-dev’。 该示例中打开了两个bulk endpoint，endpoint 1 为input，endpoint 2为output,最大包长为64： #define USB_EP_1_DESCRIPTOR \\ { \\ .size = sizeof(USB_EP_DESCRIPTOR_REAL_T), \\ .type = 5, \\ .ep = USB_EP_DIRECTION_IN(EP_IN), \\ .attributes = USB_EP_TYPE_BULK, \\ .mps = EP_X_MPS_BYTES, \\ .interval = 0 \\ } #define USB_EP_2_DESCRIPTOR \\ { \\ .size = sizeof(USB_EP_DESCRIPTOR_REAL_T), \\ .type = 5, \\ .ep = USB_EP_DIRECTION_OUT(EP_OUT), \\ .attributes = USB_EP_TYPE_BULK, \\ .mps = EP_X_MPS_BYTES, \\ .interval = 0 \\ } 在set configuration(USB_REQUEST_DEVICE_SET_CONFIGURATION)之后，In/out endpoint 可以使用，通过USB_RecvData()配置out endpoint接收host发送的数据。 在收到host的数据后（USB_CALLBACK_TYPE_RECEIVE_END），通过USB_SendData()将数据 发送给host（通过in endpoint）。 在WIN10及以上的系统上，该设备会自动加载winusb.sys并枚举成WinUsb Device, 设备名称为”win-dev”。 通过ing_usb.exe可以对该设备进行一些简单数据测试(ing_usb.exe VID:PID -w(write command) 2(transfer type(2==bulk)) 以及需要传输的数据（默认包长度为endpoint的mps），数据会通过out endpoint发送给USB Device并通过in endpoint回环并打印出来)： 使用ing_usb.exe可以读取in endpoint的数据（(ing_usb.exe VID:PID -r(read command) 2(transfer type(2==bulk))）, 但是bsp layer中需要做相应的修改（使用in endpoint发送数据给host）。 21.2.9 example 1: HID composite 该示例实现了一个mouse + keyboard的复合设备， 使用了两个独立的interface，每个interface包含一个In Endpoint。 参考：\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.c 首先调用bsp_usb_init()初始化USB模块, 之后的USB活动则全部在bsp_usb_event_handler()中处理，report的发送参考report data 发送。 21.2.9.1 标准描述符 其标准描述符结构如下，configuration descriptor之后分别是interface descriptor, hid descriptor, endpoint descriptor。 typedef struct __attribute__((packed)) { USB_CONFIG_DESCRIPTOR_REAL_T config; USB_INTERFACE_DESCRIPTOR_REAL_T interface_kb; BSP_USB_HID_DESCRIPTOR_T hid_kb; USB_EP_DESCRIPTOR_REAL_T ep_kb[bNUM_EP_KB]; USB_INTERFACE_DESCRIPTOR_REAL_T interface_mo; BSP_USB_HID_DESCRIPTOR_T hid_mo; USB_EP_DESCRIPTOR_REAL_T ep_mo[bNUM_EP_MO]; }BSP_USB_DESC_STRUCTURE_T; 上述描述符的示例在路径\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.h，以keyboard interface为例： #define USB_INTERFACE_DESCRIPTOR_KB \\ { \\ .size = sizeof(USB_INTERFACE_DESCRIPTOR_REAL_T), \\ .type = 4, \\ .interfaceIndex = 0x00, \\ .alternateSetting = 0x00, \\ .nbEp = bNUM_EP_KB, \\ .usbClass = 0x03, \\ /* 0: no subclass, 1: boot interface */ \\ .usbSubClass = 0x00, \\ /* 0: none, 1: keyboard, 2: mouse */ \\ .usbProto = 0x00, \\ .iDescription = 0x00 \\ } 其中可能需要根据场景修改的变量使用宏定义，其他则使用常量。请注意：该实现中没有打开boot function。 21.2.9.2 报告描述符 报告描述符的示例在路径\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.h keyboard的report描述符为： #define USB_HID_KB_REPORT_DESCRIPTOR { \\ 0x05, 0x01, /* USAGE_PAGE (Generic Desktop) */ \\ 0x09, 0x06, /* USAGE (Keyboard) */ \\ 0xa1, 0x01, /* COLLECTION (Application) */ \\ 0x05, 0x07, /* USAGE_PAGE (Keyboard) */ \\ ...\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.h keyboard report descriptor包含8bit modifier input，8bit reserve, 5bit led output, 3bit reserve, 6bytes key usage id 。report本地结构为： #define KEY_TABLE_LEN (6) typedef struct __attribute__((packed)) { uint8_t modifier; uint8_t reserved; uint8_t key_table[KEY_TABLE_LEN]; }BSP_KEYB_REPORT_s; report中的usage id data的实现分别在以下enum中： BSP_KEYB_KEYB_USAGE_ID_e BSP_KEYB_KEYB_MODIFIER_e BSP_KEYB_KEYB_LED_e mouse的report描述符为： #define USB_HID_MOUSE_REPORT_DESCRIPTOR_SIZE (50) #define USB_HID_MOUSE_REPORT_DESCRIPTOR { \\ 0x05, 0x01, /* USAGE_PAGE (Generic Desktop) */ \\ 0x09, 0x02, /* USAGE (Mouse) */ \\ 0xa1, 0x01, /* COLLECTION (Application) */ \\ ...\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.h report包含一个3bit button(button 1 ~ button 3), 5bit reserve, 8bit x value, 8bit y value 结构为： typedef struct __attribute__((packed)) { uint8_t button;/* 1 ~ 3 */ int8_t pos_x;/* -127 ~ 127 */ int8_t pos_y;/* -127 ~ 127 */ }BSP_MOUSE_REPORT_s; 21.2.9.3 standard/class request ep0的request处理在event：USB_EVENT_EP0_SETUP。 HID Class相关的处理在interface destination下：USB_REQUEST_DESTINATION_INTERFACE。 以其中keyboard report 描述符的获取为例： setup-&gt;wIndex代表了interface num，其中0为keyboard interface（参考BSP_USB_DESC_STRUCTURE_T） 使用USB_SendData发送report数据 case USB_REQUEST_DEVICE_GET_DESCRIPTOR: { switch(((setup-&gt;wValue)&gt;&gt;8)&amp;0xFF) { case USB_REQUEST_HID_CLASS_DESCRIPTOR_REPORT: { switch(setup-&gt;wIndex) { case 0: { size = sizeof(ReportKeybDescriptor); size = (setup-&gt;wLength &lt; size) ? (setup-&gt;wLength) : size; status |= USB_SendData(0, (void*)&amp;ReportKeybDescriptor, size, 0); KeybReport.pending = U_FALSE; }break; ...\\ING_SDK\\sdk\\src\\BSP\\bsp_usb_hid.c 21.2.9.4 report data 发送 keyboard key的发送,入参为一个键值以及其是否处于按下的状态，如果该键按下，则将其添加到report中并发送出去。 /** * @brief interface API. send keyboard key report * * @param[in] key: value comes from BSP_KEYB_KEYB_USAGE_ID_e * @param[in] press: 1: pressed, 0: released * @param[out] null. */ extern void bsp_usb_handle_hid_keyb_key_report(uint8_t key, uint8_t press); keyboard modifier的发送，与key类似，区别是modifier是bitmap data。 extern void bsp_usb_handle_hid_keyb_key_report(uint8_t key, uint8_t press); /** * @brief interface API. send keyboard modifier report * * @param[in] modifier: value comes from BSP_KEYB_KEYB_MODIFIER_e * @param[in] press: 1: pressed, 0: released * @param[out] null. */ extern void bsp_usb_handle_hid_keyb_modifier_report(BSP_KEYB_KEYB_MODIFIER_e modifier, uint8_t press); keyboard led的获取，该示例中没有out endpoint，因此led report可能是用ep0的set report得到， 参考：USB_REQUEST_HID_CLASS_REQUEST_SET_REPORT。 mouse report的发送,入参分别为x,y的相对值和button的组合（按下为1，释放为0）。 /** * @brief interface API. send mouse report * * @param[in] x: 8bit int x axis value, relative, * @param[in] y: 8bit int y axis value, relative, * @param[in] btn: 8bit value, button 1 to 3, * @param[out] null. */ extern void bsp_usb_handle_hid_mouse_report(int8_t x, int8_t y, uint8_t btn); "],["ch-watchdog.html", "22 看门狗（WATCHDOG） 22.1 功能概述 22.2 使用说明", " 22 看门狗（WATCHDOG） 22.1 功能概述 看门狗就是定期的查看芯片内部情况，一旦发生错误就向芯片内部发出重启信号。 看门狗指令在程序的中断中拥有最高的优先级。防止程序跑飞，同时也能防止程序在线运行时出现死循环 22.2 使用说明 22.2.1 配置看门狗 使用 TMR_WatchDogEnable3 配置并启用看门狗。 void TMR_WatchDogEnable3( uint32_t int_timeout_ms, uint32_t reset_timeout_ms, uint8_t enable_int ); 为了ING916xx和ING918xx统一接口，定义宏 TMR_WatchDogEnable 代替 TMR_WatchDogEnable3 。 #define TMR_WatchDogEnable(timeout) do { uint32_t TMR_CLK_FREQ = OSC_CLK_FREQ; uint32_t cnt = ((uint64_t)(timeout) * 1000 / OSC_CLK_FREQ); TMR_WatchDogEnable3(cnt, cnt, 0); } while (0) 例如： 22.2.2 重启看门狗 使用 TMR_WatchDogRestart 重启看门狗。 void TMR_WatchDogRestart(void); 22.2.3 清除中断 使用 TMR_WatchDogClearInt 清除看门狗的中断。 void TMR_WatchDogClearInt(void); 22.2.4 禁用看门狗 在使用TMR_WatchDogEnable 启用或 TMR_WatchDogRestart 重启看门狗之后， 需要使用 TMR_WatchDogDisable 对其禁用。 void TMR_WatchDogDisable(void); "],["ch-eflash.html", "23 内置 Flash（EFlash） 23.1 功能概述 23.2 使用说明", " 23 内置 Flash（EFlash） 23.1 功能概述 芯片内置一定容量的 Flash，可编程擦写。擦除时以扇区（sector）为单位进行， 写入时以 32bit 为单位。 内置 Flash 的电源由单独的 LDO 提供，相关配置请参考内置 Flash 电压。 使用不同的电压供电时所能支持的最高时钟频率也不相同，见表 23.1。 注意实际频率不可超过最高频率。 表 23.1: 内置 Flash 电源电压与最高时钟频率 电压（\\(V\\)） 最高时钟频率（MHz） \\(2.100\\) \\(170\\) \\(2.200\\) \\(170\\) \\(2.300\\) \\(170\\) \\(2.400\\) \\(170\\) \\(2.500\\) \\(170\\) \\(2.600\\) \\(192\\) \\(2.700\\) \\(192\\) \\(2.800\\) \\(192\\) \\(2.900\\) \\(192\\) \\(3.000\\) \\(192\\) \\(3.100\\) \\(192\\) 表中的 Flash 时钟频率可通过 SYSCTRL_GetFlashClk() 读取。Flash 内部会对这个时钟 2 分频， 实际的工作频率为这个时钟频率的一半。 关于内置 Flash LDO 输出电压的配置建议： 当 \\(V_{BAT}\\) 固定，且 \\(V_{BAT} \\geq 2.8V\\) 时，可以按照芯片数据手册给出的 Flash 颗粒的要求配置 Flash LDO 输出电压为 \\(2.1V\\) 或 \\(2.6V\\)； 当输出电压配置为 \\(2.6V\\) 时，可将 Flash 时钟频率配置为 \\(192 M Hz\\) 以获得最佳性能。 当 \\(V_{BAT}\\) 固定，且 \\(2.3V \\leq V_{BAT} &lt; 2.8V\\) 时，配置 Flash LDO 输出电压为 \\(2.1V\\)； 当 \\(V_{BAT}\\) 固定，且 \\(V_{BAT} &lt; 2.3V\\) 时，仍可以配置 Flash LDO 输出电压为 \\(2.1V\\)， 这时当 \\(V_{BAT} &lt; 2.1V\\) 时，Flash LDO输出电压与 \\(V_{BAT}\\) 一致，可保证 Flash 仍有供电； 当 \\(V_{BAT}\\) 不固定，如 \\(V_{BAT}\\) 来自电池输出时，推荐配置 Flash LDO 输出电压为 \\(2.1V\\)。 23.2 使用说明 23.2.1 擦除并写入新数据 通过 program_flash 擦除并写入一段数据。 int program_flash( // 待写入的地址 const uint32_t dest_addr, // 数据源的地址 const uint8_t *buffer, // 数据长度（以字节为单位，必须是 4 的倍数） uint32_t size); dest_addr 为统一编址后的地址，而非 Flash 内部从 0 开始的地址。dest_addr 必须对应于某个扇区的起始地址。数据源不可位于 Flash 内。 program_flash 将根据 size 自动擦除一个或多个扇区并写入数据。 本函数如果成功，则返回 0，否则返回非 0。 23.2.2 不擦除直接写入数据 通过 write_flash 不擦除直接写入数据。 int write_flash( // 待写入的地址 const uint32_t dest_addr, // 数据源的地址 const uint8_t *buffer, // 数据长度（以字节为单位，必须是 4 的倍数） uint32_t size); dest_addr 为统一编址后的地址，必须 32bit 对齐。write_data 不擦除 Flash，而是直接写入。 数据源不可位于 Flash 内。如果对应的 Flash 空间未被擦除，将无法写入。 本函数如果成功，则返回 0，否则返回非 0。 23.2.3 单独擦除 通过 erase_flash_sector 擦除一个指定的扇区。 int erase_flash_sector( // 待擦除的地址 const uint32_t addr); addr 必须对应于某个扇区的起始地址。本函数如果成功，则返回 0，否则返回非 0。 23.2.4 Flash 数据升级 通过 flash_do_update 可以升级 Flash 里的数据。这个函数可用于 FOTA 升级。 int flash_do_update( // 数据块数目 const int block_num, // 每个数据块的信息 const fota_update_block_t *blocks, // 用于缓存一个扇区的内存 uint8_t *ram_buffer); 每个数据块的定为为： typedef struct fota_update_block { uint32_t src; uint32_t dest; uint32_t size; } fota_update_block_t; 这个函数的行为大致如下： flash_do_update() { for (block in blocks) { flash_copy(block.dest, block.src, block.size); } } 如前所述，program_flash 的数据源不能位于 Flash，所以 flash_copy 需要把各扇区逐个读入 ram_buffer，然后使用 program_flash 擦除、写入。 这个函数如果成功，将自动重启系统，否则返回非 0。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
