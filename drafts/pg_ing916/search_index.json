[["index.html", "ING916XX 系列芯片外设开发者手册 1 版本历史", " ING916XX 系列芯片外设开发者手册 Ingchips Technology Co., Ltd. 1 版本历史 版本 信息 日期 0.1 初始版本 2022-xx-xx "],["ch-overview.html", "2 概览 2.1 缩略语及术语 2.2 参考文档", " 2 概览 欢迎使用 INGCHIPS 918xx/916xx 软件开发工具包 （SDK）. ING916XX 系列芯片支持蓝牙 5.3 规范，内置高性能 32bit RISC MCU（支持 DSP 和 FPU）、Flash、低功耗 PMU， 以及丰富的外设、高性能低功耗 BLE RF 收发机。BLE 发射功率。 本文介绍 SoC 外设及其开发方法。每个章节介绍一种外设，各种外设与芯片数据手册之外设一一对应， 基于 API 的兼容性、避免误解等因素，存在以下例外： PINCTRL 对应于数据手册之 IOMUX PCAP 对应于数据手册之 PCM SYSCTRL 是一个“虚拟”外设，负责管理各种 SoC 功能，组合了几种相关的硬件模块 SDK 外设驱动的源代码开放，其中包含很多常数，而且几乎没有注释 —— 这是有意为之，开发者只需要关注头文件，而不要尝试修改源代码。 2.1 缩略语及术语 表 2.1: 缩略语 缩略语 说明 ADC 模数转换器（Analog-to-Digital Converter） DMA 直接存储器访问（Direct Memory Access） EFUSE 电编程熔丝（Electronic Fuses） FIFO 先进先出队列（First In First Out） GPIO 通用输入输出（General-Purpose Input/Output） I2C 集成电路间总线（Inter-Integrated Circuit） I2S 集成电路音频总线（Inter-IC Sound） IR 红外线（Infrared） PCAP 脉冲捕捉（Pulse CAPture） PDM 脉冲密度调制（Pulse Density Modulation） PTE 外设触发引擎（Peripheral Trigger Engine） PWM 脉宽调制信号（Pulse Width Modulation） QDEC 正交解码器（Quadrature Decoder） RTC 实时时钟（Real-time Clock） SPI 串行外设接口（Serial Peripheral Interface） UART 通用异步收发器（Universal Asynchronous Receiver/Transmitter） USB 通用串行总线（Universal Serial Bus） 2.2 参考文档 Bluetooth SIG1 ING916XX 系列芯片数据手册 https://www.bluetooth.com/ "],["ch-dma.html", "3 DMA简介 3.1 功能描述 3.2 使用方法 3.3 编程指南", " 3 DMA简介 DMA全称direct memory access，即直接存储器访问。 其主要作用是不占用CPU大量资源，在AMBA AHB总线上的设备之间以硬件方式高速有效地传输数据。 3.1 功能描述 3.1.1 特点 符合AMBA、AHB和APB4标准 最多8个DMA通道 最多16个硬件握手请求/确认配对 支持8/16/32/64位宽的数据传输 支持24-64位地址宽度 支持成链传输数据 3.1.2 搬运方式 单次数据块搬运：DMA使用单个通道，一次使能将数据从SRC到DST位置搬运一次 成串多数据块搬运：DMA使用单个通道，一次使能按照DMA链表信息依次将数据从SRC到DST位置搬运多次或循环搬运。 其根本区别是有无注册有效的DMA链表。 3.1.3 搬运类型 memory到memory搬运 memory到peripheral搬运 peripheral到memory搬运 peripheral到peripheral搬运 3.1.4 中断类型 IntErr：错误中断表示DMA传输发生了错误而触发中断，主要包括总线错误、地址没对齐和传输数据宽度没对齐等。 IntAbt：终止传输中断会在终止DMA通道传输时产生。 IntTC：TC中断会在没有产生IntErr和IntAbt的情况下完成一次传输时产生。 3.1.5 数据地址类型 Increment address Decrement address Fixed address 如果Increment则DMA从地址有小到大搬运数据，相反的Decrement则由大到小搬运。fixed地址适用于外设FIFO的寄存器搬运数据。 3.1.6 数据方式 normal mode handshake mode 一般外设寄存器选择用握手方式。 选择握手方式要和外设协商好SrcBurstSize，当前支持2^n(n = 0-7)大小的SrcBurstSize。 3.1.7 数据位宽 DMA传输要求传输两端的数据类型一致，支持数据类型有： Byte transfer Half-word transfer Word transfer Double word transfer 覆盖所有常见数据类型。 3.2 使用方法 3.2.1 方法概述 首先确认数据搬运需求是单次搬运还是成串搬运，搬运类型memory和peripheral的关系。 3.2.1.1 单次搬运 1. 注册DMA中断 2. 定义一个DMA_Descriptor变量用来配置DMA通道寄存器 3. 根据数据搬运类型选择DMA寄存器配置接口，正确调用驱动接口配置DMA寄存器 4. 使能DMA通道开始搬运 3.2.1.2 成串搬运 1. 注册一个或多个DMA中断 2. 定义多个DMA_Descriptor变量用来配置DMA通道寄存器 3. 根据数据搬运类型选择DMA寄存器配置接口，正确调用驱动接口配置DMA寄存器 4. 将多个DMA_Descriptor变量首尾相连成串，类似链表 5. 使能DMA通道开始搬运 3.2.2 注意点 定义DMA_Descriptor变量需要8字节对齐，否则DMA搬运不成功 成串搬运如果配置多个DMA中断则需要在每个中断里使能DMA，直到最后一次搬运完成 对于从外设搬运需要确认外设是否支持DMA 建议从外设搬运选择握手方式，并与外设正确协商burstSize burstSize尽量取较大值，有利于减少DMA中断次数提高单次中断处理效率。但burstSize太大可能最后一次不能搬运丢弃较多数据 建议设置从外设搬运总数据量为burstSize的整数倍或采用乒乓搬运的方式 在DMA从外设搬运的情况下，正确的操作顺序是先配置并使能好DMA，再使能外设开始产生数据 3.3 编程指南 3.3.1 驱动接口 DMA_PrepareMem2Mem：memory到memory搬运标准DMA寄存器配置接口 DMA_PreparePeripheral2Mem：Peripheral到memory搬运标准DMA寄存器配置接口 DMA_PrepareMem2Peripheral：memory到Peripheral搬运标准DMA寄存器配置接口 DMA_PreparePeripheral2Peripheral：Peripheral到Peripheral搬运标准DMA寄存器配置接口 DMA_Reset：DMA复位接口 DMA_GetChannelIntState：DMA通道中断状态获取接口 DMA_ClearChannelIntState：DMA通道清中断接口 DMA_EnableChannel：DMA通道使能接口 DMA_AbortChannel：DMA通道终止接口 3.3.2 代码示例 3.3.2.1 单次搬运 下面以memory到memory单次搬运展示DMA的基本用法： #define CHANNEL_ID 0 char src[] = &quot;hello world!&quot;; char dst[20]; DMA_Descriptor test __attribute__((aligned (8))); static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); printf(&quot;dst = %s\\n&quot;, dst); return 0; } void DMA_Test(void) { DMA_Reset(); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); DMA_PrepareMem2Mem(&amp;test[0], dst, src, strlen(src), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_EnableChannel(CHANNEL_ID, &amp;test); } 最终会在DMA中断程序里面将搬运到dst中的“hello world!”字符串打印出来。 3.3.2.2 成串搬运 下面以memory到memory两块数据搬运拼接字符串展示DMA成串搬运的基本用法： #define CHANNEL_ID 0 char src[] = &quot;hello world!&quot;; char src1[] = &quot;I am a chinese.&quot;; char dst[100]; DMA_Descriptor test[2] __attribute__((aligned (8))); static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); printf(&quot;dst = %s\\n&quot;, dst); return 0; } void DMA_Test(void) { DMA_Reset(); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); test[0].Next = &amp;test[1]; // make a DMA link chain test[1].Next = NULL; DMA_PrepareMem2Mem(&amp;test[0], dst, src, strlen(src), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_PrepareMem2Mem(&amp;test[1], dst + strlen(src), src1, sizeof(src1), DMA_ADDRESS_INC, DMA_ADDRESS_INC, 0); DMA_EnableChannel(CHANNEL_ID, &amp;test[0]); } 最终将会打印出“hello world!I am a chinese.”字符串。 3.3.2.3 DMA乒乓搬运 DMA乒乓搬运是一种DMA搬运的特殊用法，其主要应用场景是将外设FIFO中数据循环搬运到memory中并处理。 可实现“搬运”和“数据处理”分离，从而大大提高程序处理数据的效率。 下面将以最常见的DMA乒乓搬运I2s数据为例展示DMA乒乓搬运的用法。 I2s的相关配置不在本文的介绍范围内，默认I2s已经配置好，DMA和I2s协商burstSize=8。 #define CHANNEL_ID 0 char dst[80]; DMA_Descriptor test[2] __attribute__((aligned (8))); uint8_t pingpang = 0; static uint32_t DMA_cb_isr(void *user_data) { uint32_t state = DMA_GetChannelIntState(CHANNEL_ID); DMA_ClearChannelIntState(CHANNEL_ID, state); pingpang ^= 1; DMA_EnableChannel(CHANNEL_ID, &amp;test[pingpang]); // do something to handle the data in &#39;dst&#39; buffer return 0; } void DMA_Test(void) { DMA_Reset(); platform_set_irq_callback(PLATFORM_CB_IRQ_DMA, DMA_cb_isr, 0); test[0].Next = &amp;test[1]; test[1].Next = &amp;test[0]; // make a DMA link cycle DMA_PreparePeripheral2RAM(&amp;test[0], dst, SYSCTRL_DMA_I2S_RX, 80, DMA_ADDRESS_INC, 0 | 8 &lt;&lt; 24 | 1 &lt;&lt; 28); DMA_PreparePeripheral2RAM(&amp;test[1], dst, SYSCTRL_DMA_I2S_RX, 80, DMA_ADDRESS_INC, 0 | 8 &lt;&lt; 24 | 1 &lt;&lt; 28); DMA_EnableChannel(CHANNEL_ID, &amp;test[pingpang]); I2S_ClearRxFIFO(APB_I2S); I2S_DMAEnable(APB_I2S, 1, 1); I2S_Enable(APB_I2S, 0, 1); // Enable I2s finally } "],["efuseselectronic-fuses.html", "4 eFuses(electronic fuses) 4.1 功能概述 4.2 使用说明", " 4 eFuses(electronic fuses) 4.1 功能概述 Efuse是一种片内一次性可编程存储器，可以在断电后保持数据，并且编程后无法被再次修改。 ING916系列提供128bit EFUSE，支持按bit编程或者按Word编程，bit的默认值是0，通过编程可以写成1 4.2 使用说明 4.2.1 模块初始化 void setup_peripherals_efuse_module(void) { // 打开clock，并且reset模块 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_EFUSE)); SYSCTRL_ResetBlock(SYSCTRL_ITEM_APB_EFUSE); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_EFUSE); } 4.2.2 按bit编程 void peripherals_efuse_write_bit(void) { // 提供需要编程的bit位置,0到127之间 EFUSE_UnLock(APB_EFUSE, EFUSE_UNLOCK_FLAG); EFUSE_WriteEfuseDataBitToOne(APB_EFUSE, pos);//pos is bit position from 0 to 127 //写操作完成 //如果要读取，需要reset模块 SYSCTRL_ResetBlock(SYSCTRL_ITEM_APB_EFUSE); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_EFUSE); //设置读取flag EFUSE_SetRdFlag(APB_EFUSE); //等待数据读取标志 while(!EFUSE_GetDataValidFlag(APB_EFUSE)); //读取数据 platform_printf(&quot;word 0: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 0));//bit 0 - 31 platform_printf(&quot;word 1: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 1));//bit 32 - 63 platform_printf(&quot;word 2: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 2));//bit 64 - 95 platform_printf(&quot;word 3: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 3));//bit 96 - 127 } 4.2.3 按word编程 void peripherals_efuse_write_word(void) { // 提供需要编程的word位置,0到3之间,每个word 32bit，一共128bit // EFUSE_PROGRAMWORDCNT_0代表word 0 // data是要写入的32bit数据 EFUSE_WriteEfuseDataWord(APB_EFUSE, EFUSE_PROGRAMWORDCNT_0, data); //写操作完成 //如果要读取，需要reset模块 SYSCTRL_ResetBlock(SYSCTRL_ITEM_APB_EFUSE); SYSCTRL_ReleaseBlock(SYSCTRL_ITEM_APB_EFUSE); //设置读取flag EFUSE_SetRdFlag(APB_EFUSE); //等待数据读取标志 while(!EFUSE_GetDataValidFlag(APB_EFUSE)); //读取数据 platform_printf(&quot;word 0: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 0));//bit 0 - 31 platform_printf(&quot;word 1: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 1));//bit 32 - 63 platform_printf(&quot;word 2: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 2));//bit 64 - 95 platform_printf(&quot;word 3: 0x%x \\n&quot;,EFUSE_GetEfuseData(APB_EFUSE, 3));//bit 96 - 127 } "],["ch-gpio.html", "5 通用输入输出（GPIO） 5.1 功能概述 5.2 使用说明", " 5 通用输入输出（GPIO） 5.1 功能概述 GPIO 模块常用于驱动 LED 或者其它指示器，控制片外设备，感知数字信号输入，检测信号边沿， 或者从低功耗状态唤醒系统。ING916XX 系列芯片内部支持最多 36 个 GPIO，通过 PINCTRL 可将 GPIO \\(n\\) 引出到芯片 IO 管脚 \\(n\\)。 特性： 每个 GPIO 都可单独配置为输入或输出 每个 GPIO 都可作为中断请求，中断触发方式支持边沿触发（上升、下降单沿触发，或者双沿触发） 和电平触发（高电平或低电平） 硬件去抖 在硬件上存在 两个 GPIO 模块，每个模块包含 18 个 GPIO，相应地定义了两个 SYSCTRL_Item： typedef enum { SYSCTRL_ITEM_APB_GPIO0 , SYSCTRL_ITEM_APB_GPIO1 , // ... } SYSCTRL_Item; 注意按照所使用的 GPIO 管脚打开对应的 GPIO 模块。 5.2 使用说明 5.2.1 设置 IO 方向 在使用 GPIO 之前先按需要配置 IO 方向： 需要用于输出信号时：配置为输出 需要用于读取信号时：配置为输入 需要用于生产中断请求时：配置为输入 需要高阻态时：配置为高阻态 使用 GIO_SetDirection 配置 GPIO 的方向。GPIO 支持四种方向： typedef enum { GIO_DIR_INPUT, // 输入 GIO_DIR_OUTPUT, // 输出 GIO_DIR_BOTH, // 同时支持输入、输出 GIO_DIR_NONE // 高阻态 } GIO_Direction_t; 如无必要，不要使用 GIO_DIR_BOTH。 5.2.2 读取输入 使用 GIO_ReadValue 读取某个 GPIO 当前输入的电平信号，例如读取 GPIO 0 的输入： uint8_t value = GIO_ReadValue(GIO_GPIO_0); 使用 GIO_ReadAll 可以同时读取所有 GPIO 当前输入的电平信号。其返回值的第 \\(n\\) 比特 （第 0 比特为最低比特）对应 GPIO \\(n\\) 的输入；如果 GPIO \\(n\\) 当前不支持输入，那么第 \\(n\\) 比特为 0： uint64_t GIO_ReadAll(void); 5.2.3 设置输出 使用 GIO_WriteValue 设置某个 GPIO 输出的电平信号，例如使 GPIO 0 输出高电平（1）： GIO_WriteValue(GIO_GPIO_0, 1); 5.2.4 配置中断请求 使用 GIO_ConfigIntSource 配置 GPIO 生成中断请求。 void GIO_ConfigIntSource( const GIO_Index_t io_index, // GPIO 编号 const uint8_t enable, // 使能的边沿或者电平类型组合 const GIO_IntTriggerType_t type // 触发类型 ); 其中的 enable 为以下两个值的组合（0 表示禁止产生中断请求）： typedef enum { ...LOGIC_LOW_OR_FALLING_EDGE = ..., // 低电平或者下降沿 ...LOGIC_HIGH_OR_RISING_EDGE = ... // 高电平或者上升沿 } GIO_IntTriggerEnable_t; 触发类型有两种： typedef enum { GIO_INT_EDGE, // 边沿触发 GIO_INT_LOGIC // 电平触发 } GIO_IntTriggerType_t; 例如将 GPIO 0 配置为上升沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为双沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE | ..._HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为高电平触发 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_LOGIC); 5.2.5 处理中断状态 用 GIO_GetIntStatus 获取某个 GPIO 上的中断触发状态，返回非 0 值表示该 GPIO 上产生了中断请求；用 GIO_GetAllIntStatus 一次性获取所有 GPIO 的中断触发状态， 第 \\(n\\) 比特（第 0 比特为最低比特）对应 GPIO \\(n\\) 上的中断触发状态。 GPIO 产生中断后，需要消除中断状态方可再次触发。用 GIO_ClearIntStatus 消除某个 GPIO 上中断状态，用 GIO_ClearAllIntStatus 一次性清除所有 GPIO 上可能存在的中断触发状态。 5.2.6 输入去抖 使用 GIO_DebounceCtrl 配置输入去抖参数，每个 GPIO 硬件模块使用单独的参数： void GIO_DebounceCtrl( uint8_t group_mask, // 比特 0 为 1 时配置模块 0 // 比特 1 为 1 时配置模块 1 uint8_t clk_pre_scale, GIO_DbClk_t clk // 防抖时钟选择 ); 所谓去抖就是过滤掉长度小于 (clk_pre_scale + 1) 个防抖时钟周期的“毛刺”。 防抖时钟共有 2 种： typedef enum { GIO_DB_CLK_32K, // 使用 32k 时钟 GIO_DB_CLK_PCLK, // 使用快速 PCLK } GIO_DbClk_t; 快速 PCLK 的具体频率参考 SYSCTRL。 通过 GIO_DebounceEn 为单个 GPIO 使能去抖。例如要在 GPIO 0 上启用硬件去抖，忽略宽度小于 \\(5/32768 \\approx 0.15 (ms)\\) 的“毛刺”： GIO_DebounceCtrl(1, 4, GIO_DB_CLK_32K); GIO_DebounceEn(GIO_GPIO_0, 1); "],["i2c功能概述.html", "6 I2C功能概述 6.1 I2C使用说明 6.2 场景1：Master读Slave，不使用DMA 6.3 场景2：Master写Slave，不使用DMA 6.4 场景3：Master读Slave，使用DMA 6.5 场景4：Master写Slave，使用DMA", " 6 I2C功能概述 两个I2C模块 支持Master/Slave模式 支持7bit/10bit地址 支持速率调整 支持DMA 6.1 I2C使用说明 以下场景中均以I2C0为例，如果需要I2C1则可以根据情况修改 6.2 场景1：Master读Slave，不使用DMA 其中I2C配置为Master读操作，Slave收到地址后，将数据返回给Master，CPU操作读写，没有使用DMA。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 6.2.1 I2C Master配置 // 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (10) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 6.2.1.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(IO_SOURCE_I2C0_SCL_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SCL_IN,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_IN,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 6.2.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和fifo满中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_FULL)); } 6.2.1.3 I2C中断实现 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); // FIFO 满之后，触发中断，此时需要将所有数据都读出来 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){break;} read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } } //传输结束后，触发中断，读取完剩下的数据 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 6.2.1.4 I2C master触发传输 void peripheral_i2c_send_data(void) { // 设置方向，Master读取 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_SLAVE2MASTER); // 设置每次传输的大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 6.2.1.5 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 在需要时候触发I2C读取，peripheral_i2c_send_data() 检查中断状态 6.2.2 I2C Slave配置 // 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (10) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 6.2.2.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(IO_SOURCE_I2C0_SCL_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SCL_IN,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_IN,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 6.2.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 6.2.2.3 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave 收到匹配的地址，触发中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { // 判断是读操作还是写操作 dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 如果是读操作，则会触发empty中断，此时需要填写需要发送的数据，直到FIFO满 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){break;} I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } } // 传输结束，清理打开的中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 6.2.2.4 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 检查中断状态，在中断中发送数据，I2C_STATUS_CMPL中断代表传输结束 6.3 场景2：Master写Slave，不使用DMA 其中I2C配置为Master写操作，Slave收到地址后，将从Master读取数据，CPU操作读写，没有使用DMA。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 6.3.1 I2C Master配置 // 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (10) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 6.3.1.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(IO_SOURCE_I2C0_SCL_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SCL_IN,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_IN,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 6.3.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和fifo空中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)|(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } 6.3.1.3 I2C中断实现 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); // 传输结束，触发中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } // empty FIFO 中断，填写需要发送的数据，数据全部发送之后，关掉I2C_INT_FIFO_EMPTY if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_EMPTY)) { // push data until fifo is full for(; write_data_cnt &lt; DATA_CNT; write_data_cnt++) { if(I2C_FifoFull(APB_I2C0)){break;} I2C_DataWrite(APB_I2C0,write_data[write_data_cnt]); } // if its the last, disable empty int if(write_data_cnt == DATA_CNT) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 6.3.1.4 I2C master触发传输 void peripheral_i2c_send_data(void) { // 设置方向，Master写 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_MASTER2SLAVE); // 设置每次传输的大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 6.3.1.5 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 在需要时候发送I2C数据，peripheral_i2c_send_data() 检查中断状态 6.3.2 I2C Slave配置 // 测试数据，每次传输10个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (10) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 6.3.2.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(IO_SOURCE_I2C0_SCL_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SCL_IN,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_IN,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 6.3.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 6.3.2.3 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave 收到匹配的地址，触发中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { // 判断是读操作还是写操作 dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntEnable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 等待FIFO FULL，读取FIFO直到FIFO变空 if(status &amp; (1 &lt;&lt; I2C_STATUS_FIFO_FULL)) { for(; read_data_cnt &lt; DATA_CNT; read_data_cnt++) { if(I2C_FifoEmpty(APB_I2C0)){break;} read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } } // 传输结束，读取FIFO中剩余的数据，清除相关中断 if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { for(;read_data_cnt &lt; DATA_CNT; read_data_cnt++) { read_data[read_data_cnt] = I2C_DataRead(APB_I2C0); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); // prepare for next if(dir == I2C_TRANSACTION_MASTER2SLAVE) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_FULL)); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { I2C_IntDisable(APB_I2C0,(1 &lt;&lt; I2C_INT_FIFO_EMPTY)); } } return 0; } 6.3.2.4 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 检查中断状态，I2C_STATUS_CMPL中断代表传输结束 6.4 场景3：Master读Slave，使用DMA 其中I2C配置为Master读操作，Slave收到地址后，将数据返回给Master，DMA操作读写。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 6.4.1 I2C Master配置 // 测试数据，每次传输23个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (23) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 6.4.1.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(IO_SOURCE_I2C0_SCL_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SCL_IN,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_IN,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 6.4.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)); } 6.4.1.3 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 6.4.1.4 I2C中断实现 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 6.4.1.5 I2C master DMA设置 // 注意此处是I2C0 void peripherals_i2c_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_I2C0,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 6.4.1.6 I2C master触发传输 void peripheral_i2c_send_data(void) { // I2C DMA 功能打开 I2C_DmaEnable(APB_I2C0,1); // 设置传输方向，Master读 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_SLAVE2MASTER); // 设置需要传输的数据大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 配置DMA #define I2C_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_i2c_rxfifo_to_dma(I2C_DMA_RX_CHANNEL, read_data, sizeof(read_data)); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 6.4.1.7 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候触发I2C读取，peripheral_i2c_send_data() 检查中断状态 6.4.2 I2C Slave配置 // 测试数据，每次传输23个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (23) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 6.4.2.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(IO_SOURCE_I2C0_SCL_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SCL_IN,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_IN,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 6.4.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 6.4.2.3 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 6.4.2.4 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave收到了匹配的地址，触发中断，判断方向 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { // 设置DMA，发送数据 peripherals_i2c_write_data_dma_setup(); } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 传输结束，关闭DMA if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_DmaEnable(APB_I2C0,0); I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 6.4.2.5 I2C Slave 发送数据DMA设置 // 此处配置的是I2C0 void peripherals_i2c_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_I2C0,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_i2c_write_data_dma_setup(void) { // 设置DMA #define I2C_DMA_TX_CHANNEL (0)//DMA channel 0 peripherals_i2c_dma_to_txfifo(I2C_DMA_TX_CHANNEL, write_data, sizeof(write_data)); // 更新需要传输的数据 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 打开I2C DMA I2C_DmaEnable(APB_I2C0,1); } 6.4.2.6 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 初始化DMA，setup_peripherals_dma_module() 检查中断状态，在中断中设置DMA发送数据，I2C_STATUS_CMPL中断代表传输结束 6.5 场景4：Master写Slave，使用DMA 其中I2C配置为Master写操作，Slave收到地址后，读取Master发送的数据，DMA操作读写。 配置之前需要决定使用的GPIO，请参考datasheet了解可以使用的GPIO #define I2C_SCL GIO_GPIO_10 #define I2C_SDA GIO_GPIO_11 6.5.1 I2C Master配置 // 测试数据，每次传输23个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (23) uint8_t write_data[DATA_CNT] = {0,}; uint8_t write_data_cnt = 0; 6.5.1.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(IO_SOURCE_I2C0_SCL_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SCL_IN,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_IN,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 6.5.1.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Master, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_MASTER,I2C_ADDRESSING_MODE_07BIT,ADDRESS); // 配置时钟，可选 I2C_ConfigClkFrequency(APB_I2C0,I2C_CLOCKFREQUENY_STANDARD); I2C_Enable(APB_I2C0,1); // 打开传输结束中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_CMPL)); } 6.5.1.3 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 6.5.1.4 I2C中断实现 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; uint32_t status = I2C_GetIntState(APB_I2C0); if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 6.5.1.5 I2C master DMA设置 // 注意此处是I2C0 void peripherals_i2c_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_I2C0,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 6.5.1.6 I2C master触发传输 void peripheral_i2c_send_data(void) { // I2C DMA 功能打开 I2C_DmaEnable(APB_I2C0,1); // 设置传输方向，Master读 I2C_CtrlUpdateDirection(APB_I2C0,I2C_TRANSACTION_MASTER2SLAVE); // 设置需要传输的数据大小 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 配置DMA #define I2C_DMA_TX_CHANNEL (0)//DMA channel 0 peripherals_i2c_dma_to_txfifo(I2C_DMA_TX_CHANNEL, write_data, sizeof(write_data)); // 触发传输 I2C_CommandWrite(APB_I2C0, I2C_COMMAND_ISSUE_DATA_TRANSACTION); } 6.5.1.7 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候触发I2C读取，peripheral_i2c_send_data() 检查中断状态 6.5.2 I2C Slave配置 // 测试数据，每次传输23个字节（fifo深度是8字节），每个传输单元必须是1字节 #define DATA_CNT (23) uint8_t read_data[DATA_CNT] = {0,}; uint8_t read_data_cnt = 0; 6.5.2.1 配置Pin 将GPIO映射成I2C引脚 void setup_peripherals_i2c_pin(void) { // 打开clock，注意此处使用的是I2C0 // GPIO的clock请根据需要打开GPIO0或者GPIO1 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 使用默认内部上拉，实际使用中建议使用外部上拉 - 响应速度更快，可以支持更高的时钟 // 如果使用外部上拉，则不需要pull PINCTRL_Pull(IO_SOURCE_I2C0_SCL_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_OUT,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SCL_IN,PINCTRL_PULL_UP); PINCTRL_Pull(IO_SOURCE_I2C0_SDA_IN,PINCTRL_PULL_UP); // 将GPIO映射成I2C引脚 PINCTRL_SelI2cIn(I2C_PORT_0,I2C_SCL,I2C_SDA); // 打开I2C中断 platform_set_irq_callback(PLATFORM_CB_IRQ_I2C0, peripherals_i2c_isr, NULL); } 6.5.2.2 初始化I2C模块 #define ADDRESS (0x71) void setup_peripherals_i2c_module(void) { // 配置为Slave, 7bit地址 I2C_Config(APB_I2C0,I2C_ROLE_SLAVE,I2C_ADDRESSING_MODE_07BIT,ADDRESS); I2C_Enable(APB_I2C0,1); // 打开传输结束中断和地址触发中断 I2C_IntEnable(APB_I2C0,(1&lt;&lt;I2C_INT_ADDR_HIT)|(1&lt;&lt;I2C_INT_CMPL)); } 6.5.2.3 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 6.5.2.4 I2C中断实现以及发送数据 static uint32_t peripherals_i2c_isr(void *user_data) { uint8_t i; static uint8_t dir = 2; uint32_t status = I2C_GetIntState(APB_I2C0); // Slave收到了匹配的地址，检查传输方向 if(status &amp; (1 &lt;&lt; I2C_STATUS_ADDRHIT)) { dir = I2C_GetTransactionDir(APB_I2C0); if(dir == I2C_TRANSACTION_MASTER2SLAVE) { // 设置DMA读取数据 peripherals_i2c_read_data_dma_setup(); } else if(dir == I2C_TRANSACTION_SLAVE2MASTER) { } I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_ADDRHIT)); } // 传输结束，关闭DMA if(status &amp; (1 &lt;&lt; I2C_STATUS_CMPL)) { I2C_DmaEnable(APB_I2C0,0); I2C_ClearIntState(APB_I2C0, (1 &lt;&lt; I2C_STATUS_CMPL)); } return 0; } 6.5.2.5 I2C Slave 发送数据DMA设置 // 此处配置的是I2C0 void peripherals_i2c_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_I2C0,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_i2c_read_data_dma_setup(void) { // 设置DMA #define I2C_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_i2c_rxfifo_to_dma(I2C_DMA_RX_CHANNEL, read_data, sizeof(read_data)); // 更新需要传输的数据 I2C_CtrlUpdateDataCnt(APB_I2C0, DATA_CNT); // 打开I2C DMA I2C_DmaEnable(APB_I2C0,1); } 6.5.2.6 使用流程 设置GPIO，setup_peripherals_i2c_pin() 初始化I2C，setup_peripherals_i2c_module() 初始化DMA，setup_peripherals_dma_module() 检查中断状态，在中断中设置DMA读取数据，I2C_STATUS_CMPL中断代表传输结束 "],["ir-红外.html", "7 IR 红外 7.1 功能概述 7.2 使用说明", " 7 IR 红外 7.1 功能概述 支持红外发射&amp;接收 时序可调整，支持多种编码 7.2 使用说明 7.2.1 参数(不同编码的时间参数) //32KHz 调制时钟 #define FCLK 32000 //NEC 载波频率38KHz #define NEC_WAVE_FREQ 38000 // RC5 载波频率36KHz #define RC5_WAVE_FREQ 36000 // 计算载波频率发生器数据，由此产生如38KHz NEC的载波，NEC与TC9012通用38KHz载波 #define IR_WAVE_NEC_TC9012_FREQ (OSC_CLK_FREQ/NEC_WAVE_FREQ) #define IR_WAVE_RC5_FREQ (OSC_CLK_FREQ/RC5_WAVE_FREQ) //通过FCLK产生各种协议每bit位调制周期最小单位，如NEC协议中，560us为最小调制周期，NEC：bit 0：560us载波+560us不载波，bit 1：560 us载波+560*3 us不载波 #define NEC_UINT (FCLK*560/1000000+1) #define TC9012_UINT (FCLK*260/1000000+1) #define RC5_UINT (FCLK*889/1000000+1) //不必要的参数 #define INESSENTIAL 0 typedef struct { uint16_t timer1;//发送模式下，表示引导码低电平时间：如NEC为16*UNIT = 9ms，接收模式下与timer2组成检测引导码低电平窗口 uint16_t timer2;//发送模式下，表示重复码低电平时间：如NEC为4*UNIT = 2.25ms，接收模式下与timer1组成检测引导码低窗口 uint16_t timer3;//发送模式下，表示引导码高电平时间：如NEC为8*UNIT = 4.5ms，接收模式下与timer4组成检测引导码高电平+低电平窗口 uint16_t timer4;//发送模式下，表示重复码高电平时间：如NEC为UNIT = 560us，接收模式下与timer3组成检测引导码高电平+低电平窗口 uint16_t timer5;//接收时接收超时定时器，发射不必关注 uint16_t btimer1;//逻辑 0 的bit时长：如NEC = 2*UINT = 1.12ms. uint16_t btimer2;//逻辑 1 的bit时长：如NEC = 4*UINT = 2.25ms. uint16_t bit_cycle;//发射模式下：bit调制周期最小单位，如NEC为560us，接收模式下为bit检测超时时间 uint16_t carry_low;//载波低电平时长，与carry_high组合形成占空比可调的载波波形，如NEC为38KHz 30%占空比载波则carry_low = 2/3*载波周期，carry_high = 1/3*载波周期 uint16_t carry_high;//载波高电平时长，与carry_low组合形成占空比可调的载波波形，如NEC为38KHz 30%占空比载波则carry_low = 2/3*载波周期，carry_high = 1/3*载波周期 }Ir_mode_param_t; //由于发送和接收初始化不同参数 定义结构体表示接收发送初始化参数。 typedef struct{ Ir_mode_param_t param_tx; Ir_mode_param_t param_rx; }Ir_type_param_t; //定义初始化数据，初始化函数体根据不同协议自动从此表适配参数 const static Ir_type_param_t t_ir_type_param_table[] = { {//NEC param { //TX 16*NEC_UINT-1,4*NEC_UINT-1,8*NEC_UINT-1,1*NEC_UINT-1,INESSENTIAL, 2*NEC_UINT-1, 4*NEC_UINT-1,1*NEC_UINT-1,IR_WAVE_NEC_TC9012_FREQ*2/3,IR_WAVE_NEC_TC9012_FREQ*1/3}, { //RX 14*NEC_UINT-1,18*NEC_UINT-1,22*NEC_UINT-1,26*NEC_UINT-1,0xfff, INESSENTIAL,2*NEC_UINT-1,0x7f,INESSENTIAL,INESSENTIAL}, }, {//TC9012 param { //TX 16*TC9012_UINT-1,8*TC9012_UINT-1,16*TC9012_UINT-1,2*TC9012_UINT-1,INESSENTIAL, 4*TC9012_UINT-1,6*TC9012_UINT-1,2*TC9012_UINT-1,IR_WAVE_NEC_TC9012_FREQ*2/3,IR_WAVE_NEC_TC9012_FREQ*1/3}, { //RX 28*TC9012_UINT-1,36*TC9012_UINT-1,44*TC9012_UINT-1,32*TC9012_UINT-1,0xfff,INESSENTIAL, 4*TC9012_UINT-1,0x7f,INESSENTIAL,INESSENTIAL}, }, {//RC5 param { //TX 2*RC5_UINT-1,2*RC5_UINT-1,INESSENTIAL,INESSENTIAL,INESSENTIAL,2*RC5_UINT-1, INESSENTIAL,1*RC5_UINT,IR_WAVE_RC5_FREQ*2/3,IR_WAVE_RC5_FREQ*1/3}, { //RX 1*RC5_UINT-2,1*RC5_UINT,3*RC5_UINT-1,5*RC5_UINT-1,INESSENTIAL,1*RC5_UINT-3, 1*RC5_UINT-1,2*RC5_UINT-1,INESSENTIAL,INESSENTIAL}, } }; 7.2.2 红外发射接收 7.2.2.1 配置pin #define IR_PIN GIO_GPIO_17 void setup_peripherals_ir_module(void) { // 打开时钟 // 大于等于GPIO 18则使用SYSCTRL_ClkGate_APB_GPIO1， 否则是SYSCTRL_ClkGate_APB_GPIO0 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ClkGate_APB_GPIO0) | (1 &lt;&lt; SYSCTRL_ClkGate_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_IR) | (1 &lt;&lt; SYSCTRL_ClkGate_APB_PinCtrl)); PINCTRL_SetPadMux(IR_PIN,IO_SOURCE_IR_DATA_OUT); platform_set_irq_callback(PLATFORM_CB_IRQ_IR_INT, IRQHandler_IR_INT, NULL); } 7.2.2.2 配置模块 static void user_ir_device_init(IR_IrMode_e mode,IR_TxRxMode_e tx_rx_mode,GIO_Index_t irpin) { IR_CtrlSetIrMode(APB_IR,mode); IR_CtrlSetTxRxMode(APB_IR,tx_rx_mode); IR_CtrlSetIrIntEn(APB_IR); if(IR_TXRX_MODE_TX_MODE == tx_rx_mode) { IR_TxConfigIrTxPol(APB_IR); IR_TxConfigCarrierCntClr(APB_IR); IR_TxConfigIrIntEn(APB_IR); IR_CarryConfigSetIrCarryLow(APB_IR,t_ir_type_param_table[mode].param_tx.carry_low); //30% pwm IR_CarryConfigSetIrCarryHigh(APB_IR,t_ir_type_param_table[mode].param_tx.carry_high); IR_TimeSetIrTime1(APB_IR,t_ir_type_param_table[mode].param_tx.timer1); IR_TimeSetIrTime2(APB_IR,t_ir_type_param_table[mode].param_tx.timer2); IR_TimeSetIrTime3(APB_IR,t_ir_type_param_table[mode].param_tx.timer3 ); IR_TimeSetIrTime4(APB_IR,t_ir_type_param_table[mode].param_tx.timer4); IR_CtrlIrSetBitTime1(APB_IR,t_ir_type_param_table[mode].param_tx.btimer1); IR_CtrlIrSetBitTime2(APB_IR,t_ir_type_param_table[mode].param_tx.btimer2); IR_CtrlIrSetIrBitCycle(APB_IR,t_ir_type_param_table[mode].param_tx.bit_cycle); PINCTRL_SetPadMux(irpin,IO_SOURCE_IR_DATA_OUT); } else{ IR_CtrlSetIrEndDetectEn(APB_IR);//end code detect en IR_CtrlSetIrIntVerifyEn(APB_IR); IR_CtrlIrUsercodeVerify(APB_IR); IR_CtrlIrDatacodeVerify(APB_IR); IR_TimeSetIrTime1(APB_IR,t_ir_type_param_table[mode].param_rx.timer1); IR_TimeSetIrTime2(APB_IR,t_ir_type_param_table[mode].param_rx.timer2); IR_TimeSetIrTime3(APB_IR,t_ir_type_param_table[mode].param_rx.timer3); IR_TimeSetIrTime4(APB_IR,t_ir_type_param_table[mode].param_rx.timer4); IR_TimeSetIrTime5(APB_IR,t_ir_type_param_table[mode].param_rx.timer5); IR_CtrlIrSetBitTime1(APB_IR,t_ir_type_param_table[mode].param_rx.btimer1); IR_CtrlIrSetBitTime2(APB_IR,t_ir_type_param_table[mode].param_rx.btimer2); IR_CtrlIrSetIrBitCycle(APB_IR,t_ir_type_param_table[mode].param_rx.bit_cycle); PINCTRL_SetPadMux(irpin,IO_SOURCE_IR_DATA_IN); } IR_CtrlEnable(APB_IR); } 7.2.2.3 IR 中断 static uint32_t IRQHandler_IR_INT(void *user_data) { if(IR_FsmGetIrTransmitOk(APB_IR)) ;//platform_printf(&quot;int ir send ok\\n&quot;); if(IR_FsmGetIrTxRepeat(APB_IR)) ;//platform_printf(&quot;int ir repeat ok\\n&quot;); return 0; } "],["ch-pinctrl.html", "8 管脚管理（PINCTRL）", " 8 管脚管理（PINCTRL） "],["pte简介.html", "9 PTE简介 9.1 功能描述 9.2 使用方法 9.3 编程指南", " 9 PTE简介 PTE全称Peripheral trigger engine，即外设触发引擎。 其主要作用是使外围设备可以通过其他外围设备或事件独立于CPU进行自主交互。PTE允许外围设备之间可以精确触发。 9.1 功能描述 9.1.1 特点 支持APB总线触发 支持4通道PTE 支持复用触发源或复用触发地址 支持产生CPU中断 9.1.2 PTE原理图 图 9.1: PTE原理图 9.1.3 功能 PTE具有不同外设之间的可编程内部通道，可以从src外设触发dst外设。PTE可以不依赖CPU而通过硬件的方式触发任务，因此任务可以在同步DFF所占用的周期内启动。 src外设通过pte_in_mask配置，dst外设通过pte_out_mask配置。在SOC中集成了4个PTE通道，每个通道可以通过通道使能信号来启用/禁用。 当DFF为高时PTE中断将挂起。在清除PTE中断之前，src外设中断必须被清除，否则另一个启动脉冲将发送到dst外设，这可能会产生未知的错误。 9.2 使用方法 9.2.1 方法概述 PTE使用方法总结为：建议不使用PTE中断，在dst外设中断里清PTE中断（或关闭PTE通道）。 1. 配置触发外设和被触发外设以及相应中断（被触发外设中断一定要有） 2. 配置要使用的PTE通道寄存器以及中断（建议不使用PTE中断） 3. 使能触发外设，等待PTE中断（如定义）和被触发外设来中断 4. 在PTE中断中清PTE mask（如定义） 5. 在被触发外设中断中清PTE中断（如定义），如果只触发一次则直接关闭PTE通道 9.2.2 注意点 不清src中断会循环通过PTE触发dst外设，使程序陷入死循环 不清PTE中断会循环触发dst外设，使程序陷入死循环 PTE中断优先级低容易被打断，在极端情况下如果dst外设来中断非常快会出问题（一般不会） 使用PTE中断会更多占用CPU资源并增加触发过程操作复杂度、增加出错风险，中断处理程序完全可以在src和dst中断中完成，所以强烈建议不要使用PTE中断 9.3 编程指南 9.3.1 src&amp;dst外设 当前PTE支持的src外设定义在SYSCTRL_PTE_SRC_INT中： typedef enum { SYSCTRL_PTE_I2C0_INT = 0, SYSCTRL_PTE_I2C1_INT = 1, SYSCTRL_PTE_SARADC_INT = 2, SYSCTRL_PTE_I2S_INT = 3, SYSCTRL_PTE_DMA_INT = 4, SYSCTRL_PTE_IR_INT = 5, SYSCTRL_PTE_KEYSCANNER_INT = 6, SYSCTRL_PTE_PWMC0_INT = 7, SYSCTRL_PTE_PWMC1_INT = 8, SYSCTRL_PTE_PWMC2_INT = 9, SYSCTRL_PTE_TIMER0_INT = 10, SYSCTRL_PTE_TIMER1_INT = 11, SYSCTRL_PTE_TIMER2_INT = 12, SYSCTRL_PTE_GPIO0_INT = 13, SYSCTRL_PTE_GPIO1_INT = 14, SYSCTRL_PTE_UART0_INT = 15, SYSCTRL_PTE_UART1_INT = 16, SYSCTRL_PTE_SPI0_INT = 17, SYSCTRL_PTE_SPI1_INT = 18, SYSCTRL_PTE_SPIFLASH = 19, SYSCTRL_PTE_RCT_CNT = 20, SYSCTRL_PTE_IR_WAKEUP = 21, SYSCTRL_PTE_USB_INT = 22, SYSCTRL_PTE_QDEC_INT = 23, SYSCTRL_PTE_SRC_INT_MAX = 24, } SYSCTRL_PTE_SRC_INT; dst外设定义在SYSCTRL_PTE_DST_EN中： typedef enum { SYSCTRL_PTE_I2C0_EN = 0, SYSCTRL_PTE_I2C1_EN = 1, SYSCTRL_PTE_SARADC_EN = 2, SYSCTRL_PTE_I2S_TX_EN = 3, SYSCTRL_PTE_I2S_RX_EN = 4, SYSCTRL_PTE_IR_EN = 5, SYSCTRL_PTE_KEYSCANNER_EN = 6, SYSCTRL_PTE_PWMC0_EN = 7, SYSCTRL_PTE_PWMC1_EN = 8, SYSCTRL_PTE_PWMC2_EN = 9, SYSCTRL_PTE_TIMER0_CH0_EN = 10, SYSCTRL_PTE_TIMER0_CH1_EN = 11, SYSCTRL_PTE_TIMER1_CH0_EN = 12, SYSCTRL_PTE_TIMER1_CH1_EN = 13, SYSCTRL_PTE_TIMER2_CH0_EN = 14, SYSCTRL_PTE_TIMER2_CH1_EN = 15, SYSCTRL_PTE_DST_EN_MAX = 16, } SYSCTRL_PTE_DST_EN; 通过PTE连接的src外设和dst外设需要在已注册枚举中选取。 9.3.2 驱动接口 PTE_ConnectPeripheral：PTE外设连接接口 PTE_EnableChennel：PTE通道使能接口 PTE_ChennelClose：PTE通道关闭接口 PTE_IrqProcess：PTE标准中断程序接口 PTE_OutPeripheralContinueProcess：dst外设中断标准PTE中继触发接口 PTE_OutPeripheralEndProcess：dst外设中断标准PTE结束接口 9.3.3 代码示例 下面以Timer0通过PTE通道0触发Timer1为例展示PTE的具体使用方法。 src外设和dst外设配置方法不在本文档介绍范围内，我们默认Timer0和Timer1已经配置好并注册好中断。 uint32_t Timer0Isr(void *user_data) { TMR_IntClr(APB_TMR0); return 0; } uint32_t Timer1Isr(void *user_data) { TMR_IntClr(APB_TMR1); PTE_OutPeripheralContinueProcess(0); return 0; } // 仅供参考，不建议注册PTE中断 uint32_t PTE0Isr(void *user_data) { PTE_IrqProcess(0); return 0; } void PTE_Test(void) { PTE_ConnectPeripheral(SYSCTRL_PTE_CHENNEL_0, SYSCTRL_PTE_TIMER0_INT, SYSCTRL_PTE_TIMER1_CH0_EN); TMR_Enable(APB_TMR0); } 上面示例会保留PTE通道0并等待下一次触发。如果想要触发之后直接关闭通道代码如下： uint32_t Timer1Isr(void *user_data) { TMR_IntClr(APB_TMR1); PTE_OutPeripheralEndProcess(0); return 0; } 关闭通道会断开Timer0和Timer1的连接，再次触发需要重新建立连接。 "],["ch-pwm.html", "10 增强型脉宽调制发生器（PWM） 10.1 PWM 工作模式 10.2 PCAP 10.3 PWM 使用说明 10.4 PCAP 使用说明", " 10 增强型脉宽调制发生器（PWM） 增强型脉宽调制发生器具有两大功能：生成脉宽调制信号（PWM），捕捉外部脉冲输入（PCAP）。 增强型脉宽调制发生器具备 3 个通道，每个通道都可以单独配置为 PWM 或者 PCAP 模式。 每个通道拥有独立的 FIFO。FIFO 里的每个存储单元为 2 个 20bit 数据。 FIFO 深度为 4，即最多存储 4 个单元，共 \\(8 \\times 20bit\\) 数据。 这里的 20bit 位宽是因为本硬件模块内部 PWM 使用的各计数器都是 20 比特。 可根据 FIFO 内的数据量触发中断或者 DMA 传输。 说明：TIMER 也支持生成脉宽调制信号，但是可配置的参数较简单，不支持死区等。 PWM 特性： 最多支持 3 个 PWM 通道，每一个通道包含 A、B 两个输出 每个通道参数独立 支持死区 支持通过 DMA 更新 PWM 配置 PCAP 特性： 支持 3 个 PCAP 通道，每一个通道包含两个输入 支持捕捉上升沿、下降沿 支持通过 DMA 读取数据 10.1 PWM 工作模式 PWM 使用的时钟频率可配置，请参考 SYSCTRL。 每个 PWM 通道支持以下多种工作模式： typedef enum { ..._UP_WITHOUT_DIED_ZONE = ..., ..._UP_WITH_DIED_ZONE = ..., ..._UPDOWN_WITHOUT_DIED_ZONE = ..., ..._UPDOWN_WITH_DIED_ZONE = ..., ..._SINGLE_WITHOUT_DIED_ZONE = ..., ..._DMA = ..., ..._PCAP = ..., } PWM_WorkMode_t; 10.1.1 最简单的模式：UP_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH &lt;= cnt; B = !A; } 10.1.2 UP_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH，DZONE_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH + DZONE_TH &lt;= cnt; B = DZONE_TH &lt;= cnt &lt; HIGH_TH); } 10.1.3 UPDOWN_WITHOUT_DIED_ZONE 此模式需要的门限参数与 UP_WITHOUT_DIED_ZONE 相同。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH &lt;= cnt &lt;= PERA_TH + HIGH_TH; B = !A; } 10.1.4 UPDOWN_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH。 以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH + DZONE_TH &lt;= cnt &lt;= PERA_TH + HIGH_TH; B = (cnt &lt; PERA_TH - HIGH_TH) || (cnt &gt; PERA_TH + HIGH_TH + DZONE_TH); } 10.1.5 SINGLE_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。此模式只产生一个脉冲，以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt++; A = HIGH_TH &lt;= cnt &lt; PERA_TH; B = !A; } 以上伪代码仅用于辅助描述硬件行为，与实际行为可以存在微小差异。 10.1.6 DMA 模式 此模式支持通过 DMA 实时更新门限。 10.1.7 输出控制 对于每个通道的每一路输出，另有 3 个参数控制最终的两路输出：掩膜、停机输出值、反相。 最终的输出以伪代码描述如下： output_control(v) { if (掩膜 == 1) return A 路输出 0、B 路输出 1; if (本通道已停机) return 停机输出值; if (反相) v = !v; return v; } 10.2 PCAP PCAP 每个通道包含两路输入。PCAP 内部有一个单独的 32 比特计数器2， 当检测到输入信号变化（包含上升沿和下降沿）时，PCAP 将计数器的值及边沿变化信息作为一个存储单元压入 FIFO： struct data0 { uint32_t cnt_high:12; uint32_t p_cap_0_p:1; // A 路出现上升沿 uint32_t p_cap_0_n:1; // A 路出现下降沿 uint32_t p_cap_1_p:1; // B 路出现上升沿 uint32_t p_cap_1_n:1; // B 路出现下降沿 uint32_t tag:4; uint32_t padding:12; }; struct data1 { uint32_t cnt_low:20; uint32_t padding:12; }; 通过复位整个模块可以清零 PCAP 计数器。 10.3 PWM 使用说明 10.3.1 启动与停止 共有两个开关与 PWM 的启动和停止有关：使能（Enable）、停机控制（HaltCtrl）。只有当 Enable 为 1， HaltCtrl 为 0 时，PWM 才真正开始工作。 相关的 API 为： // 使能 PWM 通道 void PWM_Enable( const uint8_t channel_index, // 通道号 const uint8_t enable // 使能或禁用 ); // PWM 通道停机控制 void PWM_HaltCtrlEnable( const uint8_t channel_index, // 通道号 const uint8_t enable // 停机(1) 或运转(0) ); 10.3.2 配置工作模式 void PWM_SetMode( const uint8_t channel_index, // 通道号 const PWM_WorkMode_t mode // 模式 ); 10.3.3 配置门限 // 配置 PERA_TH void PWM_SetPeraThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 DZONE_TH void PWM_SetDiedZoneThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 HIGH_TH void PWM_SetHighThreshold( const uint8_t channel_index, const uint8_t multi_duty_index, // 对于 ING916XX，此参数无效 const uint32_t threshold); 各门限值最大支持 0xFFFFF，共 20 个比特。 10.3.4 输出控制 // 掩膜控制 void PWM_SetMask( const uint8_t channel_index, // 通道号 const uint8_t mask_a, // A 路掩膜 const uint8_t mask_b // B 路掩膜 ); // 配置停机输出值 void PWM_HaltCtrlCfg( const uint8_t channel_index, // 通道号 const uint8_t out_a, // A 路停机输出值 const uint8_t out_b // B 路停机输出值 ); // 反相 void PWM_SetInvertOutput( const uint8_t channel_index, // 通道号 const uint8_t inv_a, // A 路是否反相 const uint8_t inv_b // B 路是否反相 ); 10.3.5 综合示例 下面的例子将 channel_index 通道配置成输出频率为 frequency、占空比为 (on_duty)% 的方波， 涉及 3 个关键参数： 生成这种最简单的 PWM 信号需要的模式为 UP_WITHOUT_DIED_ZONE； PERA_TH 控制输出信号的频率，设置为 PWM_CLOCK_FREQ / frequency； HIGH_TH 控制信号的占空比，设置为 PERA_TH * (100 - on_duty) % void PWM_SetupSimple( const uint8_t channel_index, const uint32_t frequency, const uint16_t on_duty) { uint32_t pera = PWM_CLOCK_FREQ / frequency; uint32_t high = pera &gt; 1000 ? pera / 100 * (100 - on_duty) : pera * (100 - on_duty) / 100; PWM_HaltCtrlEnable(channel_index, 1); PWM_Enable(channel_index, 0); PWM_SetPeraThreshold(channel_index, pera); PWM_SetHighThreshold(channel_index, 0, high); PWM_SetMode(channel_index, PWM_WORK_MODE_UP_WITHOUT_DIED_ZONE); PWM_SetMask(channel_index, 0, 0); PWM_Enable(channel_index, 1); PWM_HaltCtrlEnable(channel_index, 0); } 10.3.6 使用 DMA 实时更新配置 使用 DMA 能够实时更新配置（相当于工作在 UP_WITHOUT_DIED_ZONE，但是每个循环使用不同的参数）： 每当 PWM 计数器计完一圈回零时，自动使用来自 DMA 的数据更新配置。 这些数据以 2 个 uint32_t 为一组，依次表示 HIGH_TH 和 PERA_TH。 void PWM_DmaEnable( const uint8_t channel_index, // 通道号 uint8_t trig_cfg, // DMA 请求触发门限 uint8_t enable // 使能 ); 当 PWM 内部 FIFO 数据少于 trig_cfg，PWM 请求 DMA 传输数据。PWM FIFO 深度为 4（指可以存储 4 组 PWM 配置）， 所以 trig_cfg 的取值范围为 \\(1..4\\)。 10.4 PCAP 使用说明 10.4.1 配置 PCAP 模式 要启用 PCAP 模式，需要 5 个步骤： 关闭整个模块的时钟（参考 SYSCTRL） 使用 PCAP_Enable 使能 PCAP 模式 void PCAP_Enable( const uint8_t channel_index // 通道号 ); 打开整个模块的时钟（参考 SYSCTRL） 配置 DMA 传输 配置 PCAP 的 DMA 传输同样也是使用 PWM_DmaEnable。 当 PCAP 通道 FIFO 内存储的数据多于 trig_cfg，请求 DMA 传输数据。trig_cfg 的取值范围为 \\(0..4\\)。 void PWM_DmaEnable( const uint8_t channel_index, // 通道号 uint8_t trig_cfg, // DMA 请求触发门限 uint8_t enable // 使能 ); 使能计数器 void PCAP_CounterEnable( uint8_t enable // 使能(1)/禁用(0) ); 10.4.2 读取计数器 uint32_t PCAP_ReadCounter(void); 所有 6 路输入共有此计数器。 "],["ch-rtc.html", "11 实时时钟（RTC） 11.1 功能描述 11.2 使用说明", " 11 实时时钟（RTC） 11.1 功能描述 实时时钟是一个独立的定时器。RTC模块拥有一组连续计数的计数器，在相应的软件配置下， 可提供时钟日历的功能。修改计数器的值可以重新设置系统当前的时间和日期。 11.2 使用说明 11.2.1 RTC使能 使用 RTC_Enable 使能RTC。 void RTC_Enable(uint8_t enable); 11.2.2 获取当前日期 使用 RTC_GetTime 获取当前时间（包括时分秒）。 uint16_t RTC_GetTime( uint8_t *hour, uint8_t *minute, uint8_t *second ); 11.2.3 修改日期 使用 RTC_ModifyTime 修改当前时间。 void RTC_ModifyTime( uint16_t day, uint8_t hour, uint8_t minute, uint8_t second ); ws ### 配置闹钟 使用 RTC_ConfigAlarm void RTC_ConfigAlarm( uint8_t hour, uint8_t minute, uint8_t second ); 11.2.4 配置中断请求 使用 RTC_EnableIRQ 配置并使能RTC中断请求。 void RTC_EnableIRQ(uint32_t mask); 其中的 mask 为RTC中断类型，一共有六种： typedef enum { RTC_IRQ_ALARM = 0x04, RTC_IRQ_DAY = 0x08, RTC_IRQ_HOUR = 0x10, RTC_IRQ_MINUTE = 0x20, RTC_IRQ_SECOND = 0x40, RTC_IRQ_HALF_SECOND = 0x80, } rtc_irq_t; 例如将 RTC 设置为alarm中断 RTC_EnableIRQ(RTC_IRQ_ALARM); 例如将 RTC 设置为day中断 RTC_EnableIRQ(RTC_IRQ_DAY); 例如将 RTC 设置为hour中断 RTC_EnableIRQ(RTC_IRQ_HOUR); 例如将 RTC 设置为minute中断 RTC_EnableIRQ(RTC_IRQ_MINUTE); 例如将 RTC 设置为second中断 RTC_EnableIRQ(RTC_IRQ_SECOND); 例如将 RTC 设置为half-second中断 RTC_EnableIRQ(RTC_IRQ_HALF_SECOND); 11.2.5 获取当前中断状态 使用 RTC_GetIntState 获取当前RTC的中断状态。 uint32_t RTC_GetIntState(void); 11.2.6 清除中断 使用 RTC_ClearIntState 清除当前RTC的中断状态。 void RTC_ClearIntState(uint32_t state); 11.2.7 处理中断状态 用 RTC_GetIntState 获取RTC上的中断触发，返回非 0 值表示RTC上产生了中断请求；RTC产生中断后， 需要消除中断状态方可再次触发。利用 RTC_ClearIntState可清除RTC的中断触发状态。 "],["spi功能概述.html", "12 SPI功能概述 12.1 SPI使用说明 12.2 场景1：只读只写不带DMA 12.3 场景2：只读只写并且使用DMA 12.4 场景3：同时读写不带DMA 12.5 场景4：同时读写并且使用DMA", " 12 SPI功能概述 两个SPI模块 支持SPI主&amp;从模式 支持Quad SPI，可以执行代码 独立的RX&amp;TX FIFO，深度为8个word 支持DMA 12.1 SPI使用说明 以下场景中均以SPI1为例，如果需要SPI0则可以根据情况修改 12.2 场景1：只读只写不带DMA 其中SPI主配置为只写模式，SPI从配置为只读模式，CPU操作读写，没有使用DMA 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 12.2.1 SPI主配置 12.2.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 12.2.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_ONLY;// SPI只写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 12.2.1.3 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 12.2.1.4 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 填写数据到TX FIFO，这个例子中DATA_LEN等于FIFO的深度（8），如果大于8，可以分为多次发送 for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); } 12.2.1.5 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 12.2.2 SPI从配置 12.2.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 12.2.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_READ_ONLY;// SPI 只读 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 12.2.2.3 SPI 接收数据 uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1), i; if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { /* check if rx fifo still have some left data */ // 检查当前RX FIFO中有效值的个数，根据个数读取RX FIFO uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 12.2.2.4 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 观察SPI中断，中断触发代表当前传输结束 12.3 场景2：只读只写并且使用DMA 其中SPI主配置为只写模式，SPI从配置为只读模式，同时使用DMA进行读写 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 12.3.1 SPI主配置 12.3.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 12.3.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_ONLY;// SPI只写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 12.3.1.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 12.3.1.4 SPI DMA设置 // 此处是以SPI1为例 void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 12.3.1.5 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 12.3.1.6 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); // 初始化中已经设置了pParam.eWriteTransCnt，如果需要调整则可以调用这个API apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // DMA共有8个channel #define SPI_DMA_TX_CHANNEL (0)//DMA channel 0 // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 关闭 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,0); } 12.3.1.7 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 12.3.2 SPI从配置 12.3.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 12.3.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_READ_ONLY;// SPI 只读 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = 0; pParam.TxThres = 0; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 12.3.2.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 12.3.2.4 SPI DMA设置 // 此处是以SPI1为例 void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 12.3.2.5 SPI 接收数据 uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 打开SPI DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); // 功能等同于重新设置pParam.eReadTransCnt，代表一次传输的单位个数 apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); #define SPI_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 12.3.2.6 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { peripherals_spi_read_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 12.3.2.7 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 设置接收DMA，peripherals_spi_read_data() 观察SPI中断，中断触发代表当前接收结束 12.4 场景3：同时读写不带DMA 其中SPI主从都配置为同时读写模式，CPU操作读写，没有使用DMA 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 12.4.1 SPI主配置 12.4.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 12.4.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 12.4.1.3 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 12.4.1.4 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 填写数据到TX FIFO，这个例子中DATA_LEN等于FIFO的深度（8），如果大于8，可以分为多次发送接收， // 每次发送完8个单位，需要读取RX FIFO中的数据 for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 读取当前RX FIFO中有效值的个数，然后从RX FIFO中读取返回值 uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } } 12.4.1.5 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 12.4.2 SPI从配置 12.4.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 12.4.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 12.4.2.3 SPI 接收数据 void peripherals_spi_push_data(void) { for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } } uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1), i; if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { /* check if rx fifo still have some left data */ // 检查当前RX FIFO中有效值的个数，根据个数读取RX FIFO uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } // 根据需要填充下一次发送的SPI数据 peripherals_spi_push_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 12.4.2.4 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 根据需要填充TX FIFO，peripherals_spi_push_data() 观察SPI中断，中断触发代表当前传输结束 12.5 场景4：同时读写并且使用DMA 其中SPI主从配置为同时读写模式，同时使用DMA进行读写 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 // RX FIFO 和 TX FIFO 使用两个DMA channel #define SPI_DMA_TX_CHANNEL (0)//DMA channel 0 #define SPI_DMA_RX_CHANNEL (1)//DMA channel 1 12.5.1 SPI主配置 12.5.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 12.5.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 12.5.1.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 12.5.1.4 SPI DMA设置 // 此处是以SPI1为例 // 分别设置RX FIFO 和 TX FIFO的DMA void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 12.5.1.5 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 12.5.1.6 SPI 接收数据 uint32_t read_data[DATA_LEN] = {0,};//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向存储接收数据的地址 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 12.5.1.7 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_push_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); } void peripherals_spi_send_data(void) { // 分别设置接收和发射的DMA peripherals_spi_read_data(); peripherals_spi_push_data(); // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 关闭 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,0); } 12.5.1.8 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 12.5.2 SPI从配置 12.5.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 12.5.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = 0; pParam.TxThres = 0; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 12.5.2.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 12.5.2.4 SPI DMA设置 // 此处是以SPI1为例 // 分别设置RX FIFO 和 TX FIFO的DMA void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 12.5.2.5 SPI 接收数据 uint32_t read_data[DATA_LEN] = {0,};//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向存储接收数据的地址 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 12.5.2.6 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_push_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); } 12.5.2.7 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { // 根据情况决定是否需要准备下一次的接收和发射 peripherals_spi_read_data(); peripherals_spi_push_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 12.5.2.8 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 设置接收DMA，peripherals_spi_read_data(); 设置发射DMA，peripherals_spi_push_data(); 观察SPI中断，中断触发代表当前接收结束 "],["ch-sysctrl.html", "13 系统控制（SYSCTRL） 13.1 功能概述 13.2 使用说明", " 13 系统控制（SYSCTRL） 13.1 功能概述 SYSCTRL 负责管理、控制各种片上外设，主要功能有： 外设的复位 外设的时钟管理，包括时钟源、频率设置、门控等 DMA 规划 其它功能 13.1.1 外设标识 SYSCTRL 为外设定义了几种不同的标识。最常见的一种标识为： typedef enum { SYSCTRL_ITEM_APB_GPIO0 , SYSCTRL_ITEM_APB_GPIO1 , // ... SYSCTRL_ITEM_NUMBER, } SYSCTRL_Item; 这种标识用于外设的复位、时钟门控等。SYSCTRL_ResetItem 和 SYSCTRL_ClkGateItem 是 SYSCTRL_Item 的两个别名。 下面这种标识用于 DMA 规划： typedef enum { SYSCTRL_DMA_UART0_RX = 0, SYSCTRL_DMA_UART1_RX = 1, //... } SYSCTRL_DMA; 13.1.2 时钟树 32KiHz 时钟（clk_32k） 32k 时钟有两个来源：内部 RC 电路，外部 32768Hz 晶体。 PLL 输入的 24MHz 时钟（clk_pll_in） 24MHz 时钟有两个来源：内部 RC 电路，外部 24MHz 晶体。 PLL 输出（clk_pll） clk_pll 的频率 \\(f_{pll}\\) 可配置，受 \\(loop\\)、\\(div_{pre}\\) 和 \\(div_{output}\\) 等 3 个参数控制： \\[f_{vco}=\\frac{f_{osc}\\times loop}{div_{pre}}\\] \\[f_{pll}=\\frac{f_{vco}}{div_{output}}\\] 这里，\\(f_{osc}\\) 即 clk_pll_in 的频率。要求 \\(f_{vco} \\in [60,600]MHz\\)， \\(f_{osc}/div_{pre} \\in [2,24]MHz\\)。 sclk_fast 与 sclk_slow clk_pll 经过门控后的时钟称为 sclk_fast，24MHz 时钟 clk_pll_in 经过门控后称为 sclk_slow。 hclk sclk_fast 经过分频后得到 hclk。下列外设（包括 MCU）固定使用这个时钟3： DMA 片内 Flash QSPI USB4 其它内部模块如 AES、Cache 等 hclk 经过分频后得到 pclk。pclk 主要用于硬件内部接口。 sclk_slow 的进一步分频 sclk_slow 经过若干独立的分频器得到以下多种时钟： sclk_slow_pwm_div：专供 PWM 选择使用 sclk_slow_timer_div：供 TIMER0、TIMER1、TIMER2 选择使用 sclk_slow_ks_div：专供 KeyScan 选择使用 sclk_slow_adc_div：供 EFUSE、ADC、IR 选择使用 sclk_slow_pdm_div：专供 PDM 选择使用 sclk_fast 的进一步分频： sclk_fast 经过若干独立的分频器得到以下多种时钟： sclk_fast_i2s_div：专供 I2S 选择使用 sclk_fast_qspi_div：专供 QSPI 选择使用 sclk_fast_flash_div：专供片内 Flash 选择使用 sclk_fast_usb_div：专供 USB 选择使用 各硬件外设可配置的时钟源汇总如表 13.1。 表 13.1: 各硬件外设的时钟源 外设 时钟源 GPIO0、GPIO1 选择 sclk_slow 或者 clk_32k TMR0、TMR1、TMR2 独立配置 sclk_slow_timer_div 或者 clk_32k WDT clk_32k PWM sclk_slow_pwm_div 或者 clk_32k PDM sclk_slow_pdm_div QDEC 对 hclk 或者 sclk_slow 分频 KeyScan sclk_slow_ks_div 或者 clk_32k IR、ADC、EFUSE 独立配置 sclk_slow_adc_div 或者 sclk_slow DMA hclk SPI0 sclk_fast_qspi_div 或者 sclk_slow I2S sclk_fast_i2s_div 或者 sclk_slow UART0、UART1、SPI1 独立配置 hclk 或者 sclk_slow I2C0、I2C1 sclk_slow 13.1.3 DMA 规划 由于 DMA 支持的硬件握手信号只有 16 种，无法同时支持所有外设。 因此需要事先确定将要的外设握手信号，并通过 SYSCTRL_SelectUsedDmaItems 接口声明。 一个外设可能具备一个以上的握手信号，需要注意区分。比如 UART0 有两个握手信号 UART0_RX 和 UART0_TX，分别用于触发 DMA 发送请求（通过 DMA 传输接收到的数据）和读取请求（向 DMA 请 求新的待发送数据）。外设握手信号定义在 SYSCTRL_DMA 内： typedef enum { SYSCTRL_DMA_UART0_RX = 0, SYSCTRL_DMA_UART1_RX = 1, // ... } SYSCTRL_DMA; 13.2 使用说明 13.2.1 外设复位 通过 SYSCTRL_ResetBlock 复位外设，通过 SYSCTRL_ReleaseBlock 释放复位。 void SYSCTRL_ResetBlock(SYSCTRL_ResetItem item); void SYSCTRL_ReleaseBlock(SYSCTRL_ResetItem item); 13.2.2 时钟门控 通过 SYSCTRL_SetClkGate 设置门控（即关闭时钟），通过 SYSCTRL_ClearClkGate 消除门控（即恢复时钟）。 void SYSCTRL_SetClkGate(SYSCTRL_ClkGateItem item); void SYSCTRL_ClearClkGate(SYSCTRL_ClkGateItem item); SYSCTRL_SetClkGateMulti 和 SYSCTRL_ClearClkGateMulti 可以同时控制多个外设的门控。 items 参数里的各个比特与 SYSCTRL_ClkGateItem 里的各个外设一一对应。 void SYSCTRL_SetClkGateMulti(uint32_t items); void SYSCTRL_ClearClkGateMulti(uint32_t items); 13.2.3 时钟配置 举例如下。 clk_pll 与 hclk 使用 SYSCTRL_ConfigPLLClk 配置 clk_pll： int SYSCTRL_ConfigPLLClk( uint32_t div_pre, uint32_t loop, uint32_t div_output); 例如，将 hclk 配置为 220MHz 并读取到变量： SYSCTRL_ConfigPLLClk(6, 110, 1); SYSCTRL_SelectHClk(SYSCTRL_CLK_PLL_DIV_1 + 1); uint32_t SystemCoreClock = SYSCTRL_GetHClk(); 为硬件 I2S 配置时钟 使用 SYSCTRL_SelectI2sClk 为 I2S 配置时钟： void SYSCTRL_SelectI2sClk(SYSCTRL_ClkMode mode); SYSCTRL_ClkMode 的定为为： typedef enum { SYSCTRL_CLK_OSC, // 使用 sclk_slow SYSCTRL_CLK_HCLK, // 使用 hclk SYSCTRL_CLK_ADC_DIV = ..., // 使用 sclk_slow_adc_div SYSCTRL_CLK_PLL_DIV_1 = ...,// 对 sclk_fast 分频 } SYSCTRL_ClkMode; 根据表 13.1 可知，I2S 可使用 _slk_slow： SYSCTRL_SelectI2sClk(SYSCTRL_CLK_OSC); 或者独占一个分频器，对 sclk_fast 分频得到 sclk_fast_i2s_div，比如使用 sclk_fast 的 55 分频： SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_1 + 4); 读取时钟频率 使用 SYSCTRL_GetClk 可获得指定外设的时钟频率： uint32_t SYSCTRL_GetClk(SYSCTRL_Item item); 比如， // I2S 使用 PLL 的 5 分频 SYSCTRL_SelectI2sClk(SYSCTRL_CLK_PLL_DIV_1 + 4); // freq = sclk_fast 的频率 / 5 uint32_t freq = SYSCTRL_GetClk(SYSCTRL_ITEM_APB_I2S); 13.2.4 DMA 规划 使用 SYSCTRL_SelectUsedDmaItems 配置要使用的 DMA 握手信号： int SYSCTRL_SelectUsedDmaItems( uint32_t items // 各比特与 SYSCTRL_DMA 一一对应 ); 使用 SYSCTRL_GetDmaId 可获取为某外设握手信号的 DMA 信号 ID，如果返回 -1， 说明没有规划该外设握手信号6： int SYSCTRL_GetDmaId(SYSCTRL_DMA item); 每个外设可单独对 hclk 门控。 仅高速时钟。 \\(5=1 + 4\\) SYSCTRL_SelectUsedDmaItems 的 items 参数里对应的比特为 0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
