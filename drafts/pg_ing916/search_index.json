[["index.html", "ING916XX 系列芯片外设开发者手册 1 版本历史", " ING916XX 系列芯片外设开发者手册 Ingchips Technology Co., Ltd. 1 版本历史 版本 信息 日期 0.1 初始版本 2022-xx-xx "],["ch-overview.html", "2 概览 2.1 缩略语及术语 2.2 参考文档", " 2 概览 ING916XX 系列芯片支持蓝牙 5.3 规范，内置高性能 32bit RISC MCU（支持 DSP 和 FPU）、Flash、低功耗 PMU， 以及丰富的外设、高性能低功耗 BLE RF 收发机。BLE 发射功率。 本文介绍 SoC 外设及其开发方法。每个章节介绍一种外设，各种外设与芯片数据手册之外设一一对应， 基于 API 的兼容性、避免误解等因素，存在以下例外： PINCTRL 对应于数据手册之 IOMUX PCAP 对应于数据手册之 PCM SYSCTRL 是一个“虚拟”外设，负责管理各种 SoC 功能，组合了几种相关的硬件模块 SDK 外设驱动的源代码开放，其中包含很多常数，而且几乎没有注释 —— 这是有意为之，开发者只需要关注头文件，而不要尝试修改源代码。 2.1 缩略语及术语 表 2.1: 缩略语 缩略语 说明 GPIO 通用输入输出（General-Purpose Input/Output） PCAP 脉冲捕捉（Pulse CAPture） PWM 脉宽调制信号（Pulse Width Modulation） UART 通用异步收发器（Universal Asynchronous Receiver/Transmitter） 2.2 参考文档 Bluetooth SIG1 ING916XX 系列芯片数据手册 https://www.bluetooth.com/ "],["ch-gpio.html", "3 通用输入输出（GPIO） 3.1 功能概述 3.2 使用说明", " 3 通用输入输出（GPIO） 3.1 功能概述 GPIO 模块常用于驱动 LED 或者其它指示器，控制片外设备，感知数字信号输入，检测信号边沿， 或者从低功耗状态唤醒系统。ING916XX 系列芯片内部支持最多 36 个 GPIO，通过 PINCTRL 可将 GPIO \\(n\\) 引出到芯片 IO 管脚 \\(n\\)。 特性： 每个 GPIO 都可单独配置为输入或输出 每个 GPIO 都可作为中断请求，中断触发方式支持边沿触发（上升、下降单沿触发，或者双沿触发） 和电平触发（高电平或低电平） 硬件去抖 在硬件上存在 两个 GPIO 模块，每个模块包含 18 个 GPIO，相应地定义了两个 SYSCTRL_Item： typedef enum { SYSCTRL_ITEM_APB_GPIO0 , SYSCTRL_ITEM_APB_GPIO1 , // ... } SYSCTRL_Item; 注意按照所使用的 GPIO 管脚打开对应的 GPIO 模块。 3.2 使用说明 3.2.1 设置 IO 方向 在使用 GPIO 之前先按需要配置 IO 方向： 需要用于输出信号时：配置为输出 需要用于读取信号时：配置为输入 需要用于生产中断请求时：配置为输入 需要三态时：配置为三态 使用 GIO_SetDirection 配置 GPIO 的方向。GPIO 支持四种方向： typedef enum { GIO_DIR_INPUT, // 输入 GIO_DIR_OUTPUT, // 输出 GIO_DIR_BOTH, // 同时支持输入、输出 GIO_DIR_NONE // 三态 } GIO_Direction_t; 如无必要，不要使用 GIO_DIR_BOTH。 3.2.2 读取输入 使用 GIO_ReadValue 读取某个 GPIO 当前输入的电平信号，例如读取 GPIO 0 的输入： uint8_t value = GIO_ReadValue(GIO_GPIO_0); 使用 GIO_ReadAll 可以同时读取所有 GPIO 当前输入的电平信号。其返回值的第 \\(n\\) 比特 （第 0 比特为最低比特）对应 GPIO \\(n\\) 的输入；如果 GPIO \\(n\\) 当前不支持输入，那么第 \\(n\\) 比特为 0： uint64_t GIO_ReadAll(void); 3.2.3 设置输出 使用 GIO_WriteValue 设置某个 GPIO 输出的电平信号，例如使 GPIO 0 输出高电平（1）： GIO_WriteValue(GIO_GPIO_0, 1); 3.2.4 配置中断请求 使用 GIO_ConfigIntSource 配置 GPIO 生成中断请求。 void GIO_ConfigIntSource( const GIO_Index_t io_index, // GPIO 编号 const uint8_t enable, // 使能的边沿或者电平类型组合 const GIO_IntTriggerType_t type // 触发类型 ); 其中的 enable 为以下两个值的组合（0 表示禁止产生中断请求）： typedef enum { ...LOGIC_LOW_OR_FALLING_EDGE = ..., // 低电平或者下降沿 ...LOGIC_HIGH_OR_RISING_EDGE = ... // 高电平或者上升沿 } GIO_IntTriggerEnable_t; 触发类型有两种： typedef enum { GIO_INT_EDGE, // 边沿触发 GIO_INT_LOGIC // 电平触发 } GIO_IntTriggerType_t; 例如将 GPIO 0 配置为上升沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为双沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE | ..._HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为高电平触发 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_LOGIC); 3.2.5 处理中断状态 用 GIO_GetIntStatus 获取某个 GPIO 上的中断触发状态，返回非 0 值表示该 GPIO 上产生了中断请求；用 GIO_GetAllIntStatus 一次性获取所有 GPIO 的中断触发状态， 第 \\(n\\) 比特（第 0 比特为最低比特）对应 GPIO \\(n\\) 上的中断触发状态。 GPIO 产生中断后，需要消除中断状态方可再次触发。用 GIO_ClearIntStatus 消除某个 GPIO 上中断状态，用 GIO_ClearAllIntStatus 一次性清除所有 GPIO 上可能存在的中断触发状态。 3.2.6 输入去抖 使用 GIO_DebounceCtrl 配置输入去抖参数，每个 GPIO 硬件模块使用单独的参数： void GIO_DebounceCtrl( uint8_t group_mask, // 比特 0 为 1 时配置模块 0 // 比特 1 为 1 时配置模块 1 uint8_t clk_pre_scale, GIO_DbClk_t clk // 防抖时钟选择 ); 所谓去抖就是过滤掉长度小于 (clk_pre_scale + 1) 个防抖时钟周期的“毛刺”。 防抖时钟共有 2 种： typedef enum { GIO_DB_CLK_32K, // 使用 32k 时钟 GIO_DB_CLK_PCLK, // 使用快速 PCLK } GIO_DbClk_t; 快速 PCLK 的具体频率参考 SYSCTRL。 通过 GIO_DebounceEn 为单个 GPIO 使能去抖。例如要在 GPIO 0 上启用硬件去抖，忽略宽度小于 \\(5/32768 \\approx 0.15 (ms)\\) 的“毛刺”： GIO_DebounceCtrl(1, 4, GIO_DB_CLK_32K); GIO_DebounceEn(GIO_GPIO_0, 1); "],["ch-pinctrl.html", "4 管脚管理（PINCTRL）", " 4 管脚管理（PINCTRL） "],["ch-pwm.html", "5 增强型脉宽调制发生器（PWM） 5.1 PWM 工作模式 5.2 PCAP 5.3 PWM 使用说明", " 5 增强型脉宽调制发生器（PWM） 增强型脉宽调制发生器具有两大功能：生成脉宽调制信号（PWM），捕捉外部脉冲输入（PCAP）。 说明：TIMER 也支持生成脉宽调制信号，但是可配置的参数较简单，不支持死区等。 PWM 特性： 支持 3 个 PWM 通道，每一个通道包含 A、B 两个输出 每个通道参数独立 支持死区 支持通过 DMA 更新 PWM 配置 PCAP 特性： 支持 3 个 PCAP 通道，每一个通道包含两个输入 支持捕捉上升沿、下降沿 支持通过 DMA 读取数据 5.1 PWM 工作模式 PWM 使用的时钟频率可配置，请参考 SYSCTRL。 每个 PWM 通道支持以下多种工作模式： typedef enum { ..._UP_WITHOUT_DIED_ZONE = ..., ..._UP_WITH_DIED_ZONE = ..., ..._UPDOWN_WITHOUT_DIED_ZONE = ..., ..._UPDOWN_WITH_DIED_ZONE = ..., ..._SINGLE_WITHOUT_DIED_ZONE = ..., } PWM_WordMode_t; 5.1.1 最简单的模式：UP_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH &lt;= cnt; B = !A; } 5.1.2 UP_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH，DZONE_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH + DZONE_TH &lt;= cnt; B = (DZONE_TH &lt;= cnt) &amp;&amp; (cnt &lt; HIGH_TH); } 5.1.3 UPDOWN_WITHOUT_DIED_ZONE 此模式需要的门限参数与 UP_WITHOUT_DIED_ZONE 相同。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH &lt;= cnt &lt; PERA_TH + HIGH_TH; B = !A; } 5.1.4 UPDOWN_WITHOUT_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH。 以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH + DZONE_TH &lt;= cnt &lt; PERA_TH + HIGH_TH; B = !(PERA_TH - HIGH_TH &lt;= cnt &lt; PERA_TH + HIGH_TH + DZONE_TH); } 5.1.5 SINGLE_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。此模式只产生一个脉冲，以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt++; A = HIGH_TH &lt;= cnt &lt; PERA_TH; B = !A; } 以上伪代码仅为辅助描述硬件行为，与实际行为可以存在差异，比如 &lt;= 与 &lt; 的差异。 5.1.6 输出控制 对于每个通道的每一路输出，另有 3 个参数控制最终的两路输出：掩膜、停机输出值、反相。 最终的输出以伪代码描述如下： output_control(v) { if (掩膜 == 1) return 0; if (本通道已停机) return 停机输出值; if (反相) v = !v; return v; } 5.2 PCAP 5.3 PWM 使用说明 5.3.1 启动与停止 共有两个开关与 PWM 的启动和停止有关：使能（Enable）、停机控制（HaltCtrl）。只有当 Enable 为 1， HaltCtrl 为 0 时，PWM 才真正开始工作。 相关的 API 为： // 使能 PWM 通道 void PWM_Enable( const uint8_t channel_index, // 通道号 const uint8_t enable // 使能或禁用 ); // PWM 通道停机控制 void PWM_HaltCtrlEnable( const uint8_t channel_index, // 通道号 const uint8_t enable // 停机(1) 或运转(0) ); 5.3.2 配置工作模式 void PWM_SetMode( const uint8_t channel_index, // 通道号 const PWM_WordMode_t mode // 模式 ); 5.3.3 配置门限 // 配置 PERA_TH void PWM_SetPeraThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 DZONE_TH void PWM_SetDiedZoneThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 HIGH_TH void PWM_SetHighThreshold( const uint8_t channel_index, const uint8_t multi_duty_index, // 对于 ING916XX，此参数无效 const uint32_t threshold); 5.3.4 输出控制 // 掩膜控制 void PWM_SetMask( const uint8_t channel_index, // 通道号 const uint8_t mask_a, // A 路掩膜 const uint8_t mask_b // B 路掩膜 ); // 配置停机输出值 void PWM_HaltCtrlCfg( const uint8_t channel_index, // 通道号 const uint8_t out_a, // A 路停机输出值 const uint8_t out_b // B 路停机输出值 ); // 反相 void PWM_SetInvertOutput( const uint8_t channel_index, // 通道号 const uint8_t inv_a, // A 路是否反相 const uint8_t inv_b // B 路是否反相 ); 5.3.5 综合示例 下面的例子将 channel_index 通道配置成输出频率为 frequency、占空比为 (on_duty)% 的方波。 生成这种最简单的 PWM 信号需要的模式为 UP_WITHOUT_DIED_ZONE。 void PWM_SetupSimple( const uint8_t channel_index, const uint32_t frequency, const uint16_t on_duty) { uint32_t pera = PWM_CLOCK_FREQ / frequency; uint32_t high = pera &gt; 1000 ? pera / 100 * (100 - on_duty) : pera * (100 - on_duty) / 100; PWM_HaltCtrlEnable(channel_index, 1); PWM_Enable(channel_index, 0); PWM_SetPeraThreshold(channel_index, pera); PWM_SetHighThreshold(channel_index, 0, high); PWM_SetMode(channel_index, PWM_WORK_MODE_UP_WITHOUT_DIED_ZONE); PWM_SetMask(channel_index, 0, 0); PWM_Enable(channel_index, 1); PWM_HaltCtrlEnable(channel_index, 0); } "],["spi功能概述.html", "6 SPI功能概述", " 6 SPI功能概述 两个SPI模块 支持SPI主&amp;从模式 支持Quad SPI 独立的RX&amp;TX FIFO，深度为8个word 支持DMA "],["spi使用说明.html", "7 SPI使用说明 7.1 场景1：只读只写不带DMA 7.2 场景2：只读只写并且使用DMA 7.3 场景3：同时读写不带DMA 7.4 场景4：同时读写并且使用DMA", " 7 SPI使用说明 以下场景中均以SPI1为例，如果需要SPI0则可以根据情况修改 7.1 场景1：只读只写不带DMA 其中SPI主配置为只写模式，SPI从配置为只读模式，CPU操作读写，没有使用DMA 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 7.1.1 SPI主配置 7.1.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 7.1.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_ONLY;// SPI只写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 7.1.1.3 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 7.1.1.4 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 填写数据到TX FIFO，这个例子中DATA_LEN等于FIFO的深度（8），如果大于8，可以分为多次发送 for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); } 7.1.1.5 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 7.1.2 SPI从配置 7.1.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 7.1.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_READ_ONLY;// SPI 只读 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 7.1.2.3 SPI 接收数据 uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1), i; if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { /* check if rx fifo still have some left data */ // 检查当前RX FIFO中有效值的个数，根据个数读取RX FIFO uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 7.1.2.4 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 观察SPI中断，中断触发代表当前传输结束 7.2 场景2：只读只写并且使用DMA 其中SPI主配置为只写模式，SPI从配置为只读模式，同时使用DMA进行读写 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 7.2.1 SPI主配置 7.2.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 7.2.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_ONLY;// SPI只写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 7.2.1.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 7.2.1.4 SPI DMA设置 // 此处是以SPI1为例 void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 7.2.1.5 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 7.2.1.6 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); // 初始化中已经设置了pParam.eWriteTransCnt，如果需要调整则可以调用这个API apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // DMA共有8个channel #define SPI_DMA_TX_CHANNEL (0)//DMA channel 0 // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 关闭 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,0); } 7.2.1.7 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 7.2.2 SPI从配置 7.2.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 7.2.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_READ_ONLY;// SPI 只读 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = 0; pParam.TxThres = 0; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 7.2.2.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 7.2.2.4 SPI DMA设置 // 此处是以SPI1为例 void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 7.2.2.5 SPI 接收数据 uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 打开SPI DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); // 功能等同于重新设置pParam.eReadTransCnt，代表一次传输的单位个数 apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); #define SPI_DMA_RX_CHANNEL (0)//DMA channel 0 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 7.2.2.6 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { peripherals_spi_read_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 7.2.2.7 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 设置接收DMA，peripherals_spi_read_data() 观察SPI中断，中断触发代表当前接收结束 7.3 场景3：同时读写不带DMA 其中SPI主从都配置为同时读写模式，CPU操作读写，没有使用DMA 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 7.3.1 SPI主配置 7.3.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 7.3.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 7.3.1.3 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 7.3.1.4 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_send_data(void) { // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 填写数据到TX FIFO，这个例子中DATA_LEN等于FIFO的深度（8），如果大于8，可以分为多次发送接收， // 每次发送完8个单位，需要读取RX FIFO中的数据 for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 读取当前RX FIFO中有效值的个数，然后从RX FIFO中读取返回值 uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } } 7.3.1.5 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 7.3.2 SPI从配置 7.3.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 7.3.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 7.3.2.3 SPI 接收数据 void peripherals_spi_push_data(void) { for(i = 0; i &lt; DATA_LEN; i++) { apSSP_WriteFIFO(APB_SSP1, write_data[i]); } } uint32_t read_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1), i; if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { /* check if rx fifo still have some left data */ // 检查当前RX FIFO中有效值的个数，根据个数读取RX FIFO uint32_t num = apSSP_GetDataNumInRxFifo(APB_SSP1); for(i = 0; i &lt; num; i++) { apSSP_ReadFIFO(APB_SSP1, &amp;read_data[i]); } // 根据需要填充下一次发送的SPI数据 peripherals_spi_push_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 7.3.2.4 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 根据需要填充TX FIFO，peripherals_spi_push_data() 观察SPI中断，中断触发代表当前传输结束 7.4 场景4：同时读写并且使用DMA 其中SPI主从配置为同时读写模式，同时使用DMA进行读写 配置之前需要决定使用的GPIO，如果是普通模式，则不需要SPI_MIC_WP和SPI_MIC_HOLD #define SPI_MIC_CLK GIO_GPIO_10 #define SPI_MIC_MOSI GIO_GPIO_11 #define SPI_MIC_MISO GIO_GPIO_12 #define SPI_MIC_CS GIO_GPIO_13 #define SPI_MIC_WP GIO_GPIO_14 #define SPI_MIC_HOLD GIO_GPIO_15 // RX FIFO 和 TX FIFO 使用两个DMA channel #define SPI_DMA_TX_CHANNEL (0)//DMA channel 0 #define SPI_DMA_RX_CHANNEL (1)//DMA channel 1 7.4.1 SPI主配置 7.4.1.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI1_CSN_OUT); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI1_MOSI_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 7.4.1.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_MASTER_MODE;// SPI主模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = DATA_LEN/2; pParam.TxThres = DATA_LEN/2; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 7.4.1.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 7.4.1.4 SPI DMA设置 // 此处是以SPI1为例 // 分别设置RX FIFO 和 TX FIFO的DMA void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 7.4.1.5 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 7.4.1.6 SPI 接收数据 uint32_t read_data[DATA_LEN] = {0,};//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向存储接收数据的地址 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 7.4.1.7 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_push_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); } void peripherals_spi_send_data(void) { // 分别设置接收和发射的DMA peripherals_spi_read_data(); peripherals_spi_push_data(); // 写入命令，触发SPI传输 apSSP_WriteCmd(APB_SSP1, 0x00, 0x00);//trigger transfer // 等待发送结束 while(apSSP_GetSPIActiveStatus(APB_SSP1)); // 关闭 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,0); } 7.4.1.8 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 在需要时候发送SPI数据，peripherals_spi_send_data() 检查中断状态 7.4.2 SPI从配置 7.4.2.1 接口配置 static void setup_peripherals_spi_pin(void) { // 打开SPI模块时钟 // 此处是以SPI1为例，如果是SPI0则需要更改 // 根据使用的GPIO，选择打开GPIO0或者GPIO1的时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ITEM_APB_SPI1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_SysCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO1) | (1 &lt;&lt; SYSCTRL_ITEM_APB_GPIO0)); // 设置IO MUX，将GPIO映射成SPI功能，不需要的pin可以使用IO_NOT_A_PIN替代 PINCTRL_Pull(IO_SOURCE_SPI1_CLK_IN,PINCTRL_PULL_DOWN); PINCTRL_Pull(IO_SOURCE_SPI1_CSN_IN,PINCTRL_PULL_UP);// CS 需要默认上拉 PINCTRL_SelSpiIn(SPI_PORT_1, SPI_MIC_CLK, SPI_MIC_CS, SPI_MIC_HOLD, SPI_MIC_WP, SPI_MIC_MISO, SPI_MIC_MOSI); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI1_CLK_OUT); PINCTRL_SetPadMux(SPI_MIC_MISO, IO_SOURCE_SPI1_MISO_OUT); // 设置SPI的中断 platform_set_irq_callback(PLATFORM_CB_IRQ_APBSPI, peripherals_spi_isr, NULL); 7.4.2.2 SPI模块初始化 常用设置项用注释标出，详细定义请参考“peripheral_ssp.h” // 示例，每次传输大小是8个word #define DATA_LEN (SPI_FIFO_DEPTH) static void setup_peripherals_spi_module(void) { apSSP_sDeviceControlBlock pParam; pParam.eSclkDiv = SPI_INTERFACETIMINGSCLKDIV_DEFAULT_2M;// SPI 时钟设置 pParam.eSCLKPolarity = SPI_CPOL_SCLK_LOW_IN_IDLE_STATES;// SPI 模式设置 pParam.eSCLKPhase = SPI_CPHA_ODD_SCLK_EDGES;// SPI 模式设置 pParam.eLsbMsbOrder = SPI_LSB_MOST_SIGNIFICANT_BIT_FIRST; pParam.eDataSize = SPI_DATALEN_32_BITS;// SPI 每个传输单位的大小 pParam.eMasterSlaveMode = SPI_SLVMODE_SLAVE_MODE;// SPI 从模式 pParam.eReadWriteMode = SPI_TRANSMODE_WRITE_READ_SAME_TIME;// SPI 同时读写 pParam.eQuadMode = SPI_DUALQUAD_REGULAR_MODE; pParam.eWriteTransCnt = DATA_LEN;// SPI每次传输多少个单位（每个单位的大小是pParam.eDataSize） pParam.eReadTransCnt = DATA_LEN;// SPI每次接收多少个单位（每个单位的大小是pParam.eDataSize） pParam.eAddrEn = SPI_ADDREN_DISABLE; pParam.eCmdEn = SPI_CMDEN_DISABLE; pParam.RxThres = 0; pParam.TxThres = 0; pParam.SlaveDataOnly = SPI_SLVDATAONLY_ENABLE; pParam.eAddrLen = SPI_ADDRLEN_1_BYTE; pParam.eInterruptMask = (1 &lt;&lt; bsSPI_INTREN_ENDINTEN);// 打开SPI中断（传输结束后触发） apSSP_DeviceParametersSet(APB_SSP1, &amp;pParam); } 7.4.2.3 SPI DMA初始化 // 初始化DMA模块 static void setup_peripherals_dma_module(void) { SYSCTRL_ClearClkGateMulti(1 &lt;&lt; SYSCTRL_ClkGate_APB_DMA); DMA_Reset(1); DMA_Reset(0); } 7.4.2.4 SPI DMA设置 // 此处是以SPI1为例 // 分别设置RX FIFO 和 TX FIFO的DMA void peripherals_spi_dma_to_txfifo(int channel_id, void *src, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PrepareMem2Peripheral(&amp;descriptor,SYSCTRL_DMA_SPI1_TX,src,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } void peripherals_spi_rxfifo_to_dma(int channel_id, void *dst, int size) { DMA_Descriptor descriptor __attribute__((aligned (8))); descriptor.Next = (DMA_Descriptor *)0; DMA_PreparePeripheral2Mem(&amp;descriptor,dst,SYSCTRL_DMA_SPI1_RX,size,DMA_ADDRESS_INC,0); DMA_EnableChannel(channel_id, &amp;descriptor); } 7.4.2.5 SPI 接收数据 uint32_t read_data[DATA_LEN] = {0,};//数据大小等于pParam.eDataSize，数组大小等于pParam.eReadTransCnt void peripherals_spi_read_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetRxDmaEn(APB_SSP1,1); apSSP_SetTransferControlRdTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向存储接收数据的地址 peripherals_spi_rxfifo_to_dma(SPI_DMA_RX_CHANNEL, read_data, sizeof(read_data)); } 7.4.2.6 SPI 发送数据 uint32_t write_data[DATA_LEN];//数据大小等于pParam.eDataSize，数组大小等于pParam.eWriteTransCnt void peripherals_spi_push_data(void) { // 首先需要打开 SPI 模块中的DMA功能 apSSP_SetTxDmaEn(APB_SSP1,1); apSSP_SetTransferControlWrTranCnt(APB_SSP1,DATA_LEN); // 配置DMA，指向需要发送的数据 peripherals_spi_dma_to_txfifo(SPI_DMA_TX_CHANNEL, write_data, sizeof(write_data)); } 7.4.2.7 SPI 中断 // SPI ENDINT中断触发标志传输结束，清除中断状态 static uint32_t peripherals_spi_isr(void *user_data) { uint32_t stat = apSSP_GetIntRawStatus(APB_SSP1); if(stat &amp; (1 &lt;&lt; bsSPI_INTREN_ENDINTEN)) { // 根据情况决定是否需要准备下一次的接收和发射 peripherals_spi_read_data(); peripherals_spi_push_data(); apSSP_ClearIntStatus(APB_SSP1, 1 &lt;&lt; bsSPI_INTREN_ENDINTEN); } } 7.4.2.8 使用流程 设置GPIO，setup_peripherals_spi_pin() 初始化SPI，setup_peripherals_spi_module() 初始化DMA，setup_peripherals_dma_module() 设置接收DMA，peripherals_spi_read_data(); 设置发射DMA，peripherals_spi_push_data(); 观察SPI中断，中断触发代表当前接收结束 "],["ch-sysctrl.html", "8 系统控制（SYSCTRL）", " 8 系统控制（SYSCTRL） "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
