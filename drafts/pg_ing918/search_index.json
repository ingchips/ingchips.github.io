[["index.html", "ING918XX 系列芯片外设开发者手册 1 版本历史", " ING918XX 系列芯片外设开发者手册 Ingchips Technology Co., Ltd. 1 版本历史 版本 信息 日期 0.1 初始版本 2022-xx-xx "],["ch-overview.html", "2 概览 2.1 缩略语及术语", " 2 概览 欢迎使用 INGCHIPS 918xx/916xx 软件开发工具包 （SDK）. ING918XX 系列芯片支持蓝牙 5.0/5.1 规范，内置高性能 32bit RISC MCU、Flash，以及丰富的外设、 高性能低功耗 BLE RF 收发机。BLE 发射功率。 本文介绍 SoC 外设及其开发方法。每个章节介绍一种外设，各种外设与芯片数据手册之外设一一对应， 基于 API 的兼容性、避免误解等因素，存在以下例外： PINCTRL 对应于数据手册之 IOMUX SYSCTRL 是一个“虚拟”外设，负责管理各种 SoC 功能，组合了几种相关的硬件模块 SDK 外设驱动的源代码开放，其中包含很多常数，而且几乎没有注释 —— 这是有意为之，开发者只需要关注头文件，而不要尝试修改源代码。 918xx系列分为9187和9188两个子系列，9187和9188各自根据封装不同而有不同的后缀。9187与9188的区别在于9188是5.1规范， 而9187是5.0规范。对于软件开发者来说，如果需要5.1规范则需要将sdk运行于9188系列的芯片上，如开发AOA等功能。 总而言之，9188向下兼容9187，两者共用一套sdk，开放给开发者的寄存器及接口均是一致的。 2.1 缩略语及术语 表 2.1: 缩略语 缩略语 说明 ADC 模数转换器（Analog-to-Digital Converter） FIFO 先进先出队列（First In First Out） GPIO 通用输入输出（General-Purpose Input/Output） I2C 集成电路间总线（Inter-Integrated Circuit） PWM 脉宽调制信号（Pulse Width Modulation） QDEC 正交解码器（Quadrature Decoder） RTC 实时时钟（Real-time Clock） SPI 串行外设接口（Serial Peripheral Interface） UART 通用异步收发器（Universal Asynchronous Receiver/Transmitter） ## 参考文档 Bluetooth SIG1 ING918XX 系列芯片数据手册 https://www.bluetooth.com/ "],["通用输入输出gpio.html", "3 通用输入输出（GPIO） 3.1 功能概述 3.2 使用说明", " 3 通用输入输出（GPIO） 3.1 功能概述 GPIO 模块常用于驱动 LED 或者其它指示器，控制片外设备，感知数字信号输入，检测信号边沿， 或者从低功耗状态唤醒系统。ING918XX 系列芯片内部支持最多 20 个 GPIO，通过 PINCTRL 可将 GPIO \\(n\\) 引出到芯片 IO 管脚 \\(n\\)。 特性： 每个 GPIO 都可单独配置为输入或输出 每个 GPIO 都可作为中断请求，中断触发方式支持边沿触发（上升、下降单沿触发，或者双沿触发） 和电平触发（高电平或低电平） 3.2 使用说明 3.2.1 设置 IO 方向 在使用 GPIO 之前先按需要配置 IO 方向： 需要用于输出信号时：配置为输出 需要用于读取信号时：配置为输入 需要用于生产中断请求时：配置为输入 需要高阻态时：配置为高阻态 使用 GIO_SetDirection 配置 GPIO 的方向。GPIO 支持四种方向： typedef enum { GIO_DIR_INPUT, // 输入 GIO_DIR_OUTPUT, // 输出 GIO_DIR_BOTH, // 同时支持输入、输出 GIO_DIR_NONE // 高阻态 } GIO_Direction_t; 如无必要，不要使用 GIO_DIR_BOTH。 3.2.2 读取输入 使用 GIO_ReadValue 读取某个 GPIO 当前输入的电平信号，例如读取 GPIO 0 的输入： uint8_t value = GIO_ReadValue(GIO_GPIO_0); 使用 GIO_ReadAll 可以同时读取所有 GPIO 当前输入的电平信号。其返回值的第 \\(n\\) 比特 （第 0 比特为最低比特）对应 GPIO \\(n\\) 的输入；如果 GPIO \\(n\\) 当前不支持输入，那么第 \\(n\\) 比特为 0： uint64_t GIO_ReadAll(void); 3.2.3 设置输出 使用 GIO_WriteValue 设置某个 GPIO 输出的电平信号，例如使 GPIO 0 输出高电平（1）： GIO_WriteValue(GIO_GPIO_0, 1); 3.2.4 配置中断请求 使用 GIO_ConfigIntSource 配置 GPIO 生成中断请求。 void GIO_ConfigIntSource( const GIO_Index_t io_index, // GPIO 编号 const uint8_t enable, // 使能的边沿或者电平类型组合 const GIO_IntTriggerType_t type // 触发类型 ); 其中的 enable 为以下两个值的组合（0 表示禁止产生中断请求）： typedef enum { ...LOGIC_LOW_OR_FALLING_EDGE = ..., // 低电平或者下降沿 ...LOGIC_HIGH_OR_RISING_EDGE = ... // 高电平或者上升沿 } GIO_IntTriggerEnable_t; 触发类型有两种： typedef enum { GIO_INT_EDGE, // 边沿触发 GIO_INT_LOGIC // 电平触发 } GIO_IntTriggerType_t; 例如将 GPIO 0 配置为上升沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为双沿触发中断 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE | ..._HIGH_OR_RISING_EDGE, GIO_INT_EDGE); 例如将 GPIO 0 配置为高电平触发 GIO_ConfigIntSource(GIO_GPIO_0, ...LOGIC_HIGH_OR_RISING_EDGE, GIO_INT_LOGIC); 3.2.5 处理中断状态 在用 platform_set_irq_callback 注册好GPIO中断回调函数后，在中断里用 GIO_GetIntStatus 可获取某个 GPIO 上的中断触发状态，返回非 0 值表示该 GPIO 上产生了中断请求；用 GIO_GetAllIntStatus 一次性获取所有 GPIO 的中断触发状态， 第 \\(n\\) 比特（第 0 比特为最低比特）对应 GPIO \\(n\\) 上的中断触发状态。 GPIO 产生中断后，需要消除中断状态方可再次触发。用 GIO_ClearIntStatus 消除某个 GPIO 上中断状态，用 GIO_ClearAllIntStatus 一次性清除所有 GPIO 上可能存在的中断触发状态。 "],["i2c功能概述.html", "4 I2C功能概述 4.1 I2C使用说明 4.2 使用方法", " 4 I2C功能概述 两个I2C模块 支持Master/Slave模式 支持7bit/10bit地址 支持DMA和QUEUE模式 4.1 I2C使用说明 以下场景中均以I2C0为例，如果需要I2C1则可以根据情况修改 4.2 使用方法 4.2.1 Master读些，采用QUEUE模式 #define I2C_PORT I2C_PORT_0 #define I2C_ADDR 0X76 4.2.1.1 打开I2C时钟 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ClkGate_APB_I2C0) |(1 &lt;&lt; SYSCTRL_ClkGate_APB_PinCtrl)); 4.2.1.2 配置I2C的IO口 PINCTRL_SetPadMux(10, IO_SOURCE_I2C0_SCL_O); PINCTRL_SetPadMux(11, IO_SOURCE_I2C0_SDO); PINCTRL_SelI2cSclIn(I2C_PORT, 10); 4.2.1.3 I2C模块初始化 I2C_CTRL0_CLR(I2C_BASE(I2C_PORT), I2C_CTRL0_SFTRST | I2C_CTRL0_CLKGATE); 4.2.1.4 I2C写操作 int i2c_do_write(const i2c_port_t port, const uint32_t nrm, uint8_t addr, const uint8_t *byte_data, int16_t length) { uint32_t *p_data = (uint32_t *)(byte_data + 3); uint32_t data = (addr &lt;&lt; 1) | 0; // control: write I2C_TypeDef *BASE = I2C_BASE(port); int timeout = I2C_HW_TIME_OUT; if (length &gt; 0) data |= (byte_data[0] &lt;&lt; 8) | (byte_data[1] &lt;&lt; 16) | (byte_data[2] &lt;&lt; 24); I2C_CTRL0_CLR(BASE, I2C_CTRL0_SFTRST | I2C_CTRL0_CLKGATE); // ONLY SUPPORT PIO QUEUE MODE, SET HW_I2C_QUEUECTRL_PIO_QUEUE_MODE AT FRIST I2C_QUEUECTRL_SET(BASE, I2C_QUEUECTRL_PIO_QUEUE_MODE); // frist operation, do not need clear I2C_QUEUECTRL and I2C_QUEUECMD. BASE-&gt;I2C_QUEUECMD.NRM = nrm + 1 + length; I2C_QUEUECTRL_SET(BASE, I2C_QUEUECTRL_QUEUE_RUN); length += 1; while (1) { while_with_timeout(I2C_QUEUESTAT_WR_QUEUE_FULL(BASE)); BASE-&gt;I2C_DATA = data; length -= 4; if (length &lt;= 0) break; data = *p_data; p_data++; } // WAIT I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ (software polling) while_with_timeout(GET_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ(BASE) == 0); I2C_CTRL1_CLR(BASE, I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ); // NOTE : MUST SET I2C_QUEUECTRL_WR_CLEAR I2C_QUEUECTRL_SET(BASE, I2C_QUEUECTRL_WR_CLEAR); I2C_QUEUECTRL_CLR(BASE, I2C_QUEUECTRL_WR_CLEAR); return 0; } 4.2.1.5 I2C读操作 int i2c_read(const i2c_port_t port, uint8_t addr, const uint8_t *write_data, int16_t write_len, uint8_t *read_data, int16_t read_length) { I2C_TypeDef *BASE = I2C_BASE(port); int timeout = I2C_HW_TIME_OUT; if (write_len) { // STEP 1: send write command int r = i2c_do_write(port, I2C_QUEUECMD_PRE_SEND_START | I2C_QUEUECMD_MASTER_MODE | I2C_QUEUECMD_DIRECTION, addr, write_data, write_len); if (r != 0) return r; } else { I2C_CTRL0_CLR(BASE, I2C_CTRL0_SFTRST | I2C_CTRL0_CLKGATE); // ONLY SUPPORT PIO QUEUE MODE, SET HW_I2C_QUEUECTRL_PIO_QUEUE_MODE AT FRIST I2C_QUEUECTRL_SET(BASE, I2C_QUEUECTRL_PIO_QUEUE_MODE); } // STEP 2 : transmit (control byte + Read command), need hold SCL (I2C_QUEUECMD_RETAIN_CLOCK) BASE-&gt;I2C_QUEUECMD.NRM = (I2C_QUEUECMD_RETAIN_CLOCK | I2C_QUEUECMD_PRE_SEND_START | I2C_QUEUECMD_MASTER_MODE | I2C_QUEUECMD_DIRECTION | 1); I2C_QUEUECTRL_SET(BASE, I2C_QUEUECTRL_QUEUE_RUN); BASE-&gt;I2C_DATA = 0xA5UL &lt;&lt; 24 | 0x5A &lt;&lt; 16 |0xAA &lt;&lt; 8 | (addr &lt;&lt; 1) | 1; while_with_timeout(GET_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ(BASE) == 0); // CLEAR I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ I2C_CTRL1_CLR(BASE, I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ); // NOTE : MUST SET I2C_QUEUECTRL_WR_CLEAR I2C_QUEUECTRL_SET(BASE, I2C_QUEUECTRL_WR_CLEAR); I2C_QUEUECTRL_CLR(BASE, I2C_QUEUECTRL_WR_CLEAR); // // STEP 3 : read data byte + (NO ACK) + STOP // BASE-&gt;I2C_QUEUECMD.NRM = (I2C_QUEUECMD_SEND_NAK_ON_LAST | I2C_QUEUECMD_POST_SEND_STOP | I2C_QUEUECMD_MASTER_MODE | /*I2C_QUEUECMD_XFER_COUNT*/ read_length); I2C_QUEUECTRL_SET(BASE, I2C_QUEUECTRL_QUEUE_RUN); // Receive DATA use I2C_QUEUEDATA; while (read_length &gt; 0) { // check whether rdFIFO is empty while_with_timeout(I2C_QUEUESTAT_RD_QUEUE_EMPTY(BASE)); int len = write_bytes(read_data, BASE-&gt;I2C_QUEUEDATA, read_length); read_data += len; read_length -= len; } // WAIT I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ (software polling) while_with_timeout(GET_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ(BASE) == 0); // cLEAR I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ I2C_CTRL1_CLR(BASE, I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ); // NOTE : CLEAR I2C_QUEUECTRL_RD_CLEAR I2C_QUEUECTRL_SET(BASE, I2C_QUEUECTRL_RD_CLEAR); I2C_QUEUECTRL_CLR(BASE, I2C_QUEUECTRL_RD_CLEAR); return 0; } "],["ch-pinctrl.html", "5 管脚管理（PINCTRL） 5.1 功能概述 5.2 使用说明", " 5 管脚管理（PINCTRL） 5.1 功能概述 PINCTRL 模块管理芯片所有 IO 管脚的功能，包括外设 IO 的映射，上拉、下拉选择，输入模式控制， 输出驱动能力设置等。 IO管脚特性如下： 每个 IO 管脚可以映射多种不同功能的外设 每个 IO 管脚都支持上拉或下拉 每个 IO 管脚都支持施密特触发输入方式 每个 IO 管脚支持四种输出驱动能力 鉴于片内外设丰富、IO 管脚多，进行管脚全映射并不现实，为此，PINCTRL 尽量保证灵活性的前提下做了一定取舍、优化。 部分常用外设的输入、输出功能管脚可与 \\(\\{{0-19\\}}\\) 这 20 个常用 IO 之间任意连接（全映射）， 这部分常用外设功能管脚总结于表 5.1。 表 5.2 列出了其它外设功能管脚支持映射到哪些 IO 管脚上。 表 5.1: 支持与常用 IO 全映射的常用功能管脚 外设 功能管脚 I2C0 I2C0_SCL_O, I2C0_SDO I2C1 I2C1_SCL_O, I2C1_SDO SPI0 SPI0_CLK, SPI0_DO, SPI0_SSN SPI1 SPI1_CLK, SPI1_DO, SPI1_SSN UART0 UART0_TXD, UART0_RTS UART1 UART1_TXD, UART1_RTS 表 5.2: 其它外设功能管脚的映射关系 外设功能管脚 可连接到的 IO 管脚 PWM_0A 0-11 PWM_0B 0-11 PWM_1A 0-11 PWM_1B 0-11 PWM_2A 0-11 PWM_2B 0-11 PWM_3A 0-11 PWM_3B 0-11 PWM_4A 0-11 PWM_4B 0-11 PWM_5A 0-11 PWM_5B 0-11 5.2 使用说明 5.2.1 为外设配置 IO 管脚 将外设输出连接到 IO 管脚 通过 PINCTRL_SetPadMux 将外设输出连接到 IO 管脚。 注意按照表 5.1 和 表 5.2 确认硬件是否支持。对于不支持的配置，显然无法生效。 void PINCTRL_SetPadMux( const uint8_t io_pin_index, // IO 序号 (0..19) const io_source_t source // IO 源 ); 将 IO 管脚连接到外设的输入 对于有些外设的输入同样通过 PINCTRL_SetPadMux 配置。对于另一些输入， PINCTRL 为不同的外设分别提供了 API 用以配置输入。比如对于 UART 用于硬件流控的 RXD，需要通过 PINCTRL_SelUartRxdIn 配置 ： void PINCTRL_SelUartRxdIn( const uart_port_t port, //UART 序号 const uint8_t io_pin_index)//连接到 RXD 输入的 IO 管脚 5.2.2 配置下拉、下拉 IO 管脚的上拉、下拉模式通过 PINCTRL_Pull 配置： void PINCTRL_Pull( const uint8_t io_pin_index, // IO 管脚序号 const pinctrl_pull_mode_t mode // 模式 ); 5.2.3 配置驱动能力 通过 PINCTRL_SetDriveStrength 配置 IO 管脚的驱动能力： void PINCTRL_SetDriveStrength( const uint8_t io_pin_index, const pinctrl_drive_strenght_t strenght); 5.2.4 配置速率 void PINCTRL_SetSlewRate( const uint8_t io_pin_index, //IO 管脚序号 const pinctrl_slew_rate_t rate); 5.2.5 IO口PWM参考代码 #define LED1_PIN 10 //在GPIO10上输出 #define LED1_PWM_CH 4 //映射到PWM_4 #define LED_FREQ 4000 //频率4K SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ClkGate_APB_PWM)); //打开PWM时钟域 PINCTRL_SetGeneralPadMode(LED1_PIN, IO_MODE_PWM, , LED1_PWM_CH, 0); //反向输出 PWM_SetupSimple(LED1_PWM_CH, LED_FREQ, 10); PWM_Enable(LED1_PWM_CH,1); 5.2.6 IO口配置为UART参考代码 #define PIN_COMM_RX GIO_GPIO_8 #define PIN_COMM_TX GIO_GPIO_7 SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ClkGate_APB_UART1)); config_uart(OSC_CLK_FREQ, 921600); PINCTRL_SetPadMux(PIN_COMM_RX, IO_SOURCE_GENERAL); PINCTRL_SelUartRxdIn(UART_PORT_1, PIN_COMM_RX); PINCTRL_SetPadMux(PIN_COMM_TX, IO_SOURCE_UART1_TXD); 5.2.7 IO口配置为SPI参考代码 { #define SPI_MIC_CLK GIO_GPIO_13 #define SPI_MIC_MOSI GIO_GPIO_16 #define SPI_MIC_MISO GIO_GPIO_17 #define SPI_MIC_CS GIO_GPIO_8 SYSCTRL_ClearClkGateMulti((1 &lt;&lt; SYSCTRL_ClkGate_AHB_SPI0) | (1 &lt;&lt; SYSCTRL_ClkGate_APB_PinCtrl) | (1 &lt;&lt; SYSCTRL_ClkGate_APB_GPIO)); PINCTRL_Pull(SPI_MIC_MOSI, PINCTRL_PULL_DOWN); PINCTRL_Pull(SPI_MIC_CLK, PINCTRL_PULL_UP); PINCTRL_Pull(SPI_MIC_CS, PINCTRL_PULL_UP); PINCTRL_Pull(SPI_MIC_MISO, PINCTRL_PULL_UP); PINCTRL_SetDriveStrength(SPI_MIC_MOSI, PINCTRL_DRIVE_12mA); PINCTRL_SetDriveStrength(SPI_MIC_CLK, PINCTRL_DRIVE_12mA); PINCTRL_SetDriveStrength(SPI_MIC_CS, PINCTRL_DRIVE_12mA); PINCTRL_SetPadMux(SPI_MIC_MOSI, IO_SOURCE_SPI0_DO); PINCTRL_SetPadMux(SPI_MIC_CLK, IO_SOURCE_SPI0_CLK); PINCTRL_SetPadMux(SPI_MIC_CS, IO_SOURCE_SPI0_SSN); PINCTRL_SelSpiDiIn(SPI_PORT_0, SPI_MIC_MISO); apSSP_DeviceDisable(AHB_SSP0); SPI_Init(AHB_SSP0); } 5.2.8 IO口配置为I2C参考代码 SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ClkGate_APB_I2C0) | (1 &lt;&lt; SYSCTRL_ClkGate_APB_PinCtrl)); PINCTRL_SetPadMux(10, IO_SOURCE_I2C0_SCL_OUT); PINCTRL_SetPadMux(11, IO_SOURCE_I2C0_SDA_OUT); "],["ch-pwm.html", "6 脉宽调制发生器（PWM） 6.1 PWM 工作模式 6.2 PWM 使用说明", " 6 脉宽调制发生器（PWM） PWM 模块实现脉冲宽度调制信号的产生，控制 LED 等外部器件。通过 APB 总线读写 寄存器来实现整个过程。ING918x 包括 6 个 PWM 模块，每个模块包含 2 个通道，因 此可以使用 12 个 PWM 通道。 PWM 特性： 每个通道都可以通过寄存器或 PWM 序列来控制 每个通道都可以屏蔽 寄存器中定义最多四个占空比序列 可以使用多种模式：命令模式、单步模式、对称模式、空白区模式 6.1 PWM 工作模式 PWM 使用的时钟频率可配置，请参考 SYSCTRL。 每个 PWM 通道支持以下多种工作模式： typedef enum { ..._UP_WITHOUT_DIED_ZONE = ..., ..._UP_WITH_DIED_ZONE = ..., ..._UPDOWN_WITHOUT_DIED_ZONE = ..., ..._UPDOWN_WITH_DIED_ZONE = ..., ..._SINGLE_WITHOUT_DIED_ZONE = ..., } PWM_WorkMode_t; 6.1.1 最简单的模式：UP_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH &lt;= cnt; B = !A; } 6.1.2 UP_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH，DZONE_TH 必须小于 HIGH_TH。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; PERA_TH ? cnt + 1 : 0; A = HIGH_TH + DZONE_TH &lt;= cnt; B = DZONE_TH &lt;= cnt &lt; HIGH_TH); } 6.1.3 UPDOWN_WITHOUT_DIED_ZONE 此模式需要的门限参数与 UP_WITHOUT_DIED_ZONE 相同。以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH &lt;= cnt &lt;= PERA_TH + HIGH_TH; B = !A; } 6.1.4 UPDOWN_WITH_DIED_ZONE 与 UP_WITHOUT_DIED_ZONE 相比，此模式需要一个新的死区门限 DZONE_TH。 以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt = cnt &lt; 2 * PERA_TH ? cnt + 1 : 0; A = PERA_TH - HIGH_TH + DZONE_TH &lt;= cnt &lt;= PERA_TH + HIGH_TH; B = (cnt &lt; PERA_TH - HIGH_TH) || (cnt &gt; PERA_TH + HIGH_TH + DZONE_TH); } 6.1.5 SINGLE_WITHOUT_DIED_ZONE 此模式需要配置两个门限：计数器回零门限 PERA_TH、高门限 HIGH_TH，HIGH_TH 必须小于 HIGH_TH。此模式只产生一个脉冲，以伪代码描述 A、B 输出如下： cnt = 0; on_clock_rising_edge() { cnt++; A = HIGH_TH &lt;= cnt &lt; PERA_TH; B = !A; } 以上伪代码仅用于辅助描述硬件行为，与实际行为可以存在微小差异。 6.1.6 输出控制 对于每个通道的每一路输出，另有 3 个参数控制最终的两路输出：掩膜、停机输出值、反相。 最终的输出以伪代码描述如下： output_control(v) { if (掩膜 == 1) return A 路输出 0、B 路输出 1; if (本通道已停机) return 停机输出值; if (反相) v = !v; return v; } 6.2 PWM 使用说明 6.2.1 启动与停止 共有两个开关与 PWM 的启动和停止有关：使能（Enable）、停机控制（HaltCtrl）。只有当 Enable 为 1， HaltCtrl 为 0 时，PWM 才真正开始工作。 相关的 API 为： // 使能 PWM 通道 void PWM_Enable( const uint8_t channel_index, // 通道号 const uint8_t enable // 使能或禁用 ); // PWM 通道停机控制 void PWM_HaltCtrlEnable( const uint8_t channel_index, // 通道号 const uint8_t enable // 停机(1) 或运转(0) ); 6.2.2 配置工作模式 void PWM_SetMode( const uint8_t channel_index, // 通道号 const PWM_WorkMode_t mode // 模式 ); 6.2.3 配置门限 // 配置 PERA_TH void PWM_SetPeraThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 DZONE_TH void PWM_SetDiedZoneThreshold( const uint8_t channel_index, const uint32_t threshold); // 配置 HIGH_TH void PWM_SetHighThreshold( const uint8_t channel_index, const uint8_t multi_duty_index, // 对于 ING916XX，此参数无效 const uint32_t threshold); 各门限值最大支持 0xFFFFF，共 20 个比特。 6.2.4 输出控制 // 掩膜控制 void PWM_SetMask( const uint8_t channel_index, // 通道号 const uint8_t mask_a, // A 路掩膜 const uint8_t mask_b // B 路掩膜 ); // 配置停机输出值 void PWM_HaltCtrlCfg( const uint8_t channel_index, // 通道号 const uint8_t out_a, // A 路停机输出值 const uint8_t out_b // B 路停机输出值 ); // 反相 void PWM_SetInvertOutput( const uint8_t channel_index, // 通道号 const uint8_t inv_a, // A 路是否反相 const uint8_t inv_b // B 路是否反相 ); 6.2.5 综合示例 下面的例子将 channel_index 通道配置成输出频率为 frequency、占空比为 (on_duty)% 的方波， 涉及 3 个关键参数： 生成这种最简单的 PWM 信号需要的模式为 UP_WITHOUT_DIED_ZONE； PERA_TH 控制输出信号的频率，设置为 PWM_CLOCK_FREQ / frequency； HIGH_TH 控制信号的占空比，设置为 PERA_TH * (100 - on_duty) % void PWM_SetupSimple( const uint8_t channel_index, const uint32_t frequency, const uint16_t on_duty) { uint32_t pera = PWM_CLOCK_FREQ / frequency; uint32_t high = pera &gt; 1000 ? pera / 100 * (100 - on_duty) : pera * (100 - on_duty) / 100; PWM_HaltCtrlEnable(channel_index, 1); PWM_Enable(channel_index, 0); PWM_SetPeraThreshold(channel_index, pera); PWM_SetHighThreshold(channel_index, 0, high); PWM_SetMode(channel_index, PWM_WORK_MODE_UP_WITHOUT_DIED_ZONE); PWM_SetMask(channel_index, 0, 0); PWM_Enable(channel_index, 1); PWM_HaltCtrlEnable(channel_index, 0); } "],["ch-sysctrl.html", "7 系统控制（SYSCTRL） 7.1 功能概述 7.2 使用说明", " 7 系统控制（SYSCTRL） 7.1 功能概述 SYSCTRL 负责管理、控制各种片上外设，主要功能有： 外设的复位 外设的时钟管理，包括时钟源、频率设置、门控等 其它功能 7.1.1 外设标识 SYSCTRL 为外设定义了几种不同的标识。最常见的几种标识为： 1.SYSCTRL的时钟门控 typedef enum { SYSCTRL_ClkGate_APB_I2C0 = 4, SYSCTRL_ClkGate_APB_SPI1 = 5, // ... SYSCTRL_ClkGate_APB_I2C1 = 19 } SYSCTRL_ClkGateItem; 2.SYSCTRL的reset typedef enum { SYSCTRL_Reset_AHB_DMA = 0, SYSCTRL_Reset_AHB_LLE = 1, // ... SYSCTRL_Reset_APH_TRNG = 21 } SYSCTRL_ResetItem; 这些标识用于外设的复位、时钟门控等。 7.1.2 时钟树 32KiHz 时钟（clk_32k） 32k 时钟有两个来源：内部 RC 32KHz，外部 32768Hz 晶体。 PLL 输入的 24MHz 时钟（clk_pll_in） 24MHz 时钟的主要来源：外部 48MHz 晶体。 时钟分布图 TODO: image is missing 7.2 使用说明 7.2.1 外设复位 通过 SYSCTRL_ResetBlock 复位外设，通过’SYSCTRL_ReleaseBlock’释放复位。 void SYSCTRL_ResetBlock(SYSCTRL_ResetItem item); void SYSCTRL_ReleaseBlock(SYSCTRL_ResetItem item); 7.2.2 时钟门控 通过 SYSCTRL_SetClkGateMulti 设置门控（即关闭时钟），通过 SYSCTRL_ClearClkGateMulti 消除门控（即恢复时钟）。 void SYSCTRL_SetClkGateMulti(SYSCTRL_ClkGateItem item); void SYSCTRL_ClearClkGateMulti(SYSCTRL_ClkGateItem item); SYSCTRL_SetClkGateMulti 和 SYSCTRL_ClearClkGateMulti 可以同时控制多个外设的门控。 items 参数里的各个比特与 SYSCTRL_ClkGateItem 里的各个外设一一对应。 void SYSCTRL_SetClkGateMulti(uint32_t items); void SYSCTRL_ClearClkGateMulti(uint32_t items); 7.2.3 时钟配置 举例如下。 开启I2C时钟 使用 SYSCTRL_SelectI2sClk 为 I2S 配置时钟： SYSCTRL_ClearClkGateMulti( (1 &lt;&lt; SYSCTRL_ClkGate_APB_I2C0) |(1 &lt;&lt; SYSCTRL_ClkGate_APB_PinCtrl)); 关闭定时器TMR0时钟 使用 SYSCTRL_GetClk 可获得指定外设的时钟频率： SYSCTRL_ClearClkGateMulti(0 | (1 &lt;&lt; SYSCTRL_ClkGate_APB_TMR0)); "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
