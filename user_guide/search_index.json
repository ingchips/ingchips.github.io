[
["index.html", "INGCHIPS SDK User Guide Chapter 1 Welcome", " INGCHIPS SDK User Guide v1.2 2021-08-02 Chapter 1 Welcome Welcome to use INGCHIPS 918xx Software Development Kit. INGCHIPS 918xxx is a BLE 5.x full feature SoC solution. This manual will give you an in-depth view on BLE development with 918xx from software perspective. "],
["intro.html", "Chapter 2 Introduction 2.1 Scope 2.2 Architecture 2.3 Abbreviations &amp; Terminology 2.4 References", " Chapter 2 Introduction Figure 2.1: SDK Overview INGCHIPS software development kit has following major components (see Figure 2.1): Core Tools Provide project wizard, flash loader and other functionalities. These tools make BLE development easy and seamless. Language &amp; IDE Integration Support Keil μVision1, IAR Embedded Workbench2, Rowley Crossworks for ARM3, and SEGGER Embedded Studio for ARM4. All IDE/Toolchain settings are configured by core tools properly and automatically. GNU Arm Embedded Toolchain5 is also supported. Nim6 is also supported as an alternative of C. Optionally, new projects can be configured properly to use Visual Studio Code7 as code editor. For Nim and GNU Arm Embedded Toolchain, building and downloading tasks are created and can be invoked in Visual Studio Code. Platform Bundles Provide different bundles for different application scenarios (such as mesh, and typical application without mesh). Each bundle contains full stack &amp; FreeRTOS binary, and C header files. Source codes for accessing peripherals are also provided. Examples Provide a rich set of BLE device examples and corresponding Anroid and iOS referencing applications. Documentation User guide (this document), API reference, and application notes are also provided. 2.1 Scope This document covers platform overall architecture, core tools and platform APIs. 2.2 Architecture 918xx software architecture is shown in Figure 2.2. Bootloader is stored in ROM and can’t be modified, while platform and app executable are stored in flash. Platform executable is provided for each bundle. BLE stack, FreeRTOS and some SoC functionality are compiled into this single platform executable. When system starts up, platform executable initializes, then loads the primary app executable. Figure 2.2: Architecture A secondary app can only be asked to execute programmaticly. It is possible to download several secondary apps, and to switch between them programmaticly. After reset, platform will load the primary app executable as usual. Entry address of the primary app is managed by SDK tools, while entry addresses of secondary apps can be configured manually. 2.2.1 Apps built with C App executable’s main function is named app_main, where app gets initialized: int app_main(void) { ... return 0; } app_main should always return 0. Platform, BLE stack and FreeRTOS APIs are all declared in corresponding C header files. To use these APIs, just include the necessary header files. 2.2.2 Apps built with Nim App executable’s main function is named appMain, where app gets initialized: proc appMain*(): int {.exportc noconv.} = ... return 0; appMain should always return 0. Thanks to the separation of platform and app, size of the app executable is significantly reduced. There are several benefits of this, not limited to: Smaller &amp; cleaner app code base Faster downloading &amp; FOTA Focus on function development Flash tools are available for all supported IDEs and installed when installing SDK. App debugging is also quite easy: download platform binary with flash downloader (Section 4.2), then download &amp; debug apps in IDE as usual. 2.3 Abbreviations &amp; Terminology Table 2.1: Abbreviations Abbreviation Notes ATT Attribute Protocol BLE Bluetooth Low Energy FOTA Firmware Over-The-Air IRQ Interrupt Request GAP Generic Access Profile GATT Generic Attribute Profile RAM Random Access Memory ROM Read Only Memory SDK Software Development Kit Table 2.2: Terminology Terminology Notes Flash Memory An electronic non-volatile computer storage medium FreeRTOS A real-time operating system kernel 2.4 References Host API Reference Bluetooth SIG8 FreeRTOS9 Mastering the FreeRTOS™ Real Time Kernel10 https://www.keil.com/↩︎ https://www.iar.com/iar-embedded-workbench/↩︎ https://www.crossworks.com/index.htm/↩︎ https://www.segger.com/products/development-tools/embedded-studio/↩︎ https://developer.arm.com/open-source/gnu-toolchain/gnu-rm↩︎ https://www.nim-lang.org↩︎ https://code.visualstudio.com↩︎ https://www.bluetooth.com/↩︎ https://freertos.org↩︎ https://www.freertos.org/Documentation/161204_Mastering_the_FreeRTOS_Real_Time_Kernel-A_Hands-On_Tutorial_Guide.pdf↩︎ "],
["tutorial.html", "Chapter 3 Tutorials 3.1 Hello World 3.2 iBeacon 3.3 Thermometer 3.4 Thermometer with FOTA 3.5 iBeacon Scanner 3.6 Notification &amp; Indication 3.7 Throughput 3.8 Dual Role &amp; BLE Gateway 3.9 Hello, Nim", " Chapter 3 Tutorials Following step-by-step tutorials show the basic usage of core tools and concepts of the SDK. 3.1 Hello World In this tutorial, we are going to create a device which is advertising its name, “Hello, 世界”. Start ingWizard from start menu and select menu item Project -&gt; New Project .... This brings up the project wizard. This first page shown by the wizard is Development Tool (see Figure 3.1). 3.1.1 Development Tool Page Figure 3.1: Choose Project Type On this page (Figure 3.1): Choose IDE/Toolchain Choose a project name Choose where to store your project ingWizard provides below handy functionality: If Git is used for software configuration management, select Setup .gitignore; If Visual Studio Code is the preferred code editor, select Setup Visual Studio Code. Then press Next to proceed to the next page, Choose Chip Series. 3.1.2 Choose Chip Series Page Figure 3.2: Choose Chip Series On this page (Figure 3.2), choose the target chip series of the project. Then press Next to proceed to the next page, Choose Project Type. 3.1.3 Choose Project Type Page Figure 3.3: Choose Project Type On this page (Figure 3.3): Select Typical Select Legacy advertising type {block-on-ext-adv, note-text, type='rmdcaution'} Phones that support BLE 5.x extended advertising are still rare at present (2021-08-02) even if BLE 5.0 is declared as \"supported\", so we use legacy advertising for better compatibility. Furthermore, legacy advertising can be changed to BLE 5.x extended advertising by toggling a single bit. Then press Next to proceed to the next page, Role of Your Device. 3.1.4 Role of Your Device Page Figure 3.4: Role of Your Device On this page (Figure 3.4), just select Peripheral, and press Next to proceed to the next page, Peripheral Setup. 3.1.5 Peripheral Setup Page Figure 3.5: Peripheral Setup On this page (Figure 3.5), click Setup Advertising Data button, which will bring up the advertising data editor (Figure 3.6). In the editor, type name to quickly search for the GAP advertising item 09 - «Complete Local Name», and click Add to add it into our device’s advertising data. Click the newly added 09 - «Complete Local Name» item, then fill in “Hello, 世界” in the data editor shown below and press Enter. Data Preview will be updated and the whole advertising data is shown in raw bytes with a few comments on each item. Obviously, Chinese characters are encoded in UTF-8 properly. Figure 3.6: Edit Advertising Data Now, click OK to go back to project wizard, and press Next to proceed to the next page Security &amp; Privacy. 3.1.6 Security &amp; Privacy Page Figure 3.7: Firmare Over-The-Air Leave all options as default (Figure 3.7), and press Next to proceed to the next page Firmare Over-The-Air. 3.1.7 Firmare Over-The-Air Page Figure 3.8: Firmare Over-The-Air Leave all options as default (Figure 3.8), and press Next to proceed to the last page Common Functions. 3.1.8 Common Functions Page Figure 3.9: Common Functions On this page (Figure 3.9), we also accept the default settings and press Create. Now your project is created (Figure 3.10), and ready for building and downloading. Figure 3.10: “Hello, 世界” is Ready 3.1.9 Build your project Back to the main window of ingWizard (Figure 3.10), click on your project to open it. Build your project in IDE. 3.1.10 Download To download your project, Back to ingWizard (Figure 3.10), right click on your project, and select Download to Flash from the popup menu to start the downloader (Figure 3.11). Figure 3.11: Download to Flash All settings in the downloader are ready except the UART port number. In the downloader, configure the correct UART port and then click Start. Once downloaded, check if you can find a device named “Hello, 世界” by LightBlue, INGdemo (Figure 3.12) or other apps. Note that, this device may not be listed in the Bluetooth menu of system settings at present. Figure 3.12: Hello, 世界 3.2 iBeacon In this tutorial, let’s make an iBeacon. iBeacon is a protocol developed by Apple11 and introduced at the Apple Worldwide Developers Conference in 2013. Beacons are a class of Bluetooth low energy (BLE) devices that broadcast their identifier to nearby portable electronic devices. This technology enables smartphones, tablets and other devices to perform actions when in close proximity to an iBeacon device. Firstly, get a iBeacon scanning app from App Store. We will use an app called Locate in this tutorial. Locate has a list of preconfigured proximity UUIDs, which includes an all 0s Null UUID. We will use this Null UUID12. 3.2.1 Setup Advertising Data There are two items in iBeacon advertising packet. Flags Value is fixed to 0x06, i.e. two bits are set, LE General Discoverable Mode &amp; BR/EDR Not Supported. Manufacturer Specific Data The contents of this item is shown in Table 3.1 Table 3.1: iBeacon Manufacturer Specific Data Size in Bytes Name Value Notes 2 Company ID 0x004C Company ID of Apple, Inc 2 Beacon Type 0x1502 Value defined by Apple 16 Proximity UUID User defined value 2 Major Group ID 2 Minor ID within a group 1 Measured Power in dBm Measured by an iPhone 5s at a 1 meter distance In order to make an iBeacon device, we can just follow the same steps as in the Hello World example, with only on exception that we need to configure the advertising package according to the specification. In the advertising data editor, add 0x01 - «Flags» and 0xFF - «Manufacturer Specific Data». Click 0x01 - «Flags», check LE General Discoverable Mode and BR/EDR Not Supported. Click 0xFF - «Manufacturer Specific Data», then the Edit as button, a menu pops up and select iBeacon ... (Figure 3.13) to open iBeacon manufacturer specific data editor (Figure 3.14). Figure 3.13: Edit iBeacon Advertising Data Figure 3.14: Edit iBeacon Manufacturer Specific Data Signal power can be set to any reasonable value (such as -50dBm), and we will calibrate it later with the help of the Locate app. 3.2.2 Try It Let’s select GNU Arm Embedded Toolchain as our development environment on Choose Project Type page, and the wizard will make everything ready (Figure 3.15). Figure 3.15: iBeacon Ready for GNU Arm Toolchain Click on the project to open a console, type make13 to build it. Back to ingWizard, follow the same steps to download it. Now we are able to find our newly created iBeacon in Locate. (Figure 3.16) Figure 3.16: iBeacon in Locate app Tap on our device then we can calibrate signal power or check distance in real-time as shown in Figure 3.17. Figure 3.17: iBeacon Detailed Information in Locate app Once signal power is calibrated, we can right click on our project in ingWizard, and select Edit Data -&gt; Advertising menu item to edit its advertising data with same editor that we are getting familiar with. After advertising data is updated, rebuild the project and check if the distance is more accurate. According to the specification, proximity beacons must use a non connectable undirected advertising PDU, using a fixed 100ms advertising interval. In this tutorial, we are not going to touch the code, so advertising parameters are not touched, either. To make these parameters fully meet the specification, please refer to the corresponding host GAP APIs. 3.3 Thermometer In this tutorial, we are going to make a serious BLE device, a thermometer. Bluetooth SIG has already defined a GATT service called Health Thermometer14. This SDK contains a reference app called INGdemo, which can be deployed to an Android or iOS device. Using INGdemo, we can check Bluetooth devices’ advertising data, and if health thermometer service is found in a device, INGdemo can connect to it and read temperature. In this tutorial, you will learn how to: Broadcast supported services Configure a GATT profile Respond to the read request of a GATT characteristic 3.3.1 Setup Advertising Data Again, we follow the same steps as in the Hello World example, and on the Peripheral Setup page, we declare the thermometer service and create a GATT profile. Add following three items into the advertising data: Flags Value is fixed to 0x06, i.e. two bits are set, LE General Discoverable Mode &amp; BR/EDR Not Supported. Complete List of 16-bit Service Class UUIDs Add one service 0x1809 - Health Thermometer as shown in Figure 3.18. Complete Local Name Let’s name our device as “AccurateOne”. Figure 3.18: Thermometer Advertising Data 3.3.2 Setup GATT Profile Back to the Peripheral Setup page and click Setup ATT database ... to open the GATT profile editor. Add two service, General Access (0x1800) and Health Thermometer (0x1809). Delete all non-mandatory characteristics of General Access service. For Health Thermometer service, keep two characteristics, i.e. temperature measurement and temperature type, and delete the other two. Next, edit each characteristic’s value: Device Name of General Access: Right click on the characteristic, select Edit String Value ... menu, and set the value to “AccurateOne”. Appearance of General Access: Right click on the characteristic, select Help and the editor will open the corresponding document on Bluetooth SIG website. Find the value for general thermometer (0x0300), then click the Edit button and input 0x00, 0x03 into the data field. Temperature Measurement of Health Thermometer Check the document on Bluetooth SIG website. click the Edit button and input five 0s (0, 0, 0, 0, 0) into the data field. Here the first byte contains the flags showing that the following measurement is a FLOAT value in units of Celsius. Check read and dynamic properties (Figure 3.19). FLOAT type is IEEE-11073 32-bit float. Basically, it has a 24-bit mantissa, and an 8-bit exponent (the most significant byte) in base 10. Temperature Type of Health Thermometer Check the document on Bluetooth SIG website. Set it to any valid value by click the Edit button. Figure 3.19: Edit Temperature Measurement 3.3.3 Write the Code After project is created, open profile.c in IDE, and the temperature measurement characteristic handling function att_read_callback is automatically generated by ingWizard. static uint16_t att_read_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t offset, uint8_t * buffer, uint16_t buffer_size) { switch (att_handle) { case HANDLE_TEMPERATURE_MEASUREMENT: if (buffer) { // add your code return buffer_size; } else return 1; // TODO: return required buffer size default: return 0; } } att_read_callback will be called twice or more when app reads a characteristic that has dynamic property: one for querying required buffer size, and one for reading data. If data is large, att_read_callback might be called more times, each reading a part of data specified by offset. As discussed above, define a temperature measurement type: typedef __packed struct gatt_temperature_meas { uint8 flags; sint32 mantissa:24; sint32 exponent:8; } gatt_temperature_meas_t; static gatt_temperature_meas_t temperature_meas = {0}; Now, we can complete the above case HANDLE_TEMPERATURE_MEASUREMENT clause: case HANDLE_TEMPERATURE_MEASUREMENT: if (buffer) { // simulate an &quot;accurate&quot; thermometer temperature_meas.mantissa = rand() % 100; // output data memcpy(buffer, ((uint8 *)&amp;temperature_meas) + offset, buffer_size); return buffer_size; } else return sizeof(gatt_temperature_meas_t); Build &amp; download project, then connect to “AccurateOne” device in INGdemo app. Check if temperature changes randomly each time Refresh button is pressed (Figure 3.20). Figure 3.20: Refresh Temperature Measurement A thermometer (a server) can use notification or indication procedure to notify (without acknowledge) or indicate (with acknowledge) a characteristic value, see [Thermometer with Notification]. In this example, “AccurateOne” does not use these two procedures, and sends its measurement passively. 3.3.4 Notification 3.4 Thermometer with FOTA In this tutorial, we are going to add Firmware Over-The-Air update feature into our thermometer. This SDK provides a FOTA reference design that is workable out-of-the-box. To make FOTA work, at least three parties are involved, a device, an app, and an HTTP server. The INGdemo app is already there, so in this tutorial, we will focus on the device and HTTP server. 3.4.1 Device with FOTA Follow the same steps as in the previous Thermometer example to create a new project, say “ota”. When editing advertising data, we can import data created in previous example by clicking Open File... button of the editor. Advertising data is stored in $(ProjectPath)/data/advertising.adv. Let’s change device’s name to “Clickety Click”. When editing GATT profile database, we can import data created in previous example by clicking Open File... button of the editor. GATT profile data is stored in $(ProjectPath)/data/gatt.profile. Select INGChips Service from the drop-down menu of Add Service button, and add “INGChips FOTA Service”. Next, edit characteristics value of this service: FOTA Version: This identifies the full version number of our project. As shown in flash downloader, a whole project is composed by two binaries, one is from SDK bundle, called platform binary, and the other one is built from our project, called the app binary. Platform binary contains the whole BLE stack and a realtime OS FreeRTSO, with some additional functions handling SoC initialization, interrupts, etc. FOTA version contains two sub-versions, one for each binary. Each sub-version contains three fields: Major: A 16-bit field. Minor: A 8-bit field. Patch: Another 8-bit field. Each bundle has its own version (so as the platform binary), using the same numbering scheme, which can be found on SDK page of Environment Options dialog (use menu item Tools -&gt; Environment Options to open this dialog). Suppose platform version is 1.0.115, and we would like our app’s version to be 1.0.0, then we set this characteristic’s value to (Fig 3.21): 0x0001, 0, 0, // app version 0x0001, 0, 1 // platform version FOTA Control This is control point during update. Set its value to 0 (i.e. OTA_STATUS_DISABLED), which is the initial status of FOTA. Figure 3.21: Configure FOTA Version Click OK to close GATT profile editor. (Note: do not click Save, unless you want to change the file $(ProjectPath)/data/gatt.profile that is opened in editor.) Back to project wizard, press Next to proceed to the next page Firmare Over-The-Air. On this page, let’s check FOTA. Note that characteristics handles related to FOTA is generated automatically by inspecting the GATT profile. Then finish remaining steps on project wizard. Open our brand-new project “ota”, copy the code from previous example to make our thermometer respond to Refresh in INGdemo app. Next, let’s make a new version. 3.4.2 Make a New Version New version of our “ota” will have a new name “Barba Trick”, and app version number is upgraded to 2.0.0. These data are saved in advertising and profile data respectively, so right click on the project and use editors to update it. After data is updated, use Save As ... to save data to another file in the same directory, for example, update advertising data and save it to $(ProjectPath)/data/advertising_2.adv, and updated profile to $(ProjectPath)/data/gatt_2.profile. Use macro V2 to control the actual advertising and profile data: const static uint8_t adv_data[] = { #ifndef V2 #include &quot;../data/advertising.adv&quot; #else #include &quot;../data/advertising_2.adv&quot; #endif }; ...... const static uint8_t profile_data[] = { #ifndef V2 #include &quot;../data/gatt.profile&quot; #else #include &quot;../data/gatt_2.profile&quot; #endif }; Rebuild the project with macro V2 defined, copy ota.bin and platform.bin (in SDK_DIR/sdk/bundles/typical) to an empty directory, say ota_app_v2. Create a file named manifest.json in ota_app_v2, with follow data in it: { &quot;platform&quot;: { &quot;version&quot;: [1,0,1], &quot;name&quot;: &quot;platform.bin&quot;, &quot;address&quot;: 16384 }, &quot;app&quot;: { &quot;version&quot;: [2,0,0], &quot;name&quot;: &quot;ota.bin&quot;, &quot;address&quot;: 163840 }, &quot;entry&quot;: 16384, &quot;bins&quot;:[] } Those addresses can be found in Environment Options. entry value is fixed to 0x4000, i.e. 16384. Note that json do not accept the popular 0xabcd hexadecimal literals. INGdemo can download additional binaries specified by bins to device. In this case, we don’t have such binaries, so this field is left as an empty array. Then create a readme file for this update with some information about this update in it. Now the FOTA package is ready. Make a ota_app_v2.zip ZIP archive of the whole ota_app_v2 directory. Note that ota_app_v2 should not be made into a sub-directory in ota_app_v2.zip. Table 3.2 summarize the files in the ZIP archive. Table 3.2: FOTA Package Summary File Name Notes readme Some information about this update manifest.json Meta information platform.bin Platform binary ota.bin App binary Back to IDE, rebuild the project leaving macro V2 undefined, then download the project. 3.4.3 FOTA Server INGdemo app needs a FOTA server URL, defined in class Thermometer.FOTA_SERVER. Move ota_app_v2.zip to HTTP server’s document directory, and create a latest.json file, which contains information about latest version. Its content is: { &quot;app&quot;: [2,0,0], &quot;platform&quot;: [1,0,1], &quot;package&quot;: &quot;ota_app_v2.zip&quot; } Make sure that these two files can be accessed through URL (FOTA_SERVER + latest.json) and (FOTA_SERVER + ota_app_v2.zip). 3.4.4 Try It Connect to “Clickety Click” in INGdemo, click Update (Figure 3.22). Since platform.bin is up-to-date, only app.bin need to be updated, the whole update completes in a short time. Return to the main page, scan again and check if our new version works, a device named “Barba Trick” appearing. Connect to “Barba Trick”, firmware is up-to-date now. Figure 3.22: Update Available for “Clickety Click” This tutorial gives an example on FOTA implementation. Users are free to design a new FOTA solution, from version definition to FOTA service and characteristics. It also possible to develop a dedicated secondary app for FOTA. Security must be considered. 3.5 iBeacon Scanner We already know to how to make iBeacon devices. In this tutorial, we are going to create an iBeacon scanner. A scanner plays a central role in Bluetooth pico network. As always, we create a new project named “iscanner” in ingWizard (Fig 3.23). On Role of Your Device page, select Central. A central device almost always scans for something then performs other actions, and our new project wizard automatically adds codes to start scanning. Figure 3.23: “iscanner” Created for IAR Embedded Workbench Open this new project in IDE, and navigate to function user_packet_handler. We can see there is an event called GAP_EVENT_ADVERTISING_REPORT: case GAP_EVENT_ADVERTISING_REPORT: gap_get_advertisingReport(&amp;report, packet); // add your code ...... break; Each time this event is received, we can check if the advertising report contains 0xFF - «Manufacturer Specific Data», and if it is an iBeacon packet. With the knowlegde of making an iBeacon device, it is straight forward to define an iBeacon packet type in C. typedef __packed struct ibeacon_adv { uint16_t apple_id; uint16_t id; uint8_t uuid[16]; uint16_t major; uint16_t minor; int8_t ref_power; } ibeacon_adv_t; #define APPLE_COMPANY_ID 0x004C #define IBEACON_ID 0x1502 __packed is an extended keyword to specify a data alignment of 1 for a data type. Fortunately, it is supported by both ARM and IAR compilers. Alternatively, one can use #pragma pack directive: #pragma pack (push, 1) typedef struct ibeacon_adv { ... } ibeacon_adv_t; #pragma pack (pop) Before proceeding, let’s create a helper function that converts an UUID to a string. const char *format_uuid(char *buffer, uint8_t *uuid) { sprintf(buffer, &quot;{%02X%02X%02X%02X-%02X%02X-%02X%02X-&quot; &quot;%02X%02X-%02X%02X%02X%02X%02X%02X}&quot;, uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7], uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]); return buffer; } 3.5.1 Distance Estimation The received signal strength indication (RSSI) is reported together with advertising data. Generally, the intensity of electromagnetic waves radiating from a point source is inversely proportional to the square of the distance from the source. The well known equation for free space loss is: \\[ Loss = 32.45 + 20log(d) + 20log(f) \\] Where \\(d\\) is in km, \\(f\\) in MHz and \\(Loss\\) in dB. By comparing RSSI and measured power at a distance of 1 meter (ref_power), we can grossly estimate the distance between the scanner and beacon using the free space loss equation: double estimate_distance(int8_t ref_power, int8_t rssi) { return pow(10, (ref_power - rssi) / 20.0); } Now, we are able to make a fully functional iBeancon scanner in less than twenty lines: uint8_t length; ibeacon_adv_t *p_ibeacon; char str_buffer[80]; ...... case GAP_EVENT_ADVERTISING_REPORT: gap_get_advertisingReport(&amp;report, packet); p_ibeacon = (ibeacon_adv_t *)ad_data_from_type(report.length, (uint8_t *)report.data, 0xff, &amp;length); if ((length != sizeof(ibeacon_adv_t)) || (p_ibeacon-&gt;apple_id != APPLE_COMPANY_ID) || (p_ibeacon-&gt;id != IBEACON_ID)) break; printf(&quot;%s %04X,%04X, %.1fm\\n&quot;, format_uuid(str_buffer, p_ibeacon-&gt;uuid), p_ibeacon-&gt;major, p_ibeacon-&gt;minor, estimate_distance(p_ibeacon-&gt;ref_power, report.rssi)); break; Use the Locate app to transmit iBeacon signal, and check if our device can found it (Figure 3.24). Finaly, since RSSI value fluctuates, one can add a low pass filter on RSSI to make the estimation more stable. Figure 3.24: iBeacon Scan Result Note that the size of this app’s binary increases dramatically. This is mainly because that Cortex-M3 don’t have a hardware floating-point unit and floating-point operations are all performed by library functions. Think twice before using floating-point operations. 3.5.2 Concurrent Advertising &amp; Scanning As an exercise, we can merge iBeacon project with this one, and check if our device can send iBeacon signals while keeps scanning for other iBeacon devices. Bluetooth radio uses TDD (Time Division Duplex) topology in which data transmission occur in one direction at one time and data reception occur at another time, and it’s impossible to receive its own iBeacon signal. 3.6 Notification &amp; Indication A server can use notification or indication procedure to notify (without acknowledge) or indicate (with acknowledge) a characteristic value. Now, let’s add notification and indication features to our thermometer we have created in a previous tutorial. To notify or indicate a characteristic value, we use att_server_notify and att_server_indicate respectively. These two functions are only allowed to be called in ATT_EVENT_CAN_SEND_NOW event from ATT module, which is requested by att_server_request_can_send_now_event. These APIs must be called within the Bluetooth stack (Host) task. Unsolicited notifications and indication may be triggered by a timer or interrupts, i.e. by sources outside of Bluetooth stack task. To call these Bluetooth stack APIs, a inter-task communication mechanism based on FreeRTOS messages is provided. 3.6.1 Inter-task Communication Use btstack_push_user_msg to send a message into Bluetooth stack stack: uint32_t btstack_push_user_msg(uint32_t msg_id, void *data, const uint16_t len); This message will be passed to your user_packet_handler under event ID BTSTACK_EVENT_USER_MSG: static void user_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) { uint8_t event = hci_event_packet_get_type(packet); btstack_user_msg_t *p_user_msg; if (packet_type != HCI_EVENT_PACKET) return; switch (event) { // ...... case BTSTACK_EVENT_USER_MSG: p_user_msg = hci_event_packet_get_user_msg(packet); user_msg_handler(p_user_msg-&gt;msg_id, p_user_msg-&gt;data, p_user_msg-&gt;len); break; // ...... } } Here, we delegate the handling of the user message to another function user_msg_handler. Note that user_msg_handler is running in the context of Bluetooth stack task, and we are allowed to call those Bluetooth stack APIs now. Event BTSTACK_EVENT_USER_MSG is broacasted to all HCI event callback functions. 3.6.2 Timer Now let’s make our thermometer “AccurateOne” to update its value once per second. Firstly, create a timer in initialization, such as in app_main or setup_profile. TimerHandle_t app_timer = 0; uint32_t setup_profile(void *data, void *user_data) { app_timer = xTimerCreate(&quot;app&quot;, pdMS_TO_TICKS(1000), pdTRUE, NULL, app_timer_callback); // ... } Timer callback function is defined as: #define USER_MSG_ID_REQUEST_SEND 1 static void app_timer_callback(TimerHandle_t xTimer) { if (temperture_notify_enable | temperture_indicate_enable) btstack_push_user_msg(USER_MSG_ID_REQUEST_SEND, NULL, 0); } This timer is started when we get HCI_SUBEVENT_LE_CONNECTION_COMPLETE in HCI_EVENT_LE_META, and stopped when we get HCI_EVENT_DISCONNECTION_COMPLETE. Here temperture_notify_enable and temperture_indicate_enable are two flags initialized as 0s and set to 1 in att_write_callback: static int att_write_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size) { switch (att_handle) { case HANDLE_TEMPERATURE_MEASUREMENT + 1: handle_send = connection_handle; switch (*(uint16_t *)buffer) { case GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_INDICATION: temperture_indicate_enable = 1; break; case GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_NOTIFICATION: temperture_notify_enable = 1; break; } return 0; // ... } } Here we store connection_handle to a global variable handle_send which will be used later. The last piece of code is to handle message USER_MSG_ID_REQUEST_SEND in user_msg_handler: static void user_msg_handler(uint32_t msg_id, void *data, uint16_t size) { switch (msg_id) { case USER_MSG_ID_REQUEST_SEND: att_server_request_can_send_now_event(handle_send); break; } } And report temperature in ATT_EVENT_CAN_SEND_NOW: ... case ATT_EVENT_CAN_SEND_NOW: temperature_meas.mantissa = rand() % 100; if (temperture_notify_enable) { att_server_notify(handle_send, HANDLE_TEMPERATURE_MEASUREMENT, (uint8_t*)&amp;temperature_meas, sizeof(temperature_meas)); } if (temperture_indicate_enable) { att_server_indicate(handle_send, HANDLE_TEMPERATURE_MEASUREMENT, (uint8_t*)&amp;temperature_meas, sizeof(temperature_meas)); } break; ... Try to rebuild and download the project, and check if the temperature value shown in INGdemo changes once per second. There is a fully functional thermometer example, a.k.a thermo_ota, supporting FOTA, notification and indication. 3.7 Throughput BLE 5.0 introduces a new uncoded PHY with a sampling rate at 2M. 3.7.1 Theoretical Peak Throughput Maximum payload length is 251 bytes for a Data Physical Channel PDU. Using 2M PHY, it takes 1048 μs to transmit. And an empty Data Physical Channel PDU takes 44 μs to transmit. To achieve maximum throughput on one direction, length of all PDUs on this direction should be 251 bytes, while on the other direction, all PDUs should be empty. So, the transmission of 251 bytes takes a total duration of \\[ 1048 + 44 + 150 * 2 = 1392 (\\mu s) \\] Therefore, the theoretical peak throughput provided by link layer is \\[ 251 * 8 / 1392 * 1000000 \\approx 1442.528 (kbps) \\] For an app working above GATT, I2CAP and ATT all have their own overhead. Typically, GATT has a maximum effective payload of (251 - 7 =) 244 bytes. So, GATT could provide a theoretical peak throughput of \\[ 244 * 8 / 1392 * 1000000 \\approx 1402.298 (kbps) \\] 3.7.2 Test Throughput There are a pair of examples in SDK for throughput testing (Figure ). Figure 3.25: Examples for Throughput Testing 3.7.2.1 Test against INGdemo Download peripheral_throughput. Use INGdemo to connect to ING Tpt, and open throughput testing page. On this page, we can test throughput from master to slave, from slave to master, or on both directions simultaneously. Figure shows that using a common low end Android phone with 2M PHY support, we can achieve a 1M+ bps throughput over the air. Figure 3.26: Througput on an Android Phone 3.7.2.2 Test against Our Own App Example central_throughput demonstrates the typical procedure for a BLE central device: Scan and connect to a device that has throughput service declared in its advertising Discover throughput service; Discover characteristics of the service; Discover descriptors of characteristics. INGChips Throughput Service has two characteristics. Generic Output By this characteristic, peripheral device send data to central device. This characteristic has a Client Characteristic Configuration descriptor. Generic Output By this characteristic, central device send data to peripheral device. Download central_throughput to another board. This app has a UART command line interface to host computer. Connect to a host computer, type “?” to check supported commands. This app connects to peripheral_throughput automatically. Input command start s-&gt;m or start m-&gt;s to start testing throughput from peripheral to central, or from central to peripheral, receptively. Figure 3.27: Command interface Figure shows that using two boards, we have achieved a stable throughout at 1.2M+ bps over the air. Figure 3.28: Througput Between Boards This throughput is tested over the air, a little bit lower than theoretical peak value, but much more practical. 3.8 Dual Role &amp; BLE Gateway In this tutorial, we are going to create a BLE gateway, which collects data from several peripheral devices and reports data to a central device. When collecting data, this gateway is a central device, while reporting data, it is a peripheral device, i.e., our app has two roles. More specifically, our gateway only supports to collect data from thermometers. Let call it a smart_meter. Figure 3.29: Smart Meter Overview smart_meter uses a generic string based output service for report data to a central device, such as the INGdemo running on a smart phone. It also has a UART control interface connecting to a host computer. Checkout the example peripheral_console for how to do string input &amp; output. Full functional smart_meter app is also provided as an example. Take this example as an reference while creating your own. Now, let’s create this BLE gateway. 3.8.1 Use ingWizard to create a peripheral app Use GUI editor to edit advertising data, naming our app as “ING Smart Meter”. Use GUI editor to edit GATT Profile. Add INGChips Console Service into GATT Profile (Figure ). Figure 3.30: Smart Meter GATT Profile 3.8.2 Define Thermometer Data A thermometer is identified by its device address and id. Each thermometer uses its own connection identified by conn_handle. typedef struct slave_info { uint8_t id; bd_addr_t addr; uint16_t conn_handle; gatt_client_service_t service_thermo; gatt_client_characteristic_t temp_char; gatt_client_characteristic_descriptor_t temp_desc; gatt_client_notification_t temp_notify; } slave_info_t; Define four thermometers. 3.8.3 Scan for Thermometers Call two GAP APIs to start scanning. Once a device is found, check whether its device address is one of the thermometers. If so, stop scanning and call gap_ext_create_connection to connect. After connection established, if there is any thermometer not connected, then start scanning again. 3.8.4 Discover Services After connection established, call gatt_client APIs to discover its services. These APIs follow a similar logic like Android, iOS. 3.8.5 Data Handling Subscribe to thermometer’s Temperature Measurement characteristic. When a new measurement is received, convert the value into a string and report it to a host computer. If our app is already connected to a central device, forward this information to it through GATT characteristic. 3.8.6 Robustness To make our app more robust: If disconnected from a thermometer, then start scanning; If disconnected from a central device, then start advertising. 3.8.7 Prepare Thermometers We can use example thermo_ota as thermometers. But we need to configure different address for each one. We can write a simple script for downloader to generate these addresses automatically: procedure OnStartBin(const BatchCounter, BinIndex: Integer; var Data: TBytes; var Abort: Boolean); begin if BinIndex &lt;&gt; 6 then Exit; Data[0] := BatchCounter; end; For further information on downloader scripting, see Scripting &amp; Mass Production. 3.8.8 Test Input command start on host computer to start our app (start scanning &amp; advertising). Use INGdemo to connect to a device named “ING Smart Meter” and check temperature measurements. Turn off and on one or more thermometers, and our app should be able to reconnect to them. 3.9 Hello, Nim To use Nim to develop apps, nim and Gnu Toolchain are both required. Nim compiler translates Nim source code into C source code, then Gnu Toolchain is invoked to compile and link the translated C source code together with SDK, as shown in Figure . Figure 3.31: Build a Nim App Visual Studio Code is recommended for Nim code editing and building. Let’s make a simple app using Nim. 3.9.1 Create a Nim Project On the Develpment Tool page, Select Nim + Gnu Toolchain. Select By Code for both advertising &amp; ATT database generation (Figure ). Figure 3.32: Use Code to Generate Data ingWizard also support create these data for Nim apps. In this tutorial, we are going to show that it is easy to create these data with meta-programming16 in Nim. 3.9.2 Create Advertising Data Using Nim module btdatabuilder, we can create advertising and GATT profile easily. Example 1: Create a device named “Hello, Nim” let advData = ToArray([Flags({LEGeneralDiscoverableMode, BR_EDR_NotSupported}), LocalName(&quot;Hello, Nim&quot;)]) Example 2: Create an iBeacon let advData = ToArray([Flags({LEGeneralDiscoverableMode, BR_EDR_NotSupported}), iBeacon(&quot;{E9052F1E-9D67-4A6E-B2D7-459D132D6A94}&quot;, 0, 0, -50)]) 3.9.3 Create Profile Data defineProfile([Service(SIG_UUID_SERVICE_GENERIC_ACCESS), Characteristic(SIG_UUID_CHARACT_GAP_DEVICE_NAME, ATT_PROPERTY_READ, &quot;Hello, Nim&quot;), Characteristic(SIG_UUID_CHARACT_GAP_APPEARANCE, ATT_PROPERTY_READ, [0u8, 0]), Service(SIG_UUID_SERVICE_BATTERY_SERVICE), Characteristic(SIG_UUID_CHARACT_BATTERY_LEVEL, ATT_PROPERTY_READ, [20u8], &quot;HANDLE_BATTERY_LEVEL&quot;)], &quot;profileData&quot;) Once above code got compiled, ATT database is stored in profileData, handle of battery level characteristic is identified by a const HANDLE_BATTERY_LEVEL, and the offset (in byte) of battery level value in ATT base (i.e. profileData) is identified by a const HANDLE_BATTERY_LEVEL_OFFSET. We can use these variables and constants generated by macro defineProfile just as normal ones. For example, let’s create a task that updates battery level pseudo randomly: proc updateBatteryLevel(unused: pointer) {.noconv.} = while true: vTaskDelay(pdMS_TO_TICKS(1000)) profileData[HANDLE_BATTERY_LEVEL_OFFSET] = rand_level() ... discard xTaskCreate(updateBatteryLevel, &quot;b&quot;, configMINIMAL_STACK_SIZE, nil, configMAX_PRIORITIES - 1, nil) There are at least three ways to generate pseudo random number in Nim, use PRNG provided by C’s stdlib, use PRNG provided by provided by Nim, or create our own PRNG. Use C’s PRNG # It&#39;s easy to import C functions and use them proc rand(): cint {. importc: &quot;rand&quot;, header: &quot;stdlib.h&quot;.} proc rand_level(): uint8 = cast[uint8](rand() mod 101) Use Nim’s PRNG import random proc rand_level(): uint8 = cast[uint8](rand(0..100)) Create a simple PRNG proc rand_level(): uint8= var last {.global.} = 0u16 last = (last * 173 + 31) and 0x7fffu16 return cast[uint8](last mod 101) As we see, all three ways are easy in Nim. platform_hrng can be used to initialized PRNG. 3.9.4 Benefits of Adopting Nim Nim is as powerful as C because SDK provides bindings of all C APIs for Nim. There are many benefits of adopting Nim, such as it supports meta-programming and it is strongly typed. Meta-programming With metaprogramming, we can create advertising and ATT database at compile time, which has 0 overhead in runtime obviously. Strongly Typed Nim is more strongly typed than C, which can help to make code safer. https://developer.apple.com/ibeacon/↩︎ Note that UUID is not allowed to be all 0s in final products.↩︎ Makefile follows the syntax of GNU make.↩︎ https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.health_thermometer.xml↩︎ Apps can report a different version in FOTA. It is not reqired to be same as in Environment Options.↩︎ https://en.wikipedia.org/wiki/Metaprogramming↩︎ "],
["core-tools.html", "Chapter 4 Core Tools 4.1 ingWizard 4.2 Downloader 4.3 ingTracer", " Chapter 4 Core Tools SDK core tools play an important role in the BLE device development. 4.1 ingWizard ingWizard is the recommended entry point in the whole development life cycle. With it, we can create &amp; open project, edit project data, and migrate projects, etc. Create Project ingWizard’s new project wizard assists the creation of new projects. We can select favourate IDE, peripheral role, edit advertising and profile data, enable FOTA and logging, etc. Once a project is created, following files are also created, used by ingWizard but not IDE, and they shoule not be deleted, or ingWizard will not to function properly: $(ProjectName).ingw This file shares the same name with the project with an extension .ingw. It contains crucial information about the project and SDK. Without this information, it becomes impossible to do migration. Advertising Data Editor This editor helps us to generate advertising data. It can also be opened from main menu Tools -&gt; Advertising Data Editor .... GATT Profile Editor (or GATT/ATT Database Editor) This editor helps us to build GATT profile data. It can also be opened from main menu Tools -&gt; Profile Database Editor .... This editor supports three type of services, SIG defined services, INGChips defined services and user defined services. To add an user defined service, it must be create beforehandle (see below). Manage Custom Services This editor can be opened from main menu Tools -&gt; Manage Custom GATT Services .... We can add, delete and edit custom services. Custom Services and characteristics are all named with a prefix which is deduced from company name initialized when installing SDK, and updatable through Environment Options. Migration In case a new version of SDK is installed, ROM and RAM used by platform might be changed, so projects settings need to be updated accordingly. This process is automated by right click on a project and select Check &amp; Fix Settings .... Alway remember to backup your project before perform a migration, either by committing all changes into version control system or making a full backup. 4.2 Downloader 4.2.1 Introduction This downloader downloads up-to six images (binaries) to flash through UART connection. It co-operate with bootloader. Bootloader can be made into flash downloading mode either by: Asserting boot pin (this is used in the vast majority of cases), Setting entry point which is stored Flash to an invalid address. When 918xx is powered on, bootloader checks above conditions. If any conditions are true, bootloader sends the handshaking message. User can download any files, although typically these files are generated by IDE tools. The load address of image (binary) must be aligned at flash page boundary. Each flash page has 8192 (0x2000) bytes. Flash starts from 0x4000, so the load address should be 0x4000 + X * 0x2000, where X is an integer. Downloader complains if the load address is not correct. Note that when this downloader is started from ingWizard, binaries have already been correctly configured. Click Setup UART ... to configure UART (Figure 4.1). Users need to set Port Number to the value shown in Windows Device Manager, for example, if “COM9” is used, then set Port Number to COM9, or simply 9. Baud rate can be set to a value larger than 115200, such as 256000, 512000, 750000, 921600, etc, to achieve a faster download speed. The maximum supported baud rate is 921600. Due to the limitation of internal flash characters, there isn’t any further significant improvement for baud rate larger than 512000. Other fields should be left unchanged. Figure 4.1: Configurate UART The whole downloading procedure is composed of several steps, such as downloading, verification, set entry address, and launching app. These steps can be configured by clicking Options (Figure 4.2). Figure 4.2: Downloader Options Entry address 0x4000 equals to the load address of platform binary. If “Verify Download” is enabled, then data will be read back and compare with origin file to ensure data is correctly downloaded. Data blocks are CRC checked, so “Verify Download” can be kept disabled on a regular basis. If downloading keeps failing on specific address, then we can enable it to double check if flash is malfunctional. In this case, when mismatch is found, read-back data will be stored to a file. When “Batch” mode is enabled, downloader will keep waiting for bootloader handshaking, and once received handshaking, downloading starts; after downloading completes, downloader will start waiting again. When “Batch” mode is disabled, downloader will no longer wait for handshaking after downloading completes. Click Start to start downloading, or rather start waiting for handshaking. Bootloader sends handshaking message only once, and if chips are already powered up, it may be too late to receive handshaking. In this case, we can click Force to skip handshaking and start downloading immediately. 4.2.2 Scripting &amp; Mass Production This downloader supports powerful scripting, making it suitable for mass production. In the script, two event handlers (functions) are required to be defined. OnStartRun This event handler gets called when each round of downloading starts; OnStartBin This event handler gets called when a binary starts downloading. Here, binary data can be modified on-the-fly before it is written into flash. When “Batch” mode is enabled, this downloader keeps a counter which is increased by 1 after downloading finishes. This counter is shown as Counter.Current shown in Figure 4.2. There is also a variable called Counter.Limit. In “Batch” mode, before a new round of downloading starts, Counter.Current is checked against this limit, if it is larger than limit, “Batch” mode stops automatically. For example, if Counter.Current and Counter.Limit are set to 10 and 13 respectively, then “Batch” mode will run for 4 rounds in total, with Counter.Current equals to 10, 11, 12 and 13. After “Batch” mode stops, Counter.Current equals to 14. The language used for scripting is RemObjects Pascal Script17, which is quite similar to C, and easy to develop. Below is an simple but working example, in which, the batch round number (BatchCounter) is written to a fixed location in the binary. // we can use constants const BD_ADDR_ADDR = $1; // BatchCounter is just Counter.Current procedure OnStartRun(const BatchCounter: Integer; var Abort: Boolean); begin // Use *Print* for logging and debugging Print(&#39;OnStartRun %d&#39;, [BatchCounter]); // we can abort downloading by assigning True to *Abort* // Abort := True; end; procedure OnStartBin(const BatchCounter, BinIndex: Integer; var Data: TBytes; var Abort: Boolean); begin // Note that BinIndex counts from 1 (not 0), just as shown on GUI if BinIndex &lt;&gt; 2 then Exit; // We can modify binary data before it is downloaded into flash Data[BD_ADDR_ADDR + 0] := BatchCounter and $FF; Data[BD_ADDR_ADDR + 1] := (BatchCounter shr 8) and $FF; Data[BD_ADDR_ADDR + 2] := (BatchCounter shr 8) and $FF; end; 4.2.3 Flash Read Protection To protect illegal access of data &amp; program stored in flash, 918xx has a read-protection mechanism. Once read-protection is enabled, JTAG/SW and this downloader can not be able to access flash any more. To re-enable JTAG/SW debugging functionality and downloading, the read-protection must be turned off by a procedure called unlock. Flash data is erased in this procedure. Once the app is ready to ship, and it is decided that data &amp; program must be protected from illegal access, just enable “Read Protection” as shown in Figure 4.2. To download program into a read protected, check Unlock Before Download option. As flash data is erased during unlocking, do not forget to re-download platform binary. All configurations are stored in an ini file. 4.2.4 Python Version SDK also provides a Python version downloader (icsdw.py). It’s open source and easy to be integrated with other tools. This version is written in Python 3. It uses PySerial18 package to access serial port, so run “pip install pyserial” to install the package. Python downloader shares the same ini file with only one exception: Scripting. The GUI downloader stores RemObjects Pascal source code with key named “script” in section “options”, while the python version stores the path to a user module. The path can be a full path or a relative path (relative to the location of the ini file). In the user module, two methods are required to be defined to handle events as in the GUI downloader, on_start_run &amp; on_start_bin. Below is an example, in which, the batch round number (batch_counter) is written to a fixed location in #2 binary. # return abort_flag def on_start_run(batch_counter: int): return False # return abort_flag, new_data def on_start_bin(batch_counter: int, bin_index: int, data: bytes): if bin_index != 2: return False, data ba = bytearray(data) addr = batch_counter.to_bytes(4, &#39;little&#39;) ba[1:5] = addr return False, bytes(ba) 4.3 ingTracer ingTracer is the visual tool for inspecting recorded Trace data introduced in [Debugging &amp; Tracing]. To limit items drawn on screen, ingTracer breaks trace data into frames. Each frame has a length of 5sec. When a frame is selected, besides the current frame, the previous and the next one are also shown for continuity. Figure 4.3: ingTracer Main UI Graph shows all trace data visually. By clicking an item in Graph, detailed information is decoded and shown in Message Decoder and Message Hex Viewer. Graph supports some of CAD operations, such as zooming, panning, measuring, etc. Checkout menu Help -&gt; About for detailed information. (Figure 4.3) Figure 4.4: MSC Generated by ingTracer To help analyzing app &amp; high layer issues, ingTrace can generate MSC (message sequence chart) for each connection. While Graph emphasizes on timing between events, MSC emphasizes on procedure and fits better for protocol analysis. Message can be decoded by clicking on the [+] mark (Figure 4.4). https://github.com/remobjects/pascalscript↩︎ https://pypi.org/project/pyserial/↩︎ "],
["dive-into-sdk.html", "Chapter 5 Dive Into SDK 5.1 Memory Management 5.2 Multitasking 5.3 Interrupt Management 5.4 Power Management 5.5 CMSIS API 5.6 Debugging &amp; Tracing", " Chapter 5 Dive Into SDK This chapter discusses some important topics that are critical to use SDK efficiently. 5.1 Memory Management There are mainly three type of memory management methods: Statically allocated global variables Dynamically allocated and freed on stack Manually allocated and freed on heap RAM is shared between platform and user applications. When a new project is created by ingWizard, RAM settings is configured properly. Developers are not suggested to modify these settings. 5.1.1 Global Variables This is the recommended way to define variables that have a full lift span in the app. They are allocated in the fixed location and their content can be checked easily in debugger. 5.1.2 Using Stack For variables that are only used within a limited scope, such as a function, we can allocated them on stack. Cares must be taken that size of stack is limited, and it might overflow if too much memory is allocated. The app_main function &amp; interrupts serving routines shares the same global stack with platform’s main function, whose size is defined as 256 bytes. Callback functions registered into Bluetooth stack shares the same task stack with the stack task, whose size is defined as 1024 bytes, and about half is left to be used by app. Developers can create new tasks by calling FreeRTOS APIs. In these cases, stack size should be carefully examined. Use tools to check required stack maximum depth of functions. 5.1.3 Using Heap Generally, heap is not a recommended way for memory management in embedded applications. There are several cons included but not limited to: Space Overhead Some bytes are wasted to store extra information and extra program. Time Overhead It costs cycles to allocate and free memory blocks. Fragmentation Based on these considerations, the heap used by malloc &amp; free has been totally disabled by setting its size to 0. If such heap is TRULY required, it can be re-enabled by changing its size to a proper value when creating projects. Be sure to check follow alternatives before using malloc &amp; free: Use global variables Use memory pool19 This is probably the choice for most cases. Use FreeRTOS’s heap and memory functions, pvPortMalloc &amp; pvPortFree Note that this heap is used by platform &amp; FreeRTOS itself, and it may not have too much free space left for apps. The standard malloc &amp; free can be configured to be overridden and backed by pvPortMalloc &amp; pvPortFree when setting up heap in ingWizard. Once overridden, the allocator from libc is omitted, and malloc &amp; free are implemented by pvPortMalloc &amp; pvPortFree respectively. 5.2 Multitasking It is recommend to have a check on Mastering the FreeRTOS™ Real Time Kernel. Some tips: Do not do too much processing in interrupt handlers, but defer it to tasks as soon as possible Callback functions registered into Bluetooth stack are executed in the context of the stack task, so do not do too much processing in these functions either Use message passing function btstack_push_user_msg to get synchronized with Bluetooth stack (see Inter-task Communication) 5.3 Interrupt Management To create traditional ISR for interrupts, apps only need to register callback functions through a platform API platform_set_irq_callback. Apps can use following APIs to modify interrupts configuration and states: NVIC_SetPriority Note that the highest allowed priority is configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 2, i.e. that priority parameter must be larger than or equal to this value, indicating a lower or equal priority. NVIC_EnableIRQ NVIC_DisableIRQ NVIC_ClearPendingIRQ etc… 5.4 Power Management In most case, platform manages the power saving feature of ING918xx SoC automatically and tries the minimize the power consumption in all circumstances, with only one exception, deep sleep. In deep sleep, all components, except those required for power saving control and real-time clocks, are powered down. Some peripherals may be used by apps, and platform does not know how to configure them. So, apps have to get involved in the waking up process after deep sleep. Platform will also check with app if deep sleep is allowed, and fall back to less aggressive power saving modes when deep sleep is not allowed. To use deep sleep, two callback functions are needed, see platform_set_evt_callback. To ease development &amp; debug, power saving can be turned on or off by calling platform_config. Besides the above automatic power management schema, apps can also shutdown the whole system and reboot after a specified duration. In shutdown state the whole system has the least power consumption. See platform_shutdown. In shutdown state, a portion of data can be kept optionally at the cost of a little more power consumption. In case of only a little piece of data needs to be kept, for example no more than four bits, SDK provides a pair of APIs for this, platform_write_persistent_reg and platform_read_persistent_reg. 5.5 CMSIS API SDK tries to encapsulate CMSIS APIs to ease the development. Be careful when calling these APIs in apps as it may affect the platform program. Following operations are strictly forbidden: Changing the vector table offset register Modify configurations of internal interrupts, i.e. those not listed in Table 6.1. 5.6 Debugging &amp; Tracing Besides online debugging, SDK provides two methods to assist debugging. printf printf is the most convenient way to check program’s behaviour. ingWizard can generate necessary code to use printf. Trace Internal state &amp; HCI messages can be recorded through this trace machenism. ingWizard can generate necessary code to use trace, too. There are several types of trace data, which are predefined and can’t be changed. Which types of trace data are going to be recorded is programmable. Use ingTracer to view the recorded trace data. Table 5.1: Comparison of printf and Trace Debug Option Pros Cons printf Universal slow Trace Binary data, fast Data types are predefined Both printf and trace can be directed to UART ports or SEGGER RTT20. Table 5.2 is a comparison of these two transport options. Table 5.2: Comparison of UART and SEGGER RTT Transport Option Pros Cons UART Universal, easy to use Slower, consume more CPU cycles SEGGER RTT Fast J-Link is required, hard to capture power up log 5.6.1 Tips on SEGGER RTT Use J-LINK RTT Viewer to view printf outputs in real-time. Use J-LINK RTT Logger to record trace outputs to files. This logger will ask for the settings of RTT. Device name is “CORTEX-M3”. Target interface is “SWD”. RTT Control Block address is the address of a variable named _SEGGER_RTT, which can be found in .map file. RTT channel index is 0. Blow is a sample session. ------------------------------------------------------------ Device name. Default: CORTEX-M3 &gt; Target interface. &gt; SWD Interface speed [kHz]. Default: 4000 kHz &gt; RTT Control Block address. Default: auto-detection &gt; 0x2000xxxx RTT Channel name or index. Default: channel 1 &gt; 0 Output file. Default: RTT_&lt;ChannelName&gt;_&lt;Time&gt;.log &gt; ------------------------------------------------------------ Connected to: J-Link Lite for Ghostyu compiled Jan 8 2018 13:10:00 S/N: 180100254 Searching for RTT Control Block...OK. 1 up-channels found. RTT Channel description: Index: 0 Name: Terminal Size: 500 bytes. Output file: .....log Getting RTT data from target. Press any key to quit. Alternativaly, this tool can be called from command line. Address of_SEGGER_RTT can be specified by a range, and the tool will search for it automatically. For examples, JLinkRTTLogger.exe -If SWD -Device CORTEX-M3 -Speed 4000 -RTTSearchRanges &quot;0x20005000 0x8000&quot; -RTTChannel 0 file_name 5.6.2 Memory Dump We are committed to delivery high quality platform binary. If an assertion had occurred in platform binary, it is suggested to create a full memory dump and save all registers, then contact for further support. There are two memory regions (Table 5.3). Table 5.3: Memory Regions Region Start Address Size #1 0x20000000 0x10000 (for 128kB RAM chip series) 0x08000 (for 64kB RAM chip series) #2 0x400A0000 0x10000 (for 128kB RAM chip series) 0x08000 (for 64kB RAM chip series) Memory can be dumped through debuggers: Keil μVision In debug session, open the Command Window, use save to save each memory region. For example: save sysm.hex 0x20000000,0x20010000 save share.hex 0x400A0000,0x400B0000 Note: the second address is the address of last byte plus 1 of the dump range, and should be aligned with the chip series that is used in the project. J-Link Commander Once connected, use regs to shows all current register values, and savebin to save target memory into binary file. For example: savebin sysm.bin 0x20000000 0x10000 savebin share.bin 0x400A0000 0x10000 IAR Embedded Workbench In debug session, open a Memory window, and select “Memory Save …” from popup menu. Rowley Crossworks for ARM &amp; SEGGER Embedded Studio for ARM In debug session, open a Memory window, for each memory region: Fill in the start address and size; Use “Memory Save …” from popup menu. GDB (GNU Arm Embedded Toolchain and Nim) In GDB debug session, use dump command to save each memory region. Memory can be also dumped by a piece of specific code. For example, in the event handler of PLATFORM_CB_EVT_ASSERTION, dump all memory data to UART. https://en.wikipedia.org/wiki/Memory_pool↩︎ https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/↩︎ "],
["api-ref.html", "Chapter 6 Platform API Reference 6.1 platform_32k_rc_auto_tune 6.2 platform_32k_rc_tune 6.3 platform_config 6.4 platform_get_heap_status 6.5 platform_get_us_time 6.6 platform_get_version 6.7 platform_hrng 6.8 platform_install_isr_stack 6.9 platform_printf 6.10 platform_raise_assertion 6.11 platform_rand 6.12 platform_read_info 6.13 platform_read_persistent_reg 6.14 platform_reset 6.15 platform_set_evt_callback 6.16 platform_set_irq_callback 6.17 platform_shutdown 6.18 platform_switch_app 6.19 platform_write_persistent_reg 6.20 sysSetPublicDeviceAddr", " Chapter 6 Platform API Reference 6.1 platform_32k_rc_auto_tune Automatically tune the internal 32k RC clock, and get the tuning value. 6.1.1 Prototype uint16_t platform_32k_rc_auto_tune(void); 6.1.2 Parameters Void. 6.1.3 Return Value The 16-bits tuning value. 6.1.4 Remarks This operation costs ~250ms. It is recommended to call this once and store the returned value for later usage. 6.1.5 Example uint16_t value = platform_32k_rc_auto_tune(); 6.2 platform_32k_rc_tune Tune internal the 32k RC clock with the tune value. 6.2.1 Prototype void platform_32k_rc_tune(uint16_t value); 6.2.2 Parameters uint16_t value Value used to tune the clock (returned by platform_32k_rc_auto_tune) 6.2.3 Return Value Void. 6.2.4 Remarks void. 6.2.5 Example platform_32k_rc_tune(value); 6.3 platform_config Configure some platform functionalities. 6.3.1 Prototype void platform_config(const platform_cfg_item_t item, const uint32_t flag); 6.3.2 Parameters const platform_cfg_item_t item Specify the item to be configured. It can be one of following values: PLATFORM_CFG_LOG_HCI: Host controller interface messages. Default: Disabled. PLATFORM_CFG_POWER_SAVING: Power saving. Default: Disabled. PLATFORM_CFG_TRACE_MASK: Bit map of selected trace items. Default: 0. typedef enum { PLATFORM_TRACE_ID_EVENT = 0, PLATFORM_TRACE_ID_HCI_CMD = 1, PLATFORM_TRACE_ID_HCI_EVENT = 2, PLATFORM_TRACE_ID_HCI_ACL = 3, PLATFORM_TRACE_ID_LLCP = 4 } platform_trace_item_t; PLATFORM_CFG_RC32K_EN: Enable/Disable RC 32k clock. Default: Enabled. PLATFORM_CFG_OSC32K_EN: Enable/Disable 32k crystal oscillator. Default: Enabled. PLATFORM_CFG_32K_CLK: 32k clock selection. Flag is platform_32k_clk_src_t. Default: PLATFORM_32K_RC typedef enum { PLATFORM_32K_OSC, // External 32k crystal oscillator PLATFORM_32K_RC // Internal RC 32k clock } platform_32k_clk_src_t; When modifying this configuration, both RC32K and OSC32K should be enabled and run: * For OSC32K, wait until status of OSC32K is OK; * For RC32K, wait 100us after enabled. Note: Wait another 100us before disabling the unused clock. PLATFORM_CFG_32K_CLK_ACC: Configure 32k clock accurary in ppm. PLATFORM_CFG_32K_CALI_PERIOD: 32K clock auto-calibartion period in seconds. Default: 3600 * 2 (2 hours). PLATFORM_CFG_DEEP_SLEEP_TIME_REDUCTION: Sleep time reduction (deep sleep mode) in micro seconds. Default: ~550us. PLATFORM_CFG_SLEEP_TIME_REDUCTION: Sleep time reduction (other sleep mode) in micro seconds. Default: ~450us. PLATFORM_CFG_LL_DBG_FLAGS: Link layer flags. Combination of bits in ll_cfg_flag_t. typedef enum { LL_FLAG_DISABLE_CTE_PREPROCESSING = 1, // disable CTE processing LL_FLAG_LEGACY_ONLY_INITIATING = 4, // initiating only using legacy ADV LL_FLAG_LEGACY_ONLY_SCANNING = 8, // scanning only using legacy ADV } ll_cfg_flag_t; PLATFORM_CFG_LL_LEGACY_ADV_INTERVAL: Link layer legacy advertising intervals for high duty cycle (higher 16bits) and normal duty cycle (lower 16bits) in micro seconds. Default for high duty cycle: 1250; default for normal duty cycle: 1500. const uint32_t flag To disable or enable an item. It can be one of following values: PLATFORM_CFG_ENABLE PLATFORM_CFG_DISABLE 6.3.3 Return Value Void. 6.3.4 Remarks Void. 6.3.5 Example // Enable HCI logging platform_config(PLATFORM_CFG_LOG_HCI, PLATFORM_CFG_ENABLE); 6.4 platform_get_heap_status Get current heap status, such as available size, etc. 6.4.1 Prototype void platform_get_heap_status(platform_heap_status_t *status); 6.4.2 Parameters platform_heap_status_t *status Heap status. 6.4.3 Return Value Void. 6.4.4 Remarks Heap status is defined as: typedef struct { uint32_t bytes_free; // total free bytes uint32_t bytes_minimum_ever_free; // mininum of bytes_free from startup } platform_heap_status_t; 6.4.5 Example platform_heap_status_t status; platform_get_heap_status(&amp;status); 6.5 platform_get_us_time Read the internal timer counting from BLE initialization. 6.5.1 Prototype int64_t platform_get_us_time(void); 6.5.2 Parameters Void. 6.5.3 Return Value Value of the internal timer counting at 1us. 6.5.4 Remarks This timer restarts after shutdown, while RTC timer does not. 6.5.5 Example platform_get_us_time(); 6.6 platform_get_version Get version number of platform. 6.6.1 Prototype const platform_ver_t *platform_get_version(void); 6.6.2 Parameters Void. 6.6.3 Return Value Pointer to platform_ver_t. 6.6.4 Remarks Platform version number has three parts, major, minor and patch: typedef struct platform_ver { unsigned short major; char minor; char patch; } platform_ver_t; 6.6.5 Example const platform_ver_t *ver = platform_get_version(); printf(&quot;Platform version: %d.%d.%d\\n&quot;, ver-&gt;major, ver-&gt;minor, ver-&gt;patch); 6.7 platform_hrng Generate random bytes by using hardware random-number generator. 6.7.1 Prototype void platform_hrng(uint8_t *bytes, const uint32_t len); 6.7.2 Parameters uint8_t *bytes Random data output. const uint32_t len Number of random bytes to be generated. 6.7.3 Return Value Void. 6.7.4 Remarks Time consumption to generate a fix length of data is undetermined. 6.7.5 Example uint32_t strong_random; platform_hrng(&amp;strong_random, sizeof(strong_random)); 6.8 platform_install_isr_stack Install a new stack for ISR. 6.8.1 Prototype void platform_install_isr_stack(void *top); 6.8.2 Parameters void *top Top of the new stack, which must be 4-bytes aligned. 6.8.3 Return Value Void. 6.8.4 Remarks In case apps need a much larger stack than the default one in ISR, a new stack can be installed to replace the default one. This function is only allowed to be called in app_main. The new stack is put into use after app_main returns. 6.8.5 Example uint32_t new_stack[2048]; ... platform_install_isr_stack(new_stack + sizeof(new_stack) / sizeof(new_stack[0])); 6.9 platform_printf The printf function stored in platform binary. 6.9.1 Prototype void platform_printf(const char *format, ...); 6.9.2 Parameters const char *format Format string. ... Variable arguments for format string. 6.9.3 Return Value Void. 6.9.4 Remarks There are pros &amp; cons to use this function. Pros: This function is located in platform binary, app binary size can be saved. Cons: Output is directed PLATFORM_CB_EVT_PUTC event, so its callback function must be defined. 6.9.5 Example platform_printf(&quot;Hello world&quot;); 6.10 platform_raise_assertion Raise a software assertion. 6.10.1 Prototype void platform_raise_assertion(const char *file_name, int line_no); 6.10.2 Parameters const char *file_name File name where the assertion occurred. int line_no Line number where the assertion occurred. 6.10.3 Return Value Void. 6.10.4 Remarks Void. 6.10.5 Example if (NULL == ptr) platform_raise_assertion(__FILE__, __LINE__); 6.11 platform_rand Generate a pseudo random integer by internal PRNG. 6.11.1 Prototype int platform_rand(void); 6.11.2 Parameters Void. 6.11.3 Return Value A pseudo random integer in range of 0 to RAND_MAX. 6.11.4 Remarks Seed of the internal PRNG is initialized by HRNG at startup. 6.11.5 Example printf(&quot;rand: %d\\n&quot;, platform_rand()); 6.12 platform_read_info Read platform information 6.12.1 Prototype uint32_t platform_read_info(const platform_info_item_t item); 6.12.2 Parameters const platform_info_item_t item Information item. typedef enum { PLATFORM_INFO_OSC32K_STATUS, // Read status of 32k crystal oscillator. // Value 0: not OK; Non-0: OK } platform_info_item_t; 6.12.3 Return Value Value of the information item. 6.12.4 Remarks Void. 6.12.5 Example platform_read_info(PLATFORM_INFO_OSC32K_STATUS); 6.13 platform_read_persistent_reg Read value from the persistent register. See also platform_write_persistent_reg. 6.13.1 Prototype uint32_t platform_read_persistent_reg(void); 6.13.2 Parameters Void. 6.13.3 Return Value The **four* bits value writen by platform_write_persistent_reg. 6.13.4 Remarks Void. 6.13.5 Example platform_read_persistent_reg(); 6.14 platform_reset Reset platform (SoC). 6.14.1 Prototype void platform_reset(void); 6.14.2 Parameters Void. 6.14.3 Return Value Void. 6.14.4 Remarks When calling this function, the code after it will not be executed. 6.14.5 Example if (out-of-memory) platform_reset(); 6.15 platform_set_evt_callback Registers callback functions to platform events. 6.15.1 Prototype void platform_set_evt_callback(platform_evt_callback_type_t type, f_platform_evt_cb f, void *user_data); 6.15.2 Parameters platform_evt_callback_type_t type Specify the event type to which the callback function is registered. It can be one of following values: PLATFORM_CB_EVT_PUTC: Ouput ASCII character event When platform want to output ASCII characters for logging, this event is fired. Parameter void *data passed into the callback function is casted from char *. ingWizard can automatically generate code that redirects platform log to UART if Print to UART is checked on Common Function when creating a new project. PLATFORM_CB_EVT_PROFILE_INIT: Profile initialization event When host initializes, this event is fired to request app to initialize GATT profile. ingWizard can automatically generate code for this event when creating a new project. PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP: Wakeup from deep sleep event When waking up from deep sleep, this event is fired. During deep sleep, peripheral interfaces (such as UART, I2C, etc) are all powered off. So, when waking up, these interfaces might need to be re-initialized. ingWizard can automatically generate code for event if Deep Sleep is checked on Common Function when creating a new project. PLATFORM_CB_EVT_QUERY_DEEP_SLEEP_ALLOWED: Query if deep sleep is allowed event When platform prepares to enter deep sleep mode, this event is fired to query app if deep sleep is allow at this moment. Callback function can reject deep sleep by returning 0, and allow it by returning a non-0 value. ingWizard can automatically generate code for event if Deep Sleep is checked on Common Function when creating a new project. PLATFORM_CB_EVT_HARD_FAULT: Hard fault occurs When hard fault occurs, this event is fired. Parameter void *data passed into the callback function is casted from hard_fault_info_t *. If this callback is not defined, CPU enters a dead loop when hard fault occurs. PLATFORM_CB_EVT_ASSERTION: Software assertion fails When software assertion fails, this event is fired. Parameter void *data passed into the callback function is casted from assertion_info_t *. If this callback is not defined, CPU enters a dead loop when assertion occurs. PLATFORM_CB_EVT_LLE_INIT: Link layer engine initialized. When link layer engine initialized, this event is fired. PLATFORM_CB_EVT_HEAP_OOM: Out of memory. When allocation on heap fails (heap out of memory), this event is fired. If this event is fired and no callback is defined, CPU enters a dead loop. PLATFORM_CB_EVT_TRACE: Trace output. When a trace item is emitted, this event is fired. Apps can define a callback function for this event to save or log trace output. param to the callback is casted from platform_trace_evt_t * (See Debugging &amp; Tracing). typedef struct { const void *data1; const void *data2; uint16_t len1; uint16_t len2; } platform_evt_trace_t; A trace item is a combination of data1 and data2. Note: len1 or len2 might be 0, but not both; If callback function finds that it can’t output data of size len1 + len2, then, both data1 &amp; data2 should be discarded to avoid trace item corruption. f_platform_evt_cb f The callback function registered to event type. f_platform_evt_cb is: typedef uint32_t (*f_platform_evt_cb)(void *data, void *user_data); void *user_data This is passed to callback function’s user_data unchanged. 6.15.3 Return Value Void. 6.15.4 Remarks It is not required to register callback functions to each event. If no callback function is registered to PLATFORM_CB_EVT_PUTC event, all platform log is discarded. If no callback function is registered to PLATFORM_CB_EVT_PROFILE_INIT event, BLE device’s profile is empty. If no callback function is registered to PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP event, app will not be notified when waking up from deep sleep. If no callback function is registered to PLATFORM_CB_EVT_QUERY_DEEP_SLEEP_ALLOWED event, deep sleep is disabled. 6.15.5 Example uint32_t cb_putc(char *c, void *dummy) { // TODO: output char c to UART return 0; } ...... platform_set_evt_callback(PLATFORM_CB_EVT_PUTC, (f_platform_evt_cb)cb_putc, NULL); 6.16 platform_set_irq_callback Registers callback functions to interrupt requests. Developers do not need to define IRQ handlers in apps, but use callback functions instead. There are 11 such IRQs, summarized in Table 6.1. Table 6.1: IRQ Summary Peripheral Type Number Notes RTC 1 Real Time Clock TIMER 3 Timer GPIO 1 General Purpose Input/Output SPI 2 Serial Peripheral Interface UART 2 Universal Asynchronous Receiver-Transmitter I2C 2 Inter-Integrated Circuit 6.16.1 Prototype void platform_set_irq_callback(platform_irq_callback_type_t type, f_platform_irq_cb f, void *user_data); 6.16.2 Parameters platform_irq_callback_type_t type Specify the IRQ type to which the callback function is registered. It can be one of following values: PLATFORM_CB_IRQ_RTC, PLATFORM_CB_IRQ_TIMER0, PLATFORM_CB_IRQ_TIMER1, PLATFORM_CB_IRQ_TIMER2, PLATFORM_CB_IRQ_GPIO, PLATFORM_CB_IRQ_SPI0, PLATFORM_CB_IRQ_SPI1, PLATFORM_CB_IRQ_UART0, PLATFORM_CB_IRQ_UART1, PLATFORM_CB_IRQ_I2C0, PLATFORM_CB_IRQ_I2C1 f_platform_irq_cb f The callback function registered to IRQ type. f_platform_irq_cb is: typedef uint32_t (*f_platform_irq_cb)(void *user_data); void *user_data This is passed to callback function’s user_data unchanged. 6.16.3 Return Value Void. 6.16.4 Remarks When a callback function is registered to an IRQ, the IRQ is enabled automatically. 6.16.5 Example uint32_t cb_irq_uart0(void *dummy) { // TODO: add UART0 IRQ handling code return 0; } ...... platform_set_irq_callback(PLATFORM_CB_IRQ_UART0, cb_irq_uart0, NULL); 6.17 platform_shutdown Bring the whole system into shutdown state, and reboot after a specified duration. Optionally, a portion of memory can be retentioned during shutdown, and apps can continue to use it after reboot. Note that this function will NOT return except that shutdown procedure fails to initiate. Possible causes for failures include: External wake-up signal is issued; Input parameters are not proper; Internal components are busy. 6.17.1 Prototype void platform_shutdown(const uint32_t duration_cycles, const void *p_retention_data, const uint32_t data_size); 6.17.2 Parameters const uint32_t duration_cycles Duration (measured in cycles of 32k clock) before power on again (reboot). The minimum duration is 825 cycles (about 25.18ms). const void *p_retention_data Pointer to the start of data to be retentioned. Only data within SYSTEM memory can be retentioned. This parameter can be set to NULL when data_size is 0. data_size Size of the data to be retentioned. Set to 0 when memory retention is not needed. 6.17.3 Return Value Void. 6.17.4 Remarks Void. 6.17.5 Example // Shutdown the system and reboot after 1s. platform_shutdown(32768, NULL, 0); 6.18 platform_switch_app Switch to a secondary app. 6.18.1 Prototype void platform_switch_app(const uint32_t app_addr); 6.18.2 Parameters const uint32_t app_addr Entry address of the secondary app. 6.18.3 Return Value Void. 6.18.4 Remarks When calling this function, the code after it will not be executed. 6.18.5 Example platform_switch_app(0x80000); 6.19 platform_write_persistent_reg Write a value to the persistent register. This value is kept even in power saving, shutdown mode, or when switching to another app. 6.19.1 Prototype void platform_write_persistent_reg(const uint8_t value); 6.19.2 Parameters const uint8_t value The value. 6.19.3 Return Value Void. 6.19.4 Remarks Only four bits are saved. 6.19.5 Example platform_write_persistent_reg(1); 6.20 sysSetPublicDeviceAddr Set the public address of device. The public address of a BLE device is a 48-bit extended unique identifier (EUI-48) created in accordance with the IEEE 802-2014 standard21. INGCHIPS 918xx DO NOT have public addresses. This function should ONLY be used for debugging or testing, and NEVER be used in final products. 6.20.1 Prototype void sysSetPublicDeviceAddr(const unsigned char *addr); 6.20.2 Parameters const unsigned char *addr New public address. 6.20.3 Return Value Void. 6.20.4 Remarks In order to avoid potential issues, this function should be called before calling any GAP functions. It is recommended to call this function in app_main or PLATFORM_CB_EVT_PROFILE_INIT event callback function. 6.20.5 Example const unsigned char pub_addr[] = {1,2,3,4,5,6}; sysSetPublicDeviceAddr(pub_addr); http://standards.ieee.org/findstds/standard/802-2014.html↩︎ "],
["revision-history.html", "Chapter 7 Revision History", " Chapter 7 Revision History Version Notes Date 1.0 Initial release 2020-07-28 1.1 Add Python downloader 2020-10-10 1.2 Update API descriptions 2020-07-05 1.2.1 Update memory dump section 2020-08-02 "]
]
