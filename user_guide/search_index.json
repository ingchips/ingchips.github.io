[["index.html", "INGCHIPS SDK User Guide Chapter 1 Welcome", " INGCHIPS SDK User Guide Ingchips Technology Co., Ltd. 2025-01-20 Chapter 1 Welcome Welcome to use INGCHIPS 918xx/9186xx Software Development Kit. INGCHIPS 918xxx/9186xx are BLE 5.x full feature SoC solutions. This manual will give you an in-depth view on BLE development with 918xx/9186xx from software perspective. "],["intro.html", "Chapter 2 Introduction 2.1 Scope 2.2 Architecture 2.3 Abbreviations &amp; Terminology 2.4 References", " Chapter 2 Introduction Figure 2.1: SDK Overview INGCHIPS software development kit has following major components (see Figure 2.1): Core Tools Provide project wizard, flash loader and other functionalities. These tools make BLE development easy and seamless. Language &amp; IDE Integration Support Keil μVision1, IAR Embedded Workbench2, Rowley Crossworks for ARM3, and SEGGER Embedded Studio for ARM4. All IDE/Toolchain settings are configured by core tools properly and automatically. GNU Arm Embedded Toolchain5 is also supported. Nim6 is also supported as an alternative of C. Optionally, new projects can be configured properly to use Visual Studio Code7 as code editor. For Nim and GNU Arm Embedded Toolchain, building and downloading tasks are created and can be invoked in Visual Studio Code. Platform Bundles Provide different bundles for different application scenarios (such as typical, and extension). Each bundle contains full stack &amp; (optional) FreeRTOS binary, and C header files. Source codes for accessing peripherals are also provided. Examples Provide a rich set of BLE device examples and corresponding Android and iOS referencing applications. Documentation User guide (this document), API reference, and application notes are also provided. 2.1 Scope This document covers platform overall architecture, core tools and platform APIs. 2.2 Architecture There are two variants of bundles, one with built-in FreeRTOS (RTOS Bundles), and one without built-in RTOS (“NoOS” Bundles). 2.2.1 RTOS Bundles ING918xx/ING9186xx software architecture is shown in Figure 2.2. Bootloader is stored in ROM and can’t be modified, while platform and app executable are stored in flash. Platform executable is provided for each bundle. BLE stack, FreeRTOS and some SoC functionality are compiled into this single platform executable. When system starts up, platform executable initializes, then loads the primary app executable. Figure 2.2: Architecture A secondary app can only be asked to execute programmaticly. It is possible to download several secondary apps, and to switch between them programmaticly. After reset, platform will load the primary app executable as usual. Entry address of the primary app is managed by SDK tools, while entry addresses of secondary apps can be configured manually. 2.2.1.1 Apps built with C App executable’s main function is named app_main, where app gets initialized: int app_main(void) { ... return 0; } app_main should always return 0. Platform, BLE stack and FreeRTOS APIs are all declared in corresponding C header files. To use these APIs, just include the necessary header files. 2.2.1.2 Apps built with Nim App executable’s main function is named appMain, where app gets initialized: proc appMain*(): int {.exportc noconv.} = ... return 0; appMain should always return 0. Thanks to the separation of platform and app, size of the app executable is significantly reduced. There are several benefits of this, not limited to: Smaller &amp; cleaner app code base Faster downloading &amp; FOTA Focus on function development Flash tools are available for all supported IDEs and installed when installing SDK. App debugging is also quite easy: download platform binary with flash downloader (Section 4.2), then download &amp; debug apps in IDE as usual. 2.2.2 “NoOS” Bundles When developers want to use other RTOS, or use features that are missing in those RTOS bundles, developers can choose the “NoOS” bundles. A generic RTOS interface is defined, and developers should provide an implementation of this interface to platform binaries through the returning value of app_main: uintptr_t app_main(void) { ... return (uintptr_t)os_impl_get_driver(); } 2.3 Abbreviations &amp; Terminology Table 2.1: Abbreviations Abbreviation Notes ATT Attribute Protocol BLE Bluetooth Low Energy FOTA Firmware Over-The-Air IRQ Interrupt Request GAP Generic Access Profile GATT Generic Attribute Profile RAM Random Access Memory ROM Read Only Memory SDK Software Development Kit Table 2.2: Terminology Terminology Notes Flash Memory An electronic non-volatile computer storage medium FreeRTOS A real-time operating system kernel 2.4 References Host API Reference Bluetooth SIG8 FreeRTOS9 Mastering the FreeRTOS™ Real Time Kernel10 https://www.keil.com/↩︎ https://www.iar.com/iar-embedded-workbench/↩︎ https://www.crossworks.com/index.htm/↩︎ https://www.segger.com/products/development-tools/embedded-studio/↩︎ https://developer.arm.com/open-source/gnu-toolchain/gnu-rm↩︎ https://www.nim-lang.org↩︎ https://code.visualstudio.com↩︎ https://www.bluetooth.com/↩︎ https://freertos.org↩︎ https://www.freertos.org/Documentation/161204_Mastering_the_FreeRTOS_Real_Time_Kernel-A_Hands-On_Tutorial_Guide.pdf↩︎ "],["tutorial.html", "Chapter 3 Tutorials 3.1 Hello World 3.2 iBeacon 3.3 Thermometer 3.4 Thermometer with FOTA 3.5 iBeacon Scanner 3.6 Notification &amp; Indication 3.7 Throughput 3.8 Dual Role &amp; BLE Gateway 3.9 Hello, Nim", " Chapter 3 Tutorials Following step-by-step tutorials show the basic usage of core tools and concepts of the SDK. 3.1 Hello World In this tutorial, we are going to create a device which is advertising its name, “Hello, 世界”. Start ingWizard from start menu and select menu item Project -&gt; New Project .... This brings up the project wizard. This first page shown by the wizard is Development Tool (see Figure 3.1). 3.1.1 Development Tool Page Figure 3.1: Choose Project Type On this page (Figure 3.1): Choose IDE/Toolchain Choose a project name Choose where to store your project ingWizard provides below handy functionality: If Git is used for software configuration management, select Setup .gitignore; If Visual Studio Code is the preferred code editor, select Setup Visual Studio Code. Then press Next to proceed to the next page, Choose Chip Series. 3.1.2 Choose Chip Series Page Figure 3.2: Choose Chip Series On this page (Figure 3.2), choose the target chip series of the project. Then press Next to proceed to the next page, Choose Project Type. 3.1.3 Choose Project Type Page Figure 3.3: Choose Project Type On this page (Figure 3.3), select Typical. Then press Next to proceed to the next page, Role of Your Device. 3.1.4 Role of Your Device Page Figure 3.4: Role of Your Device On this page (Figure 3.4), just select Peripheral, and press Next to proceed to the next page, Peripheral Setup. 3.1.5 Peripheral Setup Page Figure 3.5: Peripheral Setup On this page (Figure 3.5), select Legacy advertising. Phones that support BLE 5.x extended advertising are still rare at present (r Sys.Date()) even if BLE 5.0 is declared as “supported”, so we use legacy advertising for better compatibility. Furthermore, legacy advertising can be changed to BLE 5.x extended advertising by toggling a single bit later. Click Setup Advertising Data button, which will bring up the advertising data editor (Figure 3.6). In the editor, type name to quickly search for the GAP advertising item 09 - «Complete Local Name», and click Add to add it into our device’s advertising data. Click the newly added 09 - «Complete Local Name» item, then fill in “Hello, 世界” in the data editor shown below and press Enter. Data Preview will be updated and the whole advertising data is shown in raw bytes with a few comments on each item. Obviously, Chinese characters are encoded in UTF-8 properly. Figure 3.6: Edit Advertising Data Now, click OK to go back to project wizard, and press Next to proceed to the next page Security &amp; Privacy. 3.1.6 Security &amp; Privacy Page Figure 3.7: Firmare Over-The-Air Leave all options as default (Figure 3.7), and press Next to proceed to the next page Firmare Over-The-Air. 3.1.7 Firmare Over-The-Air Page Figure 3.8: Firmare Over-The-Air Leave all options as default (Figure 3.8), and press Next to proceed to the last page Common Functions. 3.1.8 Common Functions Page Figure 3.9: Common Functions On this page (Figure 3.9), we also accept the default settings and press Create. Now your project is created (Figure 3.10), and ready for building and downloading. Figure 3.10: “Hello, 世界” is Ready 3.1.9 Build your project Back to the main window of ingWizard (Figure 3.10), click on your project to open it. Build your project in IDE. 3.1.10 Download To download your project, back to ingWizard (Figure 3.10), right click on your project, and select Download to Flash from the popup menu to start the downloader (Figure 3.11). Figure 3.11: Download to Flash All settings in the downloader are ready except the UART port number. In the downloader, configure the correct UART port and then click Start. Once downloaded, check if you can find a device named “Hello, 世界” by LightBlue, INGdemo (Figure 3.12) or other apps. Note that, this device may not be listed in the Bluetooth menu of system settings at present. Figure 3.12: Hello, 世界 3.2 iBeacon In this tutorial, let’s make an iBeacon. iBeacon is a protocol developed by Apple11 and introduced at the Apple Worldwide Developers Conference in 2013. Beacons are a class of Bluetooth low energy (BLE) devices that broadcast their identifier to nearby portable electronic devices. This technology enables smartphones, tablets and other devices to perform actions when in close proximity to an iBeacon device. Firstly, get a iBeacon scanning app from App Store. We will use an app called Locate in this tutorial. Locate has a list of preconfigured proximity UUIDs, which includes an all 0s Null UUID. We will use this Null UUID12. 3.2.1 Setup Advertising Data There are two items in iBeacon advertising packet. Flags Value is fixed to 0x06, i.e. two bits are set, LE General Discoverable Mode &amp; BR/EDR Not Supported. Manufacturer Specific Data The contents of this item is shown in Table 3.1 Table 3.1: iBeacon Manufacturer Specific Data Size in Bytes Name Value Notes 2 Company ID 0x004C Company ID of Apple, Inc 2 Beacon Type 0x1502 Value defined by Apple 16 Proximity UUID User defined value 2 Major Group ID 2 Minor ID within a group 1 Measured Power in dBm Measured by an iPhone 5s at a 1 meter distance In order to make an iBeacon device, we can just follow the same steps as in the Hello World example, with only on exception that we need to configure the advertising package according to the specification. In the advertising data editor, add 0x01 - «Flags» and 0xFF - «Manufacturer Specific Data». Click 0x01 - «Flags», check LE General Discoverable Mode and BR/EDR Not Supported. Click 0xFF - «Manufacturer Specific Data», then the Edit as button, a menu pops up and select iBeacon ... (Figure 3.13) to open iBeacon manufacturer specific data editor (Figure 3.14). Figure 3.13: Edit iBeacon Advertising Data Figure 3.14: Edit iBeacon Manufacturer Specific Data Signal power can be set to any reasonable value (such as -50dBm), and we will calibrate it later with the help of the Locate app. 3.2.2 Try It Let’s select GNU Arm Embedded Toolchain as our development environment on Choose Project Type page, and the wizard will make everything ready (Figure 3.15). Figure 3.15: iBeacon Ready for GNU Arm Toolchain Click on the project to open a console, type make13 to build it. Back to ingWizard, follow the same steps to download it. Now we are able to find our newly created iBeacon in Locate. (Figure 3.16) Figure 3.16: iBeacon in Locate app Tap on our device then we can calibrate signal power or check distance in real-time as shown in Figure 3.17. Figure 3.17: iBeacon Detailed Information in Locate app Once signal power is calibrated, we can right click on our project in ingWizard, and select Edit Data -&gt; Advertising menu item to edit its advertising data with same editor that we are getting familiar with. After advertising data is updated, rebuild the project and check if the distance is more accurate. According to the specification, proximity beacons must use a non connectable undirected advertising PDU, using a fixed 100ms advertising interval. In this tutorial, we are not going to touch the code, so advertising parameters are not touched, either. To make these parameters fully meet the specification, please refer to the corresponding host GAP APIs. 3.3 Thermometer In this tutorial, we are going to make a serious BLE device, a thermometer. Bluetooth SIG has already defined a GATT service called Health Thermometer14. This SDK contains a reference app called INGdemo, which can be deployed to an Android or iOS device. Using INGdemo, we can check Bluetooth devices’ advertising data, and if health thermometer service is found in a device, INGdemo can connect to it and read temperature. In this tutorial, you will learn how to: Broadcast supported services Configure a GATT profile Respond to the read request of a GATT characteristic 3.3.1 Setup Advertising Data Again, we follow the same steps as in the Hello World example, and on the Peripheral Setup page, we declare the thermometer service and create a GATT profile. Add following three items into the advertising data: Flags Value is fixed to 0x06, i.e. two bits are set, LE General Discoverable Mode &amp; BR/EDR Not Supported. Complete List of 16-bit Service Class UUIDs Add one service 0x1809 - Health Thermometer as shown in Figure 3.18. Complete Local Name Let’s name our device as “AccurateOne”. Figure 3.18: Thermometer Advertising Data 3.3.2 Setup GATT Profile Back to the Peripheral Setup page and click Setup ATT database ... to open the GATT profile editor. Add two service, General Access (0x1800) and Health Thermometer (0x1809). Delete all non-mandatory characteristics of General Access service. For Health Thermometer service, keep two characteristics, i.e. temperature measurement and temperature type, and delete the other two. Next, edit each characteristic’s value: Device Name of General Access: Right click on the characteristic, select Edit String Value ... menu, and set the value to “AccurateOne”. Appearance of General Access: Right click on the characteristic, select Help and the editor will open the corresponding document on Bluetooth SIG website. Find the value for general thermometer (0x0300), then click the Edit button and input 0x00, 0x03 into the data field. Temperature Measurement of Health Thermometer Check the document on Bluetooth SIG website. click the Edit button and input five 0s (0, 0, 0, 0, 0) into the data field. Here the first byte contains the flags showing that the following measurement is a FLOAT value in units of Celsius. Check read and dynamic properties (Figure 3.19). FLOAT type is IEEE-11073 32-bit float. Basically, it has a 24-bit mantissa, and an 8-bit exponent (the most significant byte) in base 10. Temperature Type of Health Thermometer Check the document on Bluetooth SIG website. Set it to any valid value by click the Edit button. Figure 3.19: Edit Temperature Measurement 3.3.3 Write the Code After project is created, open profile.c in IDE, and the temperature measurement characteristic handling function att_read_callback is automatically generated by ingWizard. static uint16_t att_read_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t offset, uint8_t * buffer, uint16_t buffer_size) { switch (att_handle) { case HANDLE_TEMPERATURE_MEASUREMENT: if (buffer) { // add your code return buffer_size; } else return 1; // TODO: return required buffer size default: return 0; } } att_read_callback will be called twice or more when app reads a characteristic that has dynamic property: one for querying required buffer size, and one for reading data. If data is large, att_read_callback might be called more times, each reading a part of data specified by offset. As discussed above, define a temperature measurement type: typedef __packed struct gatt_temperature_meas { uint8 flags; sint32 mantissa:24; sint32 exponent:8; } gatt_temperature_meas_t; static gatt_temperature_meas_t temperature_meas = {0}; Now, we can complete the above case HANDLE_TEMPERATURE_MEASUREMENT clause: case HANDLE_TEMPERATURE_MEASUREMENT: if (buffer) { // simulate an &quot;accurate&quot; thermometer temperature_meas.mantissa = rand() % 100; // output data memcpy(buffer, ((uint8 *)&amp;temperature_meas) + offset, buffer_size); return buffer_size; } else return sizeof(gatt_temperature_meas_t); Build &amp; download project, then connect to “AccurateOne” device in INGdemo app. Check if temperature changes randomly each time Refresh button is pressed (Figure 3.20). Figure 3.20: Refresh Temperature Measurement A thermometer (a server) can use notification or indication procedure to notify (without acknowledge) or indicate (with acknowledge) a characteristic value, see [Thermometer with Notification]. In this example, “AccurateOne” does not use these two procedures, and sends its measurement passively. 3.3.4 Notification 3.4 Thermometer with FOTA In this tutorial, we are going to add Firmware Over-The-Air update feature into our thermometer. This SDK provides a FOTA reference design that is workable out-of-the-box. To make FOTA work, at least three parties are involved, a device, an app, and an HTTP server. The INGdemo app is already there, so in this tutorial, we will focus on the device and HTTP server. 3.4.1 Device with FOTA Follow the same steps as in the previous Thermometer example to create a new project, say “ota”. When editing advertising data, we can import data created in previous example by clicking Open File... button of the editor. Advertising data is stored in $(ProjectPath)/data/advertising.adv. Let’s change device’s name to “Clickety Click”. When editing GATT profile database, we can import data created in previous example by clicking Open File... button of the editor. GATT profile data is stored in $(ProjectPath)/data/gatt.profile. Select INGChips Service from the drop-down menu of Add Service button, and add “INGChips FOTA Service”. At present, we are not going to consider security issues, so delete the “FOTA Public Key” characteristics. Next, edit characteristics value of this service: FOTA Version: This identifies the full version number of our project. As shown in flash downloader, a whole project is composed by two binaries, one is from SDK bundle, called platform binary, and the other one is built from our project, called the app binary. FOTA version contains two sub-versions, one for each binary. Each sub-version contains three fields: Major: A 16-bit field. Minor: A 8-bit field. Patch: Another 8-bit field. Each bundle has its own version (so as the platform binary), using the same numbering scheme, which can be found on SDK page of Environment Options dialog (use menu item Tools -&gt; Environment Options to open this dialog). Suppose platform version is 1.0.115, and we would like our app’s version to be 1.0.0, then we set this characteristic’s value to (Fig 3.21): 0x0001, 0, 1 // platform version 0x0001, 0, 0, // app version FOTA Control This is control point during update. Set its value to 0 (i.e. OTA_STATUS_DISABLED), which is the initial status of FOTA. Figure 3.21: Configure FOTA Version Click OK to close GATT profile editor. (Note: do not click Save, unless you want to change the file $(ProjectPath)/data/gatt.profile that is opened in editor.) Back to project wizard, press Next to proceed to the next page Firmare Over-The-Air. On this page, let’s check FOTA. Note that characteristics handles related to FOTA is generated automatically by inspecting the GATT profile. Then finish remaining steps on project wizard. Open our brand-new project “ota”, copy the code from previous example to make our thermometer respond to Refresh in INGdemo app. Next, let’s make a new version. 3.4.2 Make a New Version New version of our “ota” will have a new name “Barba Trick”, and app version number is upgraded to 2.0.0. These data are saved in advertising and profile data respectively, so right click on the project and use editors to update it. After data is updated, use Save As ... to save data to another file in the same directory, for example, update advertising data and save it to $(ProjectPath)/data/advertising_2.adv, and updated profile to $(ProjectPath)/data/gatt_2.profile. Use macro V2 to control the actual advertising and profile data: const static uint8_t adv_data[] = { #ifndef V2 #include &quot;../data/advertising.adv&quot; #else #include &quot;../data/advertising_2.adv&quot; #endif }; ...... const static uint8_t profile_data[] = { #ifndef V2 #include &quot;../data/gatt.profile&quot; #else #include &quot;../data/gatt_2.profile&quot; #endif }; Rebuild the project with macro V2 defined, copy ota.bin and platform.bin (in SDK_DIR/sdk/bundles/typical) to an empty directory, say ota_app_v2. Create a file named manifest.json in ota_app_v2, with follow data in it: { &quot;platform&quot;: { &quot;version&quot;: [1,0,1], &quot;name&quot;: &quot;platform.bin&quot;, &quot;address&quot;: 16384 }, &quot;app&quot;: { &quot;version&quot;: [2,0,0], &quot;name&quot;: &quot;ota.bin&quot;, &quot;address&quot;: 163840 }, &quot;entry&quot;: 16384, &quot;bins&quot;:[] } Those addresses can be found in Environment Options. entry value is fixed to 0x4000, i.e. 16384. Note that json do not accept the popular 0xabcd hexadecimal literals. INGdemo can download additional binaries specified by bins to device. In this case, we don’t have such binaries, so this field is left as an empty array. Then create a readme file for this update with some information about this update in it. Now the FOTA package is ready. Make a ota_app_v2.zip ZIP archive of the whole ota_app_v2 directory. Note that ota_app_v2 should not be made into a sub-directory in ota_app_v2.zip. Table 3.2 summarize the files in the ZIP archive. Table 3.2: FOTA Package Summary File Name Notes readme Some information about this update manifest.json Meta information platform.bin Platform binary ota.bin App binary Back to IDE, rebuild the project leaving macro V2 undefined, then download the project. 3.4.3 FOTA Server INGdemo app needs a FOTA server URL, defined in class Thermometer.FOTA_SERVER. Move ota_app_v2.zip to HTTP server’s document directory, and create a latest.json file, which contains information about latest version. Its content is: { &quot;app&quot;: [2,0,0], &quot;platform&quot;: [1,0,1], &quot;package&quot;: &quot;ota_app_v2.zip&quot; } Make sure that these two files can be accessed through URL (FOTA_SERVER + latest.json) and (FOTA_SERVER + ota_app_v2.zip). 3.4.4 Try It Connect to “Clickety Click” in INGdemo, click Update (Figure 3.22). Since platform.bin is up-to-date, only app.bin need to be updated, the whole update completes in a short time. Return to the main page, scan again and check if our new version works, a device named “Barba Trick” appearing. Connect to “Barba Trick”, firmware is up-to-date now. Figure 3.22: Update Available for “Clickety Click” This tutorial gives an example on FOTA implementation. Users are free to design a new FOTA solution, from version definition to FOTA service and characteristics. It also possible to develop a dedicated secondary app for FOTA. Security must be considered. 3.5 iBeacon Scanner We already know to how to make iBeacon devices. In this tutorial, we are going to create an iBeacon scanner. A scanner plays a central role in Bluetooth pico network. As always, we create a new project named “iscanner” in ingWizard (Fig 3.23). On Role of Your Device page, select Central. A central device almost always scans for something then performs other actions, and our new project wizard automatically adds codes to start scanning. Figure 3.23: “iscanner” Created for IAR Embedded Workbench Open this new project in IDE, and navigate to function user_packet_handler. We can see there is an event called HCI_SUBEVENT_LE_EXTENDED_ADVERTISING_REPORT: case HCI_SUBEVENT_LE_EXTENDED_ADVERTISING_REPORT: { const le_ext_adv_report_t *report = decode_hci_le_meta_event(packet, le_meta_event_ext_adv_report_t)-&gt;reports; // ... } break; Each time this event is received, we can check if the advertising report contains 0xFF - «Manufacturer Specific Data», and if it is an iBeacon packet. With the knowlegde of making an iBeacon device, it is straight forward to define an iBeacon packet type in C. typedef __packed struct ibeacon_adv { uint16_t apple_id; uint16_t id; uint8_t uuid[16]; uint16_t major; uint16_t minor; int8_t ref_power; } ibeacon_adv_t; #define APPLE_COMPANY_ID 0x004C #define IBEACON_ID 0x1502 __packed is an extended keyword to specify a data alignment of 1 for a data type. Fortunately, it is supported by both ARM and IAR compilers. Alternatively, one can use #pragma pack directive: #pragma pack (push, 1) typedef struct ibeacon_adv { ... } ibeacon_adv_t; #pragma pack (pop) Before proceeding, let’s create a helper function that converts an UUID to a string. const char *format_uuid(char *buffer, uint8_t *uuid) { sprintf(buffer, &quot;{%02X%02X%02X%02X-%02X%02X-%02X%02X-&quot; &quot;%02X%02X-%02X%02X%02X%02X%02X%02X}&quot;, uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7], uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]); return buffer; } 3.5.1 Distance Estimation The received signal strength indication (RSSI) is reported together with advertising data. Generally, the intensity of electromagnetic waves radiating from a point source is inversely proportional to the square of the distance from the source. The well known equation for free space loss is: \\[ Loss = 32.45 + 20log(d) + 20log(f) \\] Where \\(d\\) is in km, \\(f\\) in MHz and \\(Loss\\) in dB. By comparing RSSI and measured power at a distance of 1 meter (ref_power), we can grossly estimate the distance between the scanner and beacon using the free space loss equation: double estimate_distance(int8_t ref_power, int8_t rssi) { return pow(10, (ref_power - rssi) / 20.0); } Now, we are able to make a fully functional iBeancon scanner in less than twenty lines: uint8_t length; ibeacon_adv_t *p_ibeacon; char str_buffer[80]; const le_ext_adv_report_t *report; ...... case HCI_SUBEVENT_LE_EXTENDED_ADVERTISING_REPORT: report = decode_hci_le_meta_event(packet, le_meta_event_ext_adv_report_t)-&gt;reports; p_ibeacon = (ibeacon_adv_t *)ad_data_from_type(report-&gt;data_len, (uint8_t *)report-&gt;data, 0xff, &amp;length); if ((length != sizeof(ibeacon_adv_t)) || (p_ibeacon-&gt;apple_id != APPLE_COMPANY_ID) || (p_ibeacon-&gt;id != IBEACON_ID)) break; printf(&quot;%s %04X,%04X, %.1fm\\n&quot;, format_uuid(str_buffer, p_ibeacon-&gt;uuid), p_ibeacon-&gt;major, p_ibeacon-&gt;minor, estimate_distance(p_ibeacon-&gt;ref_power, report-&gt;rssi)); break; Use the Locate app to transmit iBeacon signal, and check if our device can found it (Figure 3.24). Finaly, since RSSI value fluctuates, one can add a low pass filter on RSSI to make the estimation more stable. Figure 3.24: iBeacon Scan Result Note that the size of this app’s binary increases dramatically. This is mainly because that Cortex-M3 don’t have a hardware floating-point unit and floating-point operations are all performed by library functions. Think twice before using floating-point operations. 3.5.2 Concurrent Advertising &amp; Scanning As an exercise, we can merge iBeacon project with this one, and check if our device can send iBeacon signals while keeps scanning for other iBeacon devices. Bluetooth radio uses TDD (Time Division Duplex) topology in which data transmission occur in one direction at one time and data reception occur at another time, and it’s impossible to receive its own iBeacon signal. 3.6 Notification &amp; Indication A server can use notification or indication procedure to notify (without acknowledge) or indicate (with acknowledge) a characteristic’s value. Now, let’s add notification and indication features to our thermometer we have created in a previous tutorial. To notify or indicate a characteristic’s value, we use att_server_notify and att_server_indicate respectively. These APIs must be called within the Bluetooth stack (Host) task. Unsolicited notifications and indication may be triggered by a timer or interrupts, i.e. by sources outside of Bluetooth stack task. To call these Bluetooth stack APIs, inter-task communication mechanism based on RTOS messages is provided. 3.6.1 Inter-task Communication btstack_push_user_msg can be used to send a message into Bluetooth stack stack: uint32_t btstack_push_user_msg(uint32_t msg_id, void *data, const uint16_t len); This message will be passed to your user_packet_handler under event ID BTSTACK_EVENT_USER_MSG: static void user_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) { uint8_t event = hci_event_packet_get_type(packet); btstack_user_msg_t *p_user_msg; if (packet_type != HCI_EVENT_PACKET) return; switch (event) { // ...... case BTSTACK_EVENT_USER_MSG: p_user_msg = hci_event_packet_get_user_msg(packet); user_msg_handler(p_user_msg-&gt;msg_id, p_user_msg-&gt;data, p_user_msg-&gt;len); break; // ...... } } Here, we delegate the handling of the user message to another function user_msg_handler. Note that user_msg_handler is running in the context of Bluetooth stack task, and we are allowed to call those Bluetooth stack APIs now. Event BTSTACK_EVENT_USER_MSG is broadcasted to all HCI event callback functions. 3.6.2 Timer Now let’s make our thermometer “AccurateOne” to update its value once per second. Firstly, create a timer in initialization, such as in app_main or setup_profile. TimerHandle_t app_timer = 0; uint32_t setup_profile(void *data, void *user_data) { app_timer = xTimerCreate(&quot;app&quot;, pdMS_TO_TICKS(1000), pdTRUE, NULL, app_timer_callback); // ... } Timer callback function is defined as: #define USER_MSG_ID_REQUEST_SEND 1 static void app_timer_callback(TimerHandle_t xTimer) { if (temperture_notify_enable | temperture_indicate_enable) btstack_push_user_msg(USER_MSG_ID_REQUEST_SEND, NULL, 0); } This timer is started when we get HCI_SUBEVENT_LE_ENHANCED_CONNECTION_COMPLETE in HCI_EVENT_LE_META, and stopped when we get HCI_EVENT_DISCONNECTION_COMPLETE. Here temperture_notify_enable and temperture_indicate_enable are two flags initialized as 0s and set to 1 in att_write_callback: static int att_write_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size) { switch (att_handle) { case HANDLE_TEMPERATURE_MEASUREMENT + 1: handle_send = connection_handle; switch (*(uint16_t *)buffer) { case GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_INDICATION: temperture_indicate_enable = 1; break; case GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_NOTIFICATION: temperture_notify_enable = 1; break; } return 0; // ... } } Here we store connection_handle to a global variable handle_send which will be used later. The last piece of code is to handle message USER_MSG_ID_REQUEST_SEND in user_msg_handler: static void user_msg_handler(uint32_t msg_id, void *data, uint16_t size) { switch (msg_id) { case USER_MSG_ID_REQUEST_SEND: att_server_request_can_send_now_event(handle_send); break; } } And report temperature in ATT_EVENT_CAN_SEND_NOW: ... case ATT_EVENT_CAN_SEND_NOW: temperature_meas.mantissa = rand() % 100; if (temperture_notify_enable) { att_server_notify(handle_send, HANDLE_TEMPERATURE_MEASUREMENT, (uint8_t*)&amp;temperature_meas, sizeof(temperature_meas)); } if (temperture_indicate_enable) { att_server_indicate(handle_send, HANDLE_TEMPERATURE_MEASUREMENT, (uint8_t*)&amp;temperature_meas, sizeof(temperature_meas)); } break; ... Try to rebuild and download the project, and check if the temperature value shown in INGdemo changes once per second. There is a fully functional thermometer example, a.k.a thermo_ota, supporting FOTA, notification and indication. 3.7 Throughput BLE 5.0 introduces a new uncoded PHY with a sampling rate at 2M. 3.7.1 Theoretical Peak Throughput Maximum payload length is 251 bytes for a Data Physical Channel PDU. Using 2M PHY, it takes 1048 μs to transmit. And an empty Data Physical Channel PDU takes 44 μs to transmit. To achieve maximum throughput on one direction, length of all PDUs on this direction should be 251 bytes, while on the other direction, all PDUs should be empty. So, the transmission of 251 bytes takes a total duration of \\[ 1048 + 44 + 150 * 2 = 1392 (\\mu s) \\] Therefore, the theoretical peak throughput provided by link layer is \\[ 251 * 8 / 1392 * 1000000 \\approx 1442.528 (kbps) \\] For an app working above GATT, I2CAP and ATT all have their own overhead. Typically, GATT has a maximum effective payload of (251 - 7 =) 244 bytes. So, GATT could provide a theoretical peak throughput of \\[ 244 * 8 / 1392 * 1000000 \\approx 1402.298 (kbps) \\] 3.7.2 Test Throughput There are a pair of examples in SDK for throughput testing (Figure \\(\\ref{fig:ch1-tpt}\\)). Figure 3.25: Examples for Throughput Testing 3.7.2.1 Test against INGdemo Download peripheral_throughput. Use INGdemo to connect to ING Tpt, and open throughput testing page. On this page, we can test throughput from master to slave, from slave to master, or on both directions simultaneously. Figure \\(\\ref{fig:ch1-tpt-app}\\) shows that using a common low end Android phone with 2M PHY support, we can achieve a 1M+ bps throughput over the air. Figure 3.26: Througput on an Android Phone 3.7.2.2 Test against Our Own App Example central_throughput demonstrates the typical procedure for a BLE central device: Scan and connect to a device that has throughput service declared in its advertising Discover throughput service; Discover characteristics of the service; Discover descriptors of characteristics. INGChips Throughput Service has two characteristics. Generic Output By this characteristic, peripheral device send data to central device. This characteristic has a Client Characteristic Configuration descriptor. Generic Input By this characteristic, central device send data to peripheral device. Download central_throughput to another board. This app has a UART command line interface to host computer. Connect to a host computer, type “?” to check supported commands. This app connects to peripheral_throughput automatically. Input command start s-&gt;m or start m-&gt;s to start testing throughput from peripheral to central, or from central to peripheral, receptively. Figure 3.27: Command interface Figure \\(\\ref{fig:ch1-board-tpt}\\) shows that using two boards, we have achieved a stable throughout at 1.2M+ bps over the air. Figure 3.28: Througput Between Boards This throughput is tested over the air, a little bit lower than theoretical peak value, but much more practical. 3.8 Dual Role &amp; BLE Gateway In this tutorial, we are going to create a BLE gateway, which collects data from several peripheral devices and reports data to a central device. When collecting data, this gateway is a central device, while reporting data, it is a peripheral device, i.e., our app has two roles. More specifically, our gateway only supports to collect data from thermometers. Let call it a smart_meter. Figure 3.29: Smart Meter Overview smart_meter uses a generic string based output service for report data to a central device, such as the INGdemo running on a smart phone. It also has a UART control interface connecting to a host computer. Checkout the example peripheral_console for how to do string input &amp; output. Full functional smart_meter app is also provided as an example. Take this example as an reference while creating your own. Now, let’s create this BLE gateway. 3.8.1 Use ingWizard to create a peripheral app Use GUI editor to edit advertising data, naming our app as “ING Smart Meter”. Use GUI editor to edit GATT Profile. Add INGChips Console Service into GATT Profile (Figure \\(\\ref{fig:ch1-smart-meter-gatt}\\)). Figure 3.30: Smart Meter GATT Profile 3.8.2 Define Thermometer Data A thermometer is identified by its device address and id. Each thermometer uses its own connection identified by conn_handle. typedef struct slave_info { uint8_t id; bd_addr_t addr; uint16_t conn_handle; gatt_client_service_t service_thermo; gatt_client_characteristic_t temp_char; gatt_client_characteristic_descriptor_t temp_desc; gatt_client_notification_t temp_notify; } slave_info_t; Define four thermometers. 3.8.3 Scan for Thermometers Call two GAP APIs to start scanning. Once a device is found, check whether its device address is one of the thermometers. If so, stop scanning and call gap_ext_create_connection to connect. After connection established, if there is any thermometer not connected, then start scanning again. 3.8.4 Discover Services After connection established, call gatt_client APIs to discover its services. These APIs follow a similar logic like Android, iOS. 3.8.5 Data Handling Subscribe to thermometer’s Temperature Measurement characteristic. When a new measurement is received, convert the value into a string and report it to a host computer. If our app is already connected to a central device, forward this information to it through GATT characteristic. 3.8.6 Robustness To make our app more robust: If disconnected from a thermometer, then start scanning; If disconnected from a central device, then start advertising. 3.8.7 Prepare Thermometers We can use example thermo_ota as thermometers. But we need to configure different address for each one. We can write a simple script for downloader to generate these addresses automatically: procedure OnStartBin(const BatchCounter, BinIndex: Integer; var Data: TBytes; var Abort: Boolean); begin if BinIndex &lt;&gt; 6 then Exit; Data[0] := BatchCounter; end; For further information on downloader scripting, see Scripting &amp; Mass Production. 3.8.8 Test Input command start on host computer to start our app (start scanning &amp; advertising). Use INGdemo to connect to a device named “ING Smart Meter” and check temperature measurements. Turn off and on one or more thermometers, and our app should be able to reconnect to them. 3.9 Hello, Nim To use Nim to develop apps, nim and Gnu Toolchain are both required. Nim compiler translates Nim source code into C source code, then Gnu Toolchain is invoked to compile and link the translated C source code together with SDK, as shown in Figure \\(\\ref{fig:ch1-nim-build}\\). Figure 3.31: Build a Nim App Visual Studio Code is recommended for Nim code editing and building. Let’s make a simple app using Nim. 3.9.1 Create a Nim Project On the Develpment Tool page, Select Nim + Gnu Toolchain. Select By Code for both advertising &amp; ATT database generation (Figure \\(\\ref{fig:ch1-nim-by-code}\\)). Figure 3.32: Use Code to Generate Data ingWizard also support create these data for Nim apps. In this tutorial, we are going to show that it is easy to create these data with meta-programming16 in Nim. 3.9.2 Create Advertising Data Using Nim module btdatabuilder, we can create advertising and GATT profile easily. Example 1: Create a device named “Hello, Nim” let advData = ToArray([Flags({LEGeneralDiscoverableMode, BR_EDR_NotSupported}), LocalName(&quot;Hello, Nim&quot;)]) Example 2: Create an iBeacon let advData = ToArray([Flags({LEGeneralDiscoverableMode, BR_EDR_NotSupported}), iBeacon(&quot;{E9052F1E-9D67-4A6E-B2D7-459D132D6A94}&quot;, 0, 0, -50)]) 3.9.3 Create Profile Data defineProfile([Service(SIG_UUID_SERVICE_GENERIC_ACCESS), Characteristic(SIG_UUID_CHARACT_GAP_DEVICE_NAME, ATT_PROPERTY_READ, &quot;Hello, Nim&quot;), Characteristic(SIG_UUID_CHARACT_GAP_APPEARANCE, ATT_PROPERTY_READ, [0u8, 0]), Service(SIG_UUID_SERVICE_BATTERY_SERVICE), Characteristic(SIG_UUID_CHARACT_BATTERY_LEVEL, ATT_PROPERTY_READ, [20u8], &quot;HANDLE_BATTERY_LEVEL&quot;)], &quot;profileData&quot;) Once above code got compiled, ATT database is stored in profileData, handle of battery level characteristic is identified by a const HANDLE_BATTERY_LEVEL, and the offset (in byte) of battery level value in ATT base (i.e. profileData) is identified by a const HANDLE_BATTERY_LEVEL_OFFSET. We can use these variables and constants generated by macro defineProfile just as normal ones. For example, let’s create a task that updates battery level pseudo randomly: proc updateBatteryLevel(unused: pointer) {.noconv.} = while true: vTaskDelay(pdMS_TO_TICKS(1000)) profileData[HANDLE_BATTERY_LEVEL_OFFSET] = rand_level() ... discard xTaskCreate(updateBatteryLevel, &quot;b&quot;, configMINIMAL_STACK_SIZE, nil, configMAX_PRIORITIES - 1, nil) There are at least three ways to generate pseudo random number in Nim, use PRNG provided by C’s stdlib, use PRNG provided by provided by Nim, or create our own PRNG. Use C’s PRNG # It&#39;s easy to import C functions and use them proc rand(): cint {. importc: &quot;rand&quot;, header: &quot;stdlib.h&quot;.} proc rand_level(): uint8 = cast[uint8](rand() mod 101) Use Nim’s PRNG import random proc rand_level(): uint8 = cast[uint8](rand(0..100)) Create a simple PRNG proc rand_level(): uint8= var last {.global.} = 0u16 last = (last * 173 + 31) and 0x7fffu16 return cast[uint8](last mod 101) As we see, all three ways are easy in Nim. platform_hrng can be used to initialized PRNG. 3.9.4 Benefits of Adopting Nim Nim is as powerful as C because SDK provides bindings of all C APIs for Nim. There are many benefits of adopting Nim, such as it supports meta-programming and it is strongly typed. Meta-programming With metaprogramming, we can create advertising and ATT database at compile time, which has 0 overhead in runtime obviously. Strongly Typed Nim is more strongly typed than C, which can help to make code safer. https://developer.apple.com/ibeacon/↩︎ Note that UUID is not allowed to be all 0s in final products.↩︎ Makefile follows the syntax of GNU make.↩︎ https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.health_thermometer.xml↩︎ Apps can report a different version in FOTA. It is not reqired to be same as in Environment Options.↩︎ https://en.wikipedia.org/wiki/Metaprogramming↩︎ "],["core-tools.html", "Chapter 4 Core Tools 4.1 ingWizard 4.2 Downloader 4.3 ingTracer 4.4 Axf Tool", " Chapter 4 Core Tools SDK core tools play an important role in the BLE device development. 4.1 ingWizard ingWizard is the recommended entry point in the whole development life cycle. With it, we can create &amp; open project, edit project data, and migrate projects, etc. Create Project ingWizard’s new project wizard assists the creation of new projects. We can select favourate IDE, peripheral role, edit advertising and profile data, enable FOTA and logging, etc. Once a project is created, following files are also created, used by ingWizard but not IDE, and they shoule not be deleted, or ingWizard will not to function properly: $(ProjectName).ingw This file shares the same name with the project with an extension .ingw. It contains crucial information about the project and SDK. Without this information, it becomes impossible to do migration. Advertising Data Editor This editor helps us to generate advertising data. It can also be opened from main menu Tools -&gt; Advertising Data Editor .... GATT Profile Editor (or GATT/ATT Database Editor) This editor helps us to build GATT profile data. It can also be opened from main menu Tools -&gt; Profile Database Editor .... This editor supports three type of services, SIG defined services, INGChips defined services and user defined services. To add an user defined service, it must be create beforehandle (see below). Manage Custom Services This editor can be opened from main menu Tools -&gt; Manage Custom GATT Services .... We can add, delete and edit custom services. Custom Services and characteristics are all named with a prefix which is deduced from company name initialized when installing SDK, and updatable through Environment Options. Migration In case a new version of SDK is installed, ROM and RAM used by platform might be changed, so projects settings need to be updated accordingly. This process is automated by right click on a project and select Check &amp; Fix Settings .... Alway remember to backup your project before perform a migration, either by committing all changes into version control system or making a full backup. 4.2 Downloader 4.2.1 Introduction This downloader downloads up-to six images (binaries) to flash through UART connection. It co-operate with bootloader. Bootloader can be made into flash downloading mode either by: Asserting boot pin17 (this is used in the vast majority of cases), Setting entry point which is stored Flash to an invalid address (Only on ING918). When ING918 is powered on, bootloader checks above conditions. If any conditions are true, bootloader sends the handshaking message. When ING916 is made into flash downloading mode, bootloader will check GPIO15: if its level is high, USB port is also enabled. User can download any files, although typically these files are generated by IDE tools. The load address of image (binary) must be aligned at flash erasable unit boundary (EFLASH_ERASABLE_SIZE). ING918: each erasable unit is a page The load address of image (binary) must be aligned at flash page boundary. Each flash page has $\\(8192\\) (0x2000) bytes. Flash starts from 0x4000, so the load address should be 0x4000 + X * 0x2000, where X is an integer. ING918: each erasable unit is a sector The load address of image (binary) must be aligned at flash sector boundary. Each flash sector has \\(4096\\) (0x1000) bytes. Flash starts from 0x02000000, so the load address should be 0x02000000 + X * 0x1000, where X is an integer. Downloader complains if the load address is not correct. Note that when this downloader is started from ingWizard, binaries have already been correctly configured. Click Setup UART ... or Setup Port ... to configure communication port (Figure 4.1). Users need to set Port Number to the value shown in Windows Device Manager, for example, if “COM9” is used, then set Port to COM9, or simply 9. For chips that support downloading through USB, Port can be set to USB to select the default USB device. Baud rate can be set to a value larger than 115200, such as 460800, 921600, etc, to achieve a faster download speed. The maximum supported baud rate is 921600. Due to the limitation of internal flash characters, there isn’t any further significant improvement for baud rate larger than 512000. Other fields should be left unchanged. Figure 4.1: Configurate UART The whole downloading procedure is composed of several steps, such as downloading, verification, set entry address, and launching app. These steps can be configured by clicking Options (Figure 4.2). Figure 4.2: Downloader Options Entry address specifies the entry point of the program. For ING918, if platform binary is used, entry address must be set to 0x4000 which is also the load address of platform binary. For ING916, entry address is ignored if the address is not in the range of RAM. If “Verify Download” is enabled, then data will be read back and compare with origin file to ensure data is correctly downloaded. Data blocks are CRC checked, so “Verify Download” can be kept disabled on a regular basis. If downloading keeps failing on specific address, then we can enable it to double check if flash is malfunctioned. In this case, when mismatch is found, read-back data will be stored to a file. When “Batch” mode is enabled, downloader will keep waiting for bootloader handshaking, and once received handshaking, downloading starts; after downloading completes, downloader will start waiting again. When “Batch” mode is disabled, downloader will no longer wait for handshaking after downloading completes. Click Start to start downloading, or rather start waiting for handshaking. Bootloader sends handshaking message only once, and if chips are already powered up, it may be too late to receive handshaking. In this case, we can click Force to skip handshaking and start downloading immediately. 4.2.2 Scripting &amp; Mass Production This downloader supports powerful scripting, making it suitable for mass production. In the script, two event handlers (functions) are required to be defined. OnStartRun This event handler gets called when each round of downloading starts; OnStartBin This event handler gets called when a binary starts downloading. Here, binary data can be modified on-the-fly before it is written into flash. When “Batch” mode is enabled, this downloader keeps a counter which is increased by 1 after downloading finishes. This counter is shown as Counter.Current shown in Figure 4.2. There is also a variable called Counter.Limit. In “Batch” mode, before a new round of downloading starts, Counter.Current is checked against this limit, if it is larger than limit, “Batch” mode stops automatically. For example, if Counter.Current and Counter.Limit are set to 10 and 13 respectively, then “Batch” mode will run for 4 rounds in total, with Counter.Current equals to 10, 11, 12 and 13. After “Batch” mode stops, Counter.Current equals to 14. The language used for scripting is RemObjects Pascal Script18, which is quite similar to C, and easy to develop. Below is an simple but working example, in which, the batch round number (BatchCounter) is written to a fixed location in the binary. // we can use constants const BD_ADDR_ADDR = $1; // BatchCounter is just Counter.Current procedure OnStartRun(const BatchCounter: Integer; var Abort: Boolean); begin // Use *Print* for logging and debugging Print(&#39;OnStartRun %d&#39;, [BatchCounter]); // we can abort downloading by assigning True to *Abort* // Abort := True; end; procedure OnStartBin(const BatchCounter, BinIndex: Integer; var Data: TBytes; var Abort: Boolean); begin // Note that BinIndex counts from 1 (not 0), just as shown on GUI if BinIndex &lt;&gt; 2 then Exit; // We can modify binary data before it is downloaded into flash Data[BD_ADDR_ADDR + 0] := BatchCounter and $FF; Data[BD_ADDR_ADDR + 1] := (BatchCounter shr 8) and $FF; Data[BD_ADDR_ADDR + 2] := (BatchCounter shr 8) and $FF; end; 4.2.3 Flash Read Protection To protect illegal access of data &amp; program stored in flash, 918xx has a read-protection mechanism. Once read-protection is enabled, JTAG/SW and this downloader can not be able to access flash any more. To re-enable JTAG/SW debugging functionality and downloading, the read-protection must be turned off by a procedure called unlock. Flash data is erased in this procedure. Once the app is ready to ship, and it is decided that data &amp; program must be protected from illegal access, just enable “Read Protection” as shown in Figure 4.2. To download program into a read protected, check Unlock Before Download option. As flash data is erased during unlocking, do not forget to re-download platform binary. All configurations are stored in an ini file. 4.2.4 Python Version SDK also provides a Python version downloader (icsdw.py). It’s open source and easy to be integrated with other tools. This version is written in Python 3. It uses PySerial19 package to access serial port, so run “pip install pyserial” to install the package. Python downloader shares the same ini file with only one exception: Scripting. The GUI downloader stores RemObjects Pascal source code with key named “script” in section “options”, while the python version stores the path to a user module. The path can be a full path or a relative path (relative to the location of the ini file). In the user module, two methods are required to be defined to handle events as in the GUI downloader, on_start_run &amp; on_start_bin. Below is an example, in which, the batch round number (batch_counter) is written to a fixed location in #2 binary. # return abort_flag def on_start_run(batch_counter: int): return False # return abort_flag, new_data def on_start_bin(batch_counter: int, bin_index: int, data: bytes): if bin_index != 2: return False, data ba = bytearray(data) addr = batch_counter.to_bytes(4, &#39;little&#39;) ba[1:5] = addr return False, bytes(ba) 4.3 ingTracer ingTracer is the visual tool for inspecting recorded Trace data introduced in Debugging &amp; Tracing. To limit items drawn on screen, ingTracer breaks trace data into frames. Each frame has a length of 5sec. When a frame is selected, besides the current frame, the previous and the next one are also shown for continuity. Figure 4.3: ingTracer Main UI Graph shows all trace data visually. By clicking an item in Graph, detailed information is decoded and shown in Message Decoder and Message Hex Viewer. Graph supports some of CAD operations, such as zooming, panning, measuring, etc. Checkout menu Help -&gt; About for detailed information. (Figure 4.3) Figure 4.4: MSC Generated by ingTracer To help analyzing app &amp; high layer issues, ingTrace can generate MSC (message sequence chart) for each connection. While Graph emphasizes on timing between events, MSC emphasizes on procedure and fits better for protocol analysis. Message can be decoded by clicking on the [+] mark (Figure 4.4). 4.4 Axf Tool Axf Tool is a command line tool analyzing executables and memory dump, which can be invoked from popup menu on a project in ingWizard. It has several functionalities: stack-usage: Statically analyze stack usage, and report call chains with top N maximum stack depth. bt-api-thread-safety: Audit the usage of Bluetooth API, and check thread confinement. call-stack: Try to recover call stack from memory dump. history: Give a brief history of BLE activities. check-heap: Try to check for errors in heaps. check-task: Runtime check of FreeRTOS tasks with the help of dump. Use axf_tool.exe help {function} to get help on a specific functionality. ING918 has a dedicated boot pin, while ING916 reuses GPIO0.↩︎ https://github.com/remobjects/pascalscript↩︎ https://pypi.org/project/pyserial/↩︎ "],["dive-into-sdk.html", "Chapter 5 Dive Into SDK 5.1 Memory Management 5.2 Multitasking 5.3 Interrupt Management 5.4 Power Management 5.5 CMSIS API 5.6 Debugging &amp; Tracing", " Chapter 5 Dive Into SDK This chapter discusses some important topics that are critical to use SDK efficiently. 5.1 Memory Management There are mainly three type of memory management methods: Statically allocated global variables Dynamically allocated and freed on stack Manually allocated and freed on heap RAM is shared between platform and user applications. When a new project is created by ingWizard, RAM settings is configured properly. Developers are not suggested to modify these settings. 5.1.1 Global Variables This is the recommended way to define variables that have a full lift span in the app. They are allocated in the fixed location and their content can be checked easily in debugger. 5.1.2 Using Stack For variables that are only used within a limited scope, such as a function, we can allocated them on stack. Cares must be taken that size of stack is limited, and it might overflow if too much memory is allocated. The app_main function &amp; interrupts serving routines shares the same global stack with platform’s main function. For RTOS bundles, this stack is defined in platform binaries as 1024 bytes, and can be replaced by a user defined one with the help of platform_install_isr_stack. For “NoOS” bundles, this stack is defined in app binariy as usual. Callback functions registered into Bluetooth stack shares the same task stack with the stack task, whose size is defined as 1024 bytes, and about half is left to be used by app. Developers can create new tasks by calling RTOS APIs. In these cases, stack size should be carefully examined. Use tools to check required stack maximum depth of functions. 5.1.3 Using Heap Generally, heap is not a recommended way for memory management in embedded applications. There are several cons included but not limited to: Space Overhead Some bytes are wasted to store extra information and extra program. Time Overhead It costs cycles to allocate and free memory blocks. Fragmentation Based on these considerations, the heap used by malloc &amp; free has been totally disabled by setting its size to 0. If such heap is TRULY required, it can be re-enabled by changing its size to a proper value when creating projects. Be sure to check follow alternatives before using malloc &amp; free: Use global variables Use memory pool20 This is probably the choice for most cases. Use FreeRTOS’s heap and memory functions, pvPortMalloc &amp; pvPortFree Note that this heap is used by platform &amp; FreeRTOS itself, and it may not have too much free space left for apps. The standard malloc &amp; free can be configured to be overridden and backed by pvPortMalloc &amp; pvPortFree when setting up heap in ingWizard. Once overridden, the allocator from libc is omitted, and malloc &amp; free are implemented by pvPortMalloc &amp; pvPortFree respectively. 5.2 Multitasking It is recommend to have a check on Mastering the FreeRTOS™ Real Time Kernel. Some tips: Do not do too much processing in interrupt handlers, but defer it to tasks as soon as possible Callback functions registered into Bluetooth stack are executed in the context of the stack task, so do not do too much processing in these functions either Use message passing function btstack_push_user_msg or other special functions21 to get synchronized with Bluetooth stack (see Inter-task Communication) 5.3 Interrupt Management To create traditional ISR for interrupts, apps only need to register callback functions through a platform API platform_set_irq_callback. Apps can use following APIs to modify interrupts configuration and states: NVIC_SetPriority Note that the highest allowed priority is configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 2, i.e. that priority parameter must be larger than or equal to this value, indicating a lower or equal priority. NVIC_EnableIRQ NVIC_DisableIRQ NVIC_ClearPendingIRQ etc… 5.4 Power Management In most case, platform manages the power saving feature of ING918xx/ING9186xx SoC automatically and tries the minimize the power consumption in all circumstances, with only one exception, deep sleep. In deep sleep, all components, except those required for power saving control and real-time clocks, are powered down. Some peripherals may be used by apps, and platform does not know how to configure them. So, apps have to get involved in the waking up process after deep sleep. Platform will also check with app if deep sleep is allowed, and fall back to less aggressive power saving modes when deep sleep is not allowed. To use deep sleep, two callback functions are needed, see platform_set_evt_callback. To ease development &amp; debug, power saving can be turned on or off by calling platform_config. Besides the above automatic power management schema, apps can also shutdown the whole system and reboot after a specified duration. In shutdown state the whole system has the least power consumption. See platform_shutdown. In shutdown state, a portion of data can be kept optionally at the cost of a little more power consumption. In case of only a little piece of data needs to be kept, SDK provides a pair of APIs for this, platform_write_persistent_reg and platform_read_persistent_reg. 5.5 CMSIS API SDK tries to encapsulate CMSIS APIs to ease the development. Be careful when calling these APIs in apps as it may affect the platform program. Following operations are strictly forbidden: Changing the vector table offset register Modify configurations of internal interrupts, i.e. those not listed in Table ??. 5.6 Debugging &amp; Tracing Besides online debugging, SDK provides two methods to assist debugging. printf printf is the most convenient way to check program’s behaviour. ingWizard can generate necessary code to use printf. Trace Internal state &amp; HCI messages can be recorded through this trace machenism. ingWizard can generate necessary code to use trace, too. There are several types of trace data, which are predefined and can’t be changed. Which types of trace data are going to be recorded is programmable. Use ingTracer to view the recorded trace data. Table 5.1: Comparison of printf and Trace Debug Option Pros Cons printf Universal slow Trace Binary data, fast Data types are predefined Both printf and trace can be directed to UART ports or SEGGER RTT22. Table 5.2 is a comparison of these two transport options. Table 5.2: Comparison of UART and SEGGER RTT Transport Option Pros Cons UART Universal, easy to use Slower, consume more CPU cycles SEGGER RTT Fast J-Link is required, hard to capture power up log 5.6.1 Tips on SEGGER RTT Use J-LINK RTT Viewer to view printf outputs in real-time. Use J-LINK RTT Logger to record trace outputs to files. This logger will ask for the settings of RTT. Device name is “CORTEX-M3”. Target interface is “SWD”. RTT Control Block address is the address of a variable named _SEGGER_RTT, which can be found in .map file. RTT channel index is 0. Blow is a sample session. ------------------------------------------------------------ Device name. Default: CORTEX-M3 &gt; Target interface. &gt; SWD Interface speed [kHz]. Default: 4000 kHz &gt; RTT Control Block address. Default: auto-detection &gt; 0x2000xxxx RTT Channel name or index. Default: channel 1 &gt; 0 Output file. Default: RTT_&lt;ChannelName&gt;_&lt;Time&gt;.log &gt; ------------------------------------------------------------ Connected to: J-Link ... S/N: ... Searching for RTT Control Block...OK. 1 up-channels found. RTT Channel description: Index: 0 Name: Terminal Size: 500 bytes. Output file: .....log Getting RTT data from target. Press any key to quit. Alternativaly, this tool can be called from command line. Address of_SEGGER_RTT can be specified by a range, and the tool will search for it automatically. For examples, JLinkRTTLogger.exe -If SWD -Device CORTEX-M3 -Speed 4000 -RTTSearchRanges &quot;0x20005000 0x8000&quot; -RTTChannel 0 file_name 5.6.2 Memory Dump We are committed to delivery high quality platform binary. If an assertion or hard fault had occurred in platform binary, it is suggested to create a full memory dump and save all registers. Check out Developers’ Guide for addresses of all memory regions. After a dump is got, use Axf Tool to analyze it. If the problem can not be resolved, contact technical support. Memory can be dumped through debuggers: Keil μVision In debug session, open the Command Window, use save to save each memory region. Take ING918xx as an example: save sysm.hex 0x20000000,0x2000FFFF save share.hex 0x400A0000,0x400AFFFF J-Link Commander Once connected, use regs to shows all current register values, and savebin to save target memory into binary file. Take ING918xx as an example: savebin sysm.bin 0x20000000 0x10000 savebin share.bin 0x400A0000 0x10000 IAR Embedded Workbench In debug session, open a Memory window, and select “Memory Save …” from popup menu. Rowley Crossworks for ARM &amp; SEGGER Embedded Studio for ARM In debug session, open a Memory window, for each memory region: Fill in the start address and size; Use “Memory Save …” from popup menu. GDB (GNU Arm Embedded Toolchain and Nim) In GDB debug session, use dump command to save each memory region. Memory can be also dumped by a piece of specific code. For example, in the event handler of PLATFORM_CB_EVT_ASSERTION, dump all memory data to UART. https://en.wikipedia.org/wiki/Memory_pool↩︎ btstack_push_user_runnable. See Thread Safety in Developer’s Guide for Bluetooth LE.↩︎ https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/↩︎ "],["api-ref.html", "Chapter 6 Platform API Reference 6.1 Configuration &amp; Information 6.2 Events &amp; Interrupts 6.3 Clocks 6.4 RF 6.5 Memory &amp; RTOS 6.6 Time &amp; Timers 6.7 Utilities 6.8 Debugging &amp; Tracing 6.9 Others", " Chapter 6 Platform API Reference This chapter describes the platform API. 6.1 Configuration &amp; Information 6.1.1 platform_config Configure some platform functionalities. 6.1.1.1 Prototype void platform_config(const platform_cfg_item_t item, const uint32_t flag); 6.1.1.2 Parameters const platform_cfg_item_t item Specify the item to be configured. It can be one of following values: PLATFORM_CFG_LOG_HCI: Print host controller interface messages. Default: Disabled. Only available on ING918. HCI logging is only intended for a quick check on BLE behavior. Please consider using tracing (see Debugging &amp; Tracing). PLATFORM_CFG_POWER_SAVING: Power saving. Default: Disabled. PLATFORM_CFG_TRACE_MASK: Bit map of selected trace items. Default: 0. typedef enum { PLATFORM_TRACE_ID_EVENT = 0, PLATFORM_TRACE_ID_HCI_CMD = 1, PLATFORM_TRACE_ID_HCI_EVENT = 2, PLATFORM_TRACE_ID_HCI_ACL = 3, PLATFORM_TRACE_ID_LLCP = 4, //.. } platform_trace_item_t; PLATFORM_CFG_RT_RC_EN: Enable/Disable real-time RC clock. Default: Enabled. PLATFORM_CFG_RT_OSC_EN: Enable/Disable real-time crystal oscillator. Default: Enabled. PLATFORM_CFG_RT_CLK: Real-time clock selection. Flag is platform_rt_clk_src_t. Default: PLATFORM_RT_RC typedef enum { PLATFORM_RT_OSC, // External real-time crystal oscillator PLATFORM_RT_RC // Internal real-time RC clock } platform_rt_clk_src_t; For ING918, When modifying this configuration, both RT_RC and RT_OSC should be enabled and run: * For RT_OSC, wait until status of RT_OSC is OK; * For RT_RC, wait 100μs after enabled. And wait another 100μs before disabling the unused clock. PLATFORM_CFG_RT_CLK_ACC: Configure real-time clock accuracy in ppm. PLATFORM_CFG_RT_CALI_PERIOD: Real-time clock auto-calibration period in seconds. Default: 3600 * 2 (2 hours). PLATFORM_CFG_DEEP_SLEEP_TIME_REDUCTION: Sleep time reduction (deep sleep mode) in micro seconds. ING918 Default: ~550μs. PLATFORM_CFG_SLEEP_TIME_REDUCTION: Sleep time reduction (other sleep mode) in micro seconds. ING918 Default: ~450μs. PLATFORM_CFG_LL_DBG_FLAGS: Link layer flags. Combination of bits in ll_cfg_flag_t. typedef enum { LL_FLAG_DISABLE_CTE_PREPROCESSING = 1, // disable CTE processing LL_FLAG_LEGACY_ONLY_INITIATING = 4, // initiating only using legacy ADV LL_FLAG_LEGACY_ONLY_SCANNING = 8, // scanning only using legacy ADV } ll_cfg_flag_t; PLATFORM_CFG_LL_LEGACY_ADV_INTERVAL: Link layer legacy advertising intervals for high duty cycle (higher 16bits) and normal duty cycle (lower 16bits) in micro seconds. Default for high duty cycle: 1250; default for normal duty cycle: 1500. PLATFORM_CFG_RTOS_ENH_TICK: Enable enhanced ticks for RTOS. Default: Disabled. When enabled, ticks becomes more accurate when peripherals are generating interrupt requests frequently. PLATFORM_CFG_LL_DELAY_COMPENSATION: Delay compensation for Link Layer. When system runs at a lower frequency, more time (in μs) is needed by Link Layer to schedule RF tasks. For example, if ING916 runs at 24MHz, a compensation of ~2500 μs is needed. PLATFORM_CFG_24M_OSC_TUNE: 24M OSC tunning. Not available for ING918. For ING916, tunning value may vary in 0x16~0x2d. PLATFORM_CFG_ALWAYS_CALL_WAKEUP: Always trigger PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP event no matter if deep sleep procedure is completed or aborted (failed). Default for ING918: Disabled for backward compatibility. Default for ING916: Enabled. PLATFORM_CFG_FAST_DEEP_SLEEP_TIME_REDUCTION: Sleep time reduction for fast deep sleep mode in micro seconds. Not available for ING918. This configuration must be less or equal to PLATFORM_CFG_DEEP_SLEEP_TIME_REDUCTION. When equal to PLATFORM_CFG_DEEP_SLEEP_TIME_REDUCTION, fast deep sleep mode is not used. Default for ING916: ~2000μs. PLATFORM_CFG_AUTO_REDUCE_CLOCK_FREQ: Automatically reduce CPU clock frequency in these circumstances: The default IDLE procedure, When entering sleep modes. Not available for ING918. Default for ING916: Enabled. const uint32_t flag To disable or enable an item. It can be one of following values: PLATFORM_CFG_ENABLE PLATFORM_CFG_DISABLE 6.1.1.3 Return Value Void. 6.1.1.4 Remarks Void. 6.1.1.5 Example // On ING918, Enable HCI logging platform_config(PLATFORM_CFG_LOG_HCI, PLATFORM_CFG_ENABLE); 6.1.2 platform_get_version Get version number of platform. 6.1.2.1 Prototype const platform_ver_t *platform_get_version(void); 6.1.2.2 Parameters Void. 6.1.2.3 Return Value Pointer to platform_ver_t. 6.1.2.4 Remarks Platform version number has three parts, major, minor and patch: typedef struct platform_ver { unsigned short major; char minor; char patch; } platform_ver_t; 6.1.2.5 Example const platform_ver_t *ver = platform_get_version(); printf(&quot;Platform version: %d.%d.%d\\n&quot;, ver-&gt;major, ver-&gt;minor, ver-&gt;patch); 6.1.3 platform_read_info Read platform information. 6.1.3.1 Prototype uint32_t platform_read_info(const platform_info_item_t item); 6.1.3.2 Parameters const platform_info_item_t item Information item. PLATFORM_INFO_RT_OSC_STATUS: Read status of real-time crystal oscillator. Value 0: not OK; Non-0: OK. For ING916: this clock become running after selected as real time clock source. PLATFORM_INFO_RT_CLK_CALI_VALUE: Read current real time clock calibration result. PLATFOFM_INFO_IRQ_NUMBER: Get the underline IRQ number of a platform IRQ. For example, get the underline IRQ number of UART0: platform_read_info( PLATFOFM_INFO_IRQ_NUMBER + PLATFORM_CB_IRQ_UART0) 6.1.3.3 Return Value Value of the information item. 6.1.3.4 Remarks Void. 6.1.3.5 Example platform_read_info(PLATFORM_INFO_RT_OSC_STATUS); 6.1.4 platform_switch_app Switch to a secondary app. 6.1.4.1 Prototype void platform_switch_app(const uint32_t app_addr); 6.1.4.2 Parameters const uint32_t app_addr Entry address of the secondary app. 6.1.4.3 Return Value Void. 6.1.4.4 Remarks When calling this function, the code after it will not be executed. 6.1.4.5 Example platform_switch_app(0x80000); 6.2 Events &amp; Interrupts 6.2.1 platform_set_evt_callback_table Register a callback function table for all platform events. 6.2.1.1 Prototype void platform_set_evt_callback_table( const platform_evt_cb_table_t *table); 6.2.1.2 Parameters const platform_evt_cb_table_t *table Address of the callback function table. 6.2.1.3 Return Value Void. 6.2.1.4 Remarks This function shall only be called in app_main. If platform_set_evt_callback is used, this function shall not be used. Comparing to platform_set_evt_callback, use this function can save a block of RAM of sizeof(platform_evt_cb_table_t) bytes. 6.2.1.5 Example static const platform_evt_cb_table_t evt_cb_table = { .callbacks = { [PLATFORM_CB_EVT_HARD_FAULT] = { .f = (f_platform_evt_cb)cb_hard_fault, }, [PLATFORM_CB_EVT_PROFILE_INIT] = { .f = setup_profile, }, // ... } }; int app_main() { // ... platform_set_evt_callback_table(&amp;evt_cb_table); // ... } 6.2.2 platform_set_irq_callback_table Register a callback function table for all platform interrupt requests. 6.2.2.1 Prototype void platform_set_irq_callback_table( const platform_irq_cb_table_t *table); 6.2.2.2 Parameters const platform_irq_cb_table_t *table Address of the callback function table. 6.2.2.3 Return Value Void. 6.2.2.4 Remarks This function shall only be called in app_main. If platform_set_irq_callback is used, this function shall not be used. Comparing to platform_set_irq_callback, use this function can save a block of RAM of sizeof(platform_irq_cb_table_t) bytes. 6.2.2.5 Example static const platform_irq_cb_table_t irq_cb_table = { .callbacks = { [PLATFORM_CB_IRQ_UART0] = { .f = (f_platform_irq_cb)cb_irq_uart, .user_data = APB_UART0 }, // ... } }; int app_main() { // ... platform_set_irq_callback_table(&amp;irq_cb_table); // ... } 6.2.3 platform_set_evt_callback Registers callback functions to platform events. 6.2.3.1 Prototype void platform_set_evt_callback(platform_evt_callback_type_t type, f_platform_evt_cb f, void *user_data); 6.2.3.2 Parameters platform_evt_callback_type_t type Specify the event type to which the callback function is registered. It can be one of following values: PLATFORM_CB_EVT_PUTC: Ouput ASCII character event When platform want to output ASCII characters for logging, this event is fired. Parameter void *data passed into the callback function is casted from char *. ingWizard can automatically generate code that redirects platform log to UART if Print to UART is checked on Common Function when creating a new project. PLATFORM_CB_EVT_PROFILE_INIT: Profile initialization event When host initializes, this event is fired to request app to initialize GATT profile. ingWizard can automatically generate code for this event when creating a new project. PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP: Wakeup from deep sleep event When waking up from deep sleep, this event is fired. During deep sleep, peripheral interfaces (such as UART, I2C, etc) are all powered off. So, when waking up, these interfaces might need to be re-initialized. ingWizard can automatically generate code for event if Deep Sleep is checked on Common Function when creating a new project. Parameter void *data passed into the callback function is casted from platform_wakeup_call_info_t *. RTOS is not resumed yet, some ROTS APIs are not usable; Some platform APIs (such as platform_get_us_time) might be unusable either. PLATFORM_CB_EVT_ON_IDLE_TASK_RESUMED: OS is fully resumed from power saving modes. The callback is invoked after PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP if its reason is PLATFORM_WAKEUP_REASON_NORMAL. For NoOS variants, the callback is invoked by platform_os_idle_resumed_hook(). This event is different with PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP: all OS functionalities are resumed (For NoOS variants, this depends on the proper use of platform_os_idle_resumed_hook()) all platform APIs are functional callback is invoked in the idle task. Parameter void *data is always NULL. PLATFORM_CB_EVT_QUERY_DEEP_SLEEP_ALLOWED: Query if deep sleep is allowed event When platform prepares to enter deep sleep mode, this event is fired to query app if deep sleep is allow at this moment. Callback function can reject deep sleep by returning 0, and allow it by returning a non-0 value. ingWizard can automatically generate code for event if Deep Sleep is checked on Common Function when creating a new project. PLATFORM_CB_EVT_HARD_FAULT: Hard fault occurs When hard fault occurs, this event is fired. Parameter void *data passed into the callback function is casted from hard_fault_info_t *. If this callback is not defined, CPU enters a dead loop when hard fault occurs. PLATFORM_CB_EVT_ASSERTION: Software assertion fails When software assertion fails, this event is fired. Parameter void *data passed into the callback function is casted from assertion_info_t *. If this callback is not defined, CPU enters a dead loop when assertion occurs. PLATFORM_CB_EVT_LLE_INIT: Link layer engine initialized. When link layer engine initialized, this event is fired. PLATFORM_CB_EVT_HEAP_OOM: Out of memory. When allocation on heap fails (heap out of memory), this event is fired. If this event is fired and no callback is defined, CPU enters a dead loop. PLATFORM_CB_EVT_TRACE: Trace output. When a trace item is emitted, this event is fired. Apps can define a callback function for this event to save or log trace output. param to the callback is casted from platform_trace_evt_t * (See Debugging &amp; Tracing). typedef struct { const void *data1; const void *data2; uint16_t len1; uint16_t len2; } platform_evt_trace_t; A trace item is a combination of data1 and data2. Note: len1 or len2 might be 0, but not both; If callback function finds that it can’t output data of size len1 + len2, then, both data1 &amp; data2 should be discarded to avoid trace item corruption. PLATFORM_CB_EVT_EXCEPTION: Hardware exceptions. Parameter void *data is casted from platform_exception_id_t *. PLATFORM_CB_EVT_IDLE_PROC: Customized IDLE procedure. See “Programmer’s Guide - Power Saving”23. PLATFORM_CB_EVT_HCI_RECV: Take over HCI and isolate the built-in Host completely. When defined: HCI events and ACL data are passed to this callback; PLATFORM_CB_EVT_PROFILE_INIT is ignored. Parameter void *data is casted from const platform_hci_recv_t *. See also platform_get_link_layer_interf. f_platform_evt_cb f The callback function registered to event type. f_platform_evt_cb is: typedef uint32_t (*f_platform_evt_cb)(void *data, void *user_data); void *user_data This is passed to callback function’s user_data unchanged. 6.2.3.3 Return Value Void. 6.2.3.4 Remarks It is not required to register callback functions to each event. If no callback function is registered to PLATFORM_CB_EVT_PUTC event, all platform log including platform_printf is discarded. If no callback function is registered to PLATFORM_CB_EVT_PROFILE_INIT event, BLE device’s profile is empty. If no callback function is registered to PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP event, app will not be notified when waking up from deep sleep. If no callback function is registered to PLATFORM_CB_EVT_QUERY_DEEP_SLEEP_ALLOWED event, deep sleep is disabled. 6.2.3.5 Example uint32_t cb_putc(char *c, void *dummy) { // TODO: output char c to UART return 0; } ...... platform_set_evt_callback(PLATFORM_CB_EVT_PUTC, (f_platform_evt_cb)cb_putc, NULL); 6.2.4 platform_set_irq_callback Registers callback functions to interrupt requests. Developers do not need to define IRQ handlers in apps, but use callback functions instead. 6.2.4.1 Prototype void platform_set_irq_callback(platform_irq_callback_type_t type, f_platform_irq_cb f, void *user_data); 6.2.4.2 Parameters platform_irq_callback_type_t type Specify the IRQ type to which the callback function is registered. Values vary for different chip families. Take ING918 as an example: PLATFORM_CB_IRQ_RTC, PLATFORM_CB_IRQ_TIMER0, PLATFORM_CB_IRQ_TIMER1, PLATFORM_CB_IRQ_TIMER2, PLATFORM_CB_IRQ_GPIO, PLATFORM_CB_IRQ_SPI0, PLATFORM_CB_IRQ_SPI1, PLATFORM_CB_IRQ_UART0, PLATFORM_CB_IRQ_UART1, PLATFORM_CB_IRQ_I2C0, PLATFORM_CB_IRQ_I2C1 f_platform_irq_cb f The callback function registered to IRQ type. f_platform_irq_cb is: typedef uint32_t (*f_platform_irq_cb)(void *user_data); void *user_data This is passed to callback function’s user_data unchanged. 6.2.4.3 Return Value Void. 6.2.4.4 Remarks When a callback function is registered to an IRQ, the IRQ is enabled automatically. See also platform_enable_irq. 6.2.4.5 Example uint32_t cb_irq_uart0(void *dummy) { // TODO: add UART0 IRQ handling code return 0; } ...... platform_set_irq_callback( PLATFORM_CB_IRQ_UART0, cb_irq_uart0, NULL); 6.2.5 platform_enable_irq Enable or disable a specified IRQ. 6.2.5.1 Prototype void platform_enable_irq( platform_irq_callback_type_t type, uint8_t flag); 6.2.5.2 Parameters platform_irq_callback_type_t type: The IRQ to be configured. uint8_t flag: Enable (1) or disable (0). 6.2.5.3 Return Value Void. 6.2.5.4 Remarks “Enabling” or “disabling” an interrupt here is from the perspective of CPU. Take UART as an example, UART itself has to be configured to generate interrupts for Rx, Tx, or timeout, which is out of the scope of this function. 6.2.5.5 Example To enable the interrupt request from UART0: platform_enable_irq( PLATFORM_CB_IRQ_UART0, 1); 6.3 Clocks See also “The Real-time Clock”24 in “Programmer’s Guide - Power Saving”25. 6.3.1 platform_calibrate_rt_clk Calibrate real-time clock and get the calibration value. 6.3.1.1 Prototype uint32_t platform_calibrate_rt_clk(void); 6.3.2 platform_rt_rc_auto_tune Automatically tune the internal real-time RC clock, and get the tuning value. For ING918, this function tunes the internal real-time RC clock to 50kHz26. For others, it tunes the internal real-time RC clock to 32768Hz. 6.3.2.1 Prototype uint16_t platform_rt_rc_auto_tune(void); 6.3.2.2 Parameters Void. 6.3.2.3 Return Value The 16-bits tuning value. 6.3.2.4 Remarks This function must be called if the app enables power saving mode, and the real-time RC clock is used as the clock source. This operation costs ~250ms. It is recommended to call this once and store the returned value for later usage. 6.3.2.5 Example // the simplest example: call this function in the // callback function of `PLATFORM_CB_EVT_PROFILE_INIT` // without saving the returned value. uint32_t setup_profile(void *user_data) { platform_rt_rc_auto_tune(); ... } 6.3.3 platform_rt_rc_auto_tune2 Automatically tune the internal real-time RC clock to a specific frequency, and get the tuning value. 6.3.3.1 Prototype uint16_t platform_rt_rc_auto_tune2( uint32_t target_frequency); 6.3.3.2 Parameters uint32_t target_frequency Target frequency in Hertz. 6.3.3.3 Return Value The 16-bits tuning value. 6.3.4 platform_rt_rc_tune Tune internal the real-time RC clock with the tune value. 6.3.4.1 Prototype void platform_rt_rc_tune(uint16_t value); 6.3.4.2 Parameters uint16_t value Value used to tune the clock (returned by platform_rt_rc_auto_tune, or platform_rt_rc_auto_tune2) 6.3.4.3 Return Value Void. 6.3.4.4 Remarks void. 6.3.4.5 Example platform_rt_rc_tune(value); 6.4 RF 6.4.1 platform_set_rf_clk_source Select RF clock source. This function is for internal use. 6.4.2 platform_set_rf_init_data Customize RF initialization data. This function is for internal use. 6.4.3 platform_set_rf_power_mapping Power level is represented by an index internally. There is a power mapping table which lists the actual Tx power level of an index. Take ING918 as an example, power index is in a range of [0..63], and power mapping table is an array of 64 entries, each entry giving the Tx power level in 0.01 dBm. For applications that need better power level control, actual power level can be measured for each index. Update the mapping with this function, then the stack can determine the proper index for a request power level. 6.4.3.1 Prototype void platform_set_rf_power_mapping( const int16_t *rf_power_mapping); 6.4.3.2 Parameters const int16_t *rf_power_mapping The new power mapping table. 6.4.3.3 Return Value Void. 6.4.3.4 Remarks Void. 6.4.3.5 Example static const int16_t power_mapping[] = { -6337, // index 0: -63.37dBm // ... 603 // index 63: 6.03dBm }; platform_set_rf_power_mapping( power_mapping); 6.4.4 platform_patch_rf_init_data Patch part of the internal RF initialization data. This function is for internal use. 6.5 Memory &amp; RTOS 6.5.1 platform_call_on_stack Call a function on a separate dedicated stack. This is useful when a function that uses a lot of stack needs to be called, occasionally. 6.5.1.1 Prototype void platform_call_on_stack( f_platform_function f, void *user_data, void *stack_start, uint32_t stack_size); 6.5.1.2 Parameters f_platform_function f The function to be called. void *user_data User data to be passed to f. void *stack_start Start (lowest) address of the dedicated stack. uint32_t stack_size Size of the dedicated stack in bytes. 6.5.1.3 Return Value Void. 6.5.1.4 Remarks Although stack_size is provided, this function does not protect the stack from overwritten by f. 6.5.2 platform_get_current_task Get the current task from which this API is called. 6.5.2.1 Prototype platform_task_id_t platform_get_current_task(void); 6.5.2.2 Parameters Void. 6.5.2.3 Return Value typedef enum { PLATFORM_TASK_CONTROLLER, PLATFORM_TASK_HOST, PLATFORM_TASK_RTOS_TIMER, } platform_task_id_t; 6.5.2.4 Remarks This API is only available in bundles with built-in RTOS. 6.5.3 platform_get_gen_os_driver Get the generic OS driver. For “NoOS” variants, driver provided by app is returned; for bundles with built-in RTOS, an emulated driver is returned. 6.5.3.1 Prototype const void *platform_get_gen_os_driver(void); 6.5.3.2 Parameters Void. 6.5.3.3 Return Value Return value is casted from const gen_os_driver_t *. Developers can cast the return value back to const gen_os_driver_t * and use API in it. 6.5.3.4 Remarks gen_os_driver_t is an abstract layer over RTOS. Using API in it instead of RTOS API can make apps cross RTOS (independent of underlying RTOS). 6.5.4 platform_get_heap_status Get current heap status, such as available size, etc. 6.5.4.1 Prototype void platform_get_heap_status(platform_heap_status_t *status); 6.5.4.2 Parameters platform_heap_status_t *status Heap status. 6.5.4.3 Return Value Void. 6.5.4.4 Remarks Heap status is defined as: typedef struct { uint32_t bytes_free; // total free bytes uint32_t bytes_minimum_ever_free; // minimum of bytes_free from startup } platform_heap_status_t; 6.5.4.5 Example platform_heap_status_t status; platform_get_heap_status(&amp;status); 6.5.5 platform_get_task_handle Get RTOS handle of a specific platform task. 6.5.5.1 Prototype uintptr_t platform_get_task_handle( platform_task_id_t id); 6.5.5.2 Parameters platform_task_id_t id Platform task ID. 6.5.5.3 Return Value Task handle if such task is known to platform else 0. For example, in the case of “NoOS” variants, platform does not know the handle of PLATFORM_TASK_RTOS_TIMER, so 0 is returned. 6.5.6 platform_install_task_stack Install a new RTOS stack for a specific platform task. Use this to enlarge stack when the default stack size is not enough for internal tasks. For example, user developed RTOS timer callbacks might require a larger stack space. Developers can check RTOS documentation for how to check stack usages. For example, uxTaskGetStackHighWaterMark in FreeRTOS is used to query how close a task has come to overflowing the stack space allocated to it. 6.5.6.1 Prototype void platform_install_task_stack( platform_task_id_t id, void *start, uint32_t size); 6.5.6.2 Parameters platform_task_id_t id Task identifier. void *start Start (lowest) address of the stack. Address shall be properly aligned for underlying CPU. uint32_t size Size of the new stack in bytes. 6.5.6.3 Return Value Void. 6.5.6.4 Remarks This function shall only be called in app_main. For NoOS variants, RTOS stacks can be replaced (modify its size, etc) when implementing the generic OS interface. 6.5.7 platform_install_isr_stack Install a new stack for ISR. 6.5.7.1 Prototype void platform_install_isr_stack(void *top); 6.5.7.2 Parameters void *top Top of the new stack, which must be properly aligned for the underlying CPU. 6.5.7.3 Return Value Void. 6.5.7.4 Remarks In case apps need a much larger stack than the default one in ISR, a new stack can be installed to replace the default one. This function is only allowed to be called in app_main. The new stack is put into use after app_main returns. 6.5.7.5 Example uint32_t new_stack[2048]; ... platform_install_isr_stack(new_stack + sizeof(new_stack) / sizeof(new_stack[0])); 6.6 Time &amp; Timers API for reading current time (timer counter): platform_get_timer_counter platform_get_us_time API for using timers with 625μs resolution: platform_set_abs_timer platform_set_timer platform_delete_timer API for using timer with 1μs resolution: platform_create_us_timer platform_cancel_us_timer Both types of timers can be used with power saving, i.e. it just works as expected when power saving is enabled. A comparison of of these two types of timers is shown in Table 6.1. Table 6.1: Two Types of Platform Timers Type 625μs resolution 1μs resolution Callback Invoked from a task-like context Invoked from an ISR Identifier Callback function pointer Timer handle 6.6.1 platform_cancel_us_timer Cancel a platform timer previously created by platform_create_us_timer. 6.6.1.1 Prototype int platform_cancel_us_timer( platform_us_timer_handle_t timer_handle); 6.6.1.2 Parameters platform_us_timer_handle_t timer_handle Handle of the timer. 6.6.1.3 Return Value This function returns 0 if the specified time is canceled successfully. Otherwise, a non-0 value is returned, which also means the callback function of the timer is executing. 6.6.2 platform_create_us_timer Setup a single-shot platform timer with 1 microsecond (μs) resolution. 6.6.2.1 Prototype platform_us_timer_handle_t platform_create_us_timer( uint64_t abs_time, f_platform_us_timer_callback callback, void *param); 6.6.2.2 Parameters uint64_t abs_time When platform_get_us_timer() == abs_time, the callback is invoked. f_platform_us_timer_callback callback The callback function. The signature is: typedef void * (* f_platform_us_timer_callback)( platform_us_timer_handle_t timer_handle, uint64_t time_us, void *param); Where, timer_handle is the returned value of platform_create_us_timer, i.e. , time_us is current value of platform_get_us_timer when invoking the callback, and param is the user parameter when creating this timer. void *param User parameter. 6.6.2.3 Return Value This function returns a handle of the created timer. A non-NULL value is returned when the timer is successfully created. Otherwise, NULL is returned. 6.6.2.4 Remarks Although abs_time is in microsecond (μs), callback is not guaranteed to be invoked with such resolution. This type of timers are much like platform_set_timer, except that: resolution is higher; callback is invoked in the context of an ISR. DO NOT call platform_create_us_timer again in callback. 6.6.3 platform_delete_timer Delete a previously platform timer created by platform_set_timer or platform_set_abs_timer. 6.6.3.1 Prototype void platform_delete_timer(f_platform_timer_callback callback) 6.6.3.2 Parameters f_platform_timer_callback callback The callback function, which is also an identifier for the timer. 6.6.3.3 Return Value Void. 6.6.3.4 Remarks When calling this function, the callback might already be queued for invoking in the task. Therefore, the callback might still be invoked after this function is called. 6.6.4 platform_get_timer_counter Read the counter of platform timer at 625μs resolution. 6.6.4.1 Prototype uint32_t platform_get_timer_counter(void); 6.6.4.2 Parameters Void. 6.6.4.3 Return Value A full 32 bits value represents current counter, which is roughly platform_get_us_time() / 625. 6.6.5 platform_get_us_time Read the internal time counting from BLE initialization. 6.6.5.1 Prototype int64_t platform_get_us_time(void); 6.6.5.2 Parameters Void. 6.6.5.3 Return Value Value of the internal time counter counting at 1μs. This counter wraps around every ~21.8 years. 6.6.5.4 Remarks This counter restarts after shutdown. 6.6.5.5 Example uint64_t now = platform_get_us_time(); 6.6.6 platform_set_abs_timer Setup a single-shot platform timer triggered at an absolute time with 625μs resolution. 6.6.6.1 Prototype void platform_set_abs_timer( f_platform_timer_callback callback, uint32_t abs_time); 6.6.6.2 Parameters f_platform_timer_callback callback The callback function when the timer expired, and is called in a RTOS task-like27 context, but not an ISR. uint32_t abs_time when platform_get_timer_counter() == abs_time, callback is invoked. If abs_time just passes platform_get_timer_counter(), callback is invoked immediately, for example, abs_time is platform_get_timer_counter() - 1. 6.6.6.3 Return Value Void. 6.6.6.4 Remarks This function always succeeds, except when running out of memory. 6.6.6.5 Example Use this function to emulate a periodic timer. #define PERIOD 100 static uint32_t last_timer = 0; void platform_timer_callback(void) { last_timer += PERIOD; platform_set_abs_timer(platform_timer_callback, last_timer); // do periodic job // ... } last_timer = platform_get_timer_counter() + PERIOD; platform_set_abs_timer(platform_timer_callback, last_timer); 6.6.7 platform_set_timer Setup a single-shot platform timer after a delay from “now” with 625μs resolution. 6.6.7.1 Prototype void platform_set_timer( f_platform_timer_callback callback, uint32_t delay); 6.6.7.2 Parameters f_platform_timer_callback callback The callback function when the timer expired, and is called in a RTOS task-like context, but not an ISR. uint32_t delay Time delay before the timer expires (unit: 625μs). Valid Range: 0~0x7fffffff. When delay is 0, the timer is cleared. 6.6.7.3 Return Value Void. 6.6.7.4 Remarks This function always succeeds, except when running out of memory. platform_set_timer(f, 100) is equivalent to: platform_set_abs_timer(f, platform_get_timer_counter() + 100); platform_set_timer(f, 0) is equivalent to: platform_delete_timer(f); but not platform_set_abs_timer(f, platform_get_timer_counter() + 0); Since callback is also the identifier of the timer, below two lines defines only a timer expiring after 200 units but not two separate timers: platform_set_timer(f, 100); platform_set_timer(f, 200); // update the timer, but not creating a new one If f is used once again in platform_set_abs_timer, then the timer is updated again: platform_set_abs_timer(f, ...); 6.7 Utilities 6.7.1 platform_hrng Generate random bytes by using hardware random-number generator. 6.7.1.1 Prototype void platform_hrng(uint8_t *bytes, const uint32_t len); 6.7.1.2 Parameters uint8_t *bytes Random data output. const uint32_t len Number of random bytes to be generated. 6.7.1.3 Return Value Void. 6.7.1.4 Remarks Time consumption to generate a fix length of data is undetermined. 6.7.1.5 Example uint32_t strong_random; platform_hrng(&amp;strong_random, sizeof(strong_random)); 6.7.2 platform_rand Generate a pseudo random integer by internal PRNG. 6.7.2.1 Prototype int platform_rand(void); 6.7.2.2 Parameters Void. 6.7.2.3 Return Value A pseudo random integer in range of 0 to RAND_MAX. 6.7.2.4 Remarks Seed of the internal PRNG is initialized by HRNG at startup. This function can be used as a replacement of rand() in standard library. 6.7.2.5 Example printf(&quot;rand: %d\\n&quot;, platform_rand()); 6.7.3 platform_read_persistent_reg Read value from the persistent register. See also platform_write_persistent_reg. 6.7.3.1 Prototype uint32_t platform_read_persistent_reg(void); 6.7.3.2 Parameters Void. 6.7.3.3 Return Value The value written by platform_write_persistent_reg. 6.7.3.4 Remarks Void. 6.7.3.5 Example platform_read_persistent_reg(); 6.7.4 platform_reset Reset platform (SoC). 6.7.4.1 Prototype void platform_reset(void); 6.7.4.2 Parameters Void. 6.7.4.3 Return Value Void. 6.7.4.4 Remarks When calling this function, the code after it will not be executed. 6.7.4.5 Example if (out-of-memory) platform_reset(); 6.7.5 platform_shutdown Bring the whole system into shutdown state, and reboot after a specified duration. Optionally, a portion of memory can be retained during shutdown, and apps can continue to use it after reboot. Note that this function will NOT return except that shutdown procedure fails to initiate. Possible causes for failures include: External wake-up signal is issued; Input parameters are not proper; Internal components are busy. 6.7.5.1 Prototype void platform_shutdown(const uint32_t duration_cycles, const void *p_retention_data, const uint32_t data_size); 6.7.5.2 Parameters const uint32_t duration_cycles Duration (measured in cycles of real-time clock) before power on again (reboot). The minimum duration is 825 cycles (about 25.18ms). If 0 is used, the system will stay in shutdown state until external wake-up signal is issued. const void *p_retention_data Pointer to the start of data to be retained. Only data within SYSTEM memory can be retained. This parameter can be set to NULL when data_size is 0. data_size Size of the data to be retained. Set to 0 when memory retention is not needed. 6.7.5.3 Return Value Void. 6.7.5.4 Remarks Void. 6.7.5.5 Example // Shutdown the system and reboot after 1s. platform_shutdown(32768, NULL, 0); 6.7.6 platform_write_persistent_reg Write a value to the persistent register. This value is kept even in power saving, shutdown mode, or when switching to another app. Only a few bits are saved as shown in Table 6.2. Table 6.2: Persistent Register Bit Size Chip Family Register Size (bit) ING918 4 ING916 5 6.7.6.1 Prototype void platform_write_persistent_reg(const uint8_t value); 6.7.6.2 Parameters const uint8_t value The value. 6.7.6.3 Return Value Void. 6.7.6.4 Remarks Void. 6.7.6.5 Example platform_write_persistent_reg(1); 6.8 Debugging &amp; Tracing 6.8.1 platform_printf The printf function stored in platform binary. 6.8.1.1 Prototype void platform_printf(const char *format, ...); 6.8.1.2 Parameters const char *format Format string. ... Variable arguments for format string. 6.8.1.3 Return Value Void. 6.8.1.4 Remarks There are pros &amp; cons to use this function. Pros: This function is located in platform binary, app binary size can be saved. Cons: Output is directed PLATFORM_CB_EVT_PUTC event, so its callback function must be defined. 6.8.1.5 Example platform_printf(&quot;Hello world&quot;); 6.8.2 platform_raise_assertion Raise a software assertion. 6.8.2.1 Prototype void platform_raise_assertion(const char *file_name, int line_no); 6.8.2.2 Parameters const char *file_name File name where the assertion occurred. int line_no Line number where the assertion occurred. 6.8.2.3 Return Value Void. 6.8.2.4 Remarks Void. 6.8.2.5 Example if (NULL == ptr) platform_raise_assertion(__FILE__, __LINE__); 6.8.3 platform_trace_raw Output a block of raw data to TRACE. ID is PLATFORM_TRACE_ID_RAW. 6.8.3.1 Prototype void platform_trace_raw( const void *buffer, const int byte_len); 6.8.3.2 Parameters const void *buffer Pointer of the buffer. const int byte_len Length of data buffer in bytes. 6.9 Others 6.9.1 platform_get_link_layer_interf Get link layer driver API. 6.9.1.1 Prototype const platform_hci_link_layer_interf_t * platform_get_link_layer_interf(void); 6.9.1.2 Parameters Void. 6.9.1.3 Return Value The driver interface platform_hci_link_layer_interf_t *. 6.9.1.4 Remarks This API exposes the Controller HCI interface. This driver interface is only available when PLATFORM_CB_EVT_HCI_RECV is defined, in which case, the built in Host is disabled. 6.9.2 sysSetPublicDeviceAddr Set the public address of device. The public address of a BLE device is a 48-bit extended unique identifier (EUI-48) created in accordance with the IEEE 802-2014 standard28. INGCHIPS 91x DO NOT have public addresses. This function should ONLY be used for debugging or testing, and NEVER be used in final products. 6.9.2.1 Prototype void sysSetPublicDeviceAddr(const unsigned char *addr); 6.9.2.2 Parameters const unsigned char *addr New public address. 6.9.2.3 Return Value Void. 6.9.2.4 Remarks In order to avoid potential issues, this function should be called before calling any GAP functions. It is recommended to call this function in app_main or PLATFORM_CB_EVT_PROFILE_INIT event callback function. 6.9.2.5 Example const unsigned char pub_addr[] = {1,2,3,4,5,6}; sysSetPublicDeviceAddr(pub_addr); https://ingchips.github.io/application-notes/pg_power_saving_en/↩︎ https://ingchips.github.io/application-notes/pg_power_saving_en/ch-api.html#the-real-time-clock↩︎ https://ingchips.github.io/application-notes/pg_power_saving_en/↩︎ Starting from v8.4.6. For elder version, 32768Hz is used.↩︎ It’s called from the Controller task if existing.↩︎ http://standards.ieee.org/findstds/standard/802-2014.html↩︎ "],["revision-history.html", "Chapter 7 Revision History", " Chapter 7 Revision History Version Notes Date 1.0 Initial release 2020-07-28 1.1 Add Python downloader 2020-10-10 1.2 Update API descriptions 2020-07-05 1.2.1 Update memory dump section 2020-08-02 1.2.2 Fix typos, other minor updates 2020-09-08 1.2.3 Fix order of versions in “Device With FOTA” and typo 2020-09-09 1.2.4 Fix outdated information in tutorials 2020-10-20 1.2.5 Update for “NoOS” bundles 2020-11-15 1.2.6 Add ING9168xx 2022-01-10 1.2.7 Minor fixes 2022-07-30 1.2.8 Add btstack_push_user_runnable 2022-10-31 1.2.9 Add information about Axf Tool 2023-10-23 1.3.0 Fix some errors 2024-05-28 1.4.0 Update Platform API 2025-01-20 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
