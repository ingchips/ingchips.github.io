[["index.html", "INGCHIPS SDK 开发者用户手册 1 欢迎", " INGCHIPS SDK 开发者用户手册 v1.2.6 2022-01-10 1 欢迎 欢迎使用 INGCHIPS 918xx/916xx 软件开发工具包 （SDK）. INGCHIPS 918xxx/916xx 是 BLE 5.x 全功能 SoC 解决方案。本手册将带您从软件角度深入了解如何在 918xx/916xx 上进行 BLE 开发。 "],["intro.html", "2 简介 2.1 范围 2.2 架构 2.3 缩略语和术语 2.4 参考资料", " 2 简介 Figure 2.1: SDK Overview INGCHIPS 软件开发工具包包含以下主要组件（图 2.1）: 核心工具 提供项目向导，Flash 下载器及其它功能。这些工具可使 BLE 开发更简单、流畅。 语言和 IDE 集成 支持 Keil μVision1 ， IAR Embedded Workbench2 ， Rowley Crossworks for ARM3 ， SEGGER Embedded Studio for ARM4 。 支持 GNU Arm Embedded Toolchain5 。 核心工具可以自动配置所有这些 IDE、工具链。 支持 Nim6 作为 C 的替代。 对于新工程，可将 Visual Studio Code7 配置为代码编辑器。 对于 Nim and GNU Arm Embedded Toolchain， 编译、下载等任务可以在 Visual Studio Code 里启动。 平台软件包 为不同应用场景提供不同的软件包（比如 typical，extension）。 每个软件包包含完整的协议栈和（可选的） FreeRTOS 可执行二进制文件及对应的 C 头文件。 提供访问芯片外设所需的源代码。 示例 提供丰富的 BLE 设备示例代码，及对应的 Android、iOS 参考代码。 文档 提供用户手册（本文档），API 参考，应用指南等。 2.1 范围 本手册介绍平台软件包架构，核心工具，和平台 API。 2.2 架构 平台软件包分为两种类型，一种内置 FreeRTOS（称为 RTOS 软件包）, 一种不内置 RTOS （称为 “NoOS” 软件包）。 2.2.1 RTOS 软件包 ING918xx/ING916xx 软件架构如图 2.2 所示。 Bootloader 存储于 ROM，不可修改，而平台和应用存储于 Flash。 BLE 协议栈、FreeRTOS 及部分 SoC 功能编译为平台可执行程序。当系统启动时，平台可执行程序首先完成初始化，然后加载主应用。 Figure 2.2: Architecture 辅应用以编程方式告知平台运行。可以下载多个辅应用，编程切换。 芯片复位后，平台又会正常加载主应用。主应用的入口地址由 SDK 工具自动管理，辅应用的入口地址由开发者指定。 2.2.1.1 使用 C 语言开发 App App 的主函数名为 app_main，app 在这个函数里进行初始化： int app_main(void) { ... return 0; } app_main 应该总是返回 0。 平台，BLE 协议栈和 FreeRTOS 的 API 在相应的 C 头文件里声明，包含头文件就可以使用。 2.2.1.2 使用 Nim 语言开发 App App 的主函数名为 appMain，app 在这个函数里进行初始化： proc appMain*(): int {.exportc noconv.} = ... return 0; appMain 应该总是返回 0。 得益于平台和 app 的划分，app 的体积大大减小。这带来很多好处，不限于： 更小、更简洁的 app 代码 更快的下载和 FOTA 专注于功能开发 SDK 为各 IDE 提供了对应的 Flash 烧写算法。App 调试也很方便：使用 Flash 下载工具（4.2）下载平台二进制文件，然后在 IDE 里正常下载、调试 app。 2.2.2 “NoOS” 软件包 当需要使用另外的 RTOS，或者需要使用那些 RTOS 软件包中未提供的功能时，开发者可以选用“NoOS”软件包。 “NoOS”软件包定义了一个通用 RTOS 接口，开发者需要实现这个接口，并通过 app_main 的返回值告知平台。 uintptr_t app_main(void) { ... return (uintptr_t)os_impl_get_driver(); } 2.3 缩略语和术语 Table 2.1: 缩略语 缩略语 解释 ATT Attribute Protocol （属性协议） BLE Bluetooth Low Energy （低功耗蓝牙） FOTA Firmware Over-The-Air （固件空中升级） IRQ Interrupt Request （终端请求） GAP Generic Access Profile （通用存取配置） GATT Generic Attribute Profile （通用属性配置） RAM Random Access Memory （随机存取存储器） ROM Read Only Memory （只读存储器） SDK Software Development Kit （软件开发工具包） Table 2.2: 术语 Terminology Notes Flash Memory 一种电子非易失性计算机存储介质 FreeRTOS 一种实行操作系统内核 2.4 参考资料 Host API Reference Bluetooth SIG8 FreeRTOS9 Mastering the FreeRTOS Real Time Kernel10 https://www.keil.com/ https://www.iar.com/iar-embedded-workbench/ https://www.crossworks.com/index.htm/ https://www.segger.com/products/development-tools/embedded-studio/ https://developer.arm.com/open-source/gnu-toolchain/gnu-rm https://www.nim-lang.org https://code.visualstudio.com https://www.bluetooth.com/ https://freertos.org https://www.freertos.org/Documentation/161204_Mastering_the_FreeRTOS_Real_Time_Kernel-A_Hands-On_Tutorial_Guide.pdf "],["tutorial.html", "3 教程 3.1 世界你好 3.2 iBeacon 3.3 温度计 3.4 FOTA温度计 3.5 iBeacon扫描设备 3.6 通知&amp;指示 3.7 吞吐量 3.8 双角色 &amp; BLE网关 3.9 Hello, Nim", " 3 教程 下面的教程将一步一步地讲解 SDK 里的基本概念，核心工具的使用方法。 3.1 世界你好 在本教程里，我们将创建一个设备，发送的广播里带着它的名字：“Hello, 世界”。 从开始菜单里打开 ingWizard，选择菜单 Project -&gt; New Project ...。 这个菜单项会打开项目向导。向导的第一页是 Development Tool （见图 3.1）。 3.1.1 Development Tool 页面 Figure 3.1: 选择项目类型 在这个页面 （图 3.1）： 选择 IDE/工具链 设置项目名称 选择项目的存储位置 ingWizard 提供以下便利功能： 如果需要用 Git 做软件版本管理，选择 Setup .gitignore； 如果准备使用 Visual Studio Code 作为代码编辑器，选择 Setup Visual Studio Code。 然后点击 Next 按钮进入下一页，Choose Chip Series。 3.1.2 Choose Chip Series 页面 Figure 3.2: Choose Chip Series 在这个页面（图 3.2）选择项目的目标芯片型号，然后点击 Next 进入下一页，Choose Project Type。 3.1.3 Choose Project Type 页面 Figure 3.3: Choose Project Type 在这个页面（图 3.3），选择 Typical。 然后点击 Next 进入下一页，Role of Your Device。 3.1.4 Role of Your Device 页面 Figure 3.4: Role of Your Device 在这个页面 （图 3.4），选择 Peripheral，然后点击 Next 进入下一页，Peripheral Setup。 3.1.5 Peripheral Setup 页面 Figure 3.5: Peripheral Setup 在这个页面（图 3.5），选择 Legacy 广播方式。 支持 BLE 5.x 扩展广播的手机目前依然凤毛麟角，即使声称了“支持” BLE 5.0。为了更好的兼容性，这里我们选择 使用 Legacy 广播。此外，待项目创建之后，通过修改一个比特就能将 Legacy 广播切换成 BLE 5.x 扩展广播。 点击 Setup Advertising Data 按钮， 打开广播数据编辑器（图 3.6）。 在编辑器里，输入 name 可以快速定位到 GAP 广播项 09 - «Complete Local Name»，点击 Add 将这个项添加到设备的广播数据里。 点击刚刚添加的 09 - «Complete Local Name» 数据项， 然后将在下面的数据编辑框里输入 “Hello, 世界” 并按回车。 Data Preview 会更新，整个广播都将已原始字节流的形式显示其中。显而易见，工具对中文字符使用了 UTF-8 编码。 Figure 3.6: Edit Advertising Data 现在点击 OK 回到项目向导，然后点击 Next 进入下一页，Security &amp; Privacy。 3.1.6 Security &amp; Privacy 页面 Figure 3.7: Firmare Over-The-Air 保持默认值（图 3.7），然后点击 Next 进入下一页，Firmare Over-The-Air。 3.1.7 Firmare Over-The-Air 页面 Figure 3.8: Firmare Over-The-Air 保持默认值（图 3.8），然后点击 Next 进入下一页，Common Functions. 3.1.8 Common Functions 页面 Figure 3.9: Common Functions 在这一页（图 3.9），我们依然保持默认值不变，点击 Create。 现在项目创建好了（图 3.10），可以随时编译、下载。 Figure 3.10: “Hello, 世界” is Ready 3.1.9 编译您的项目 回到 ingWizard 的主窗口（图 3.10），点击打开您的项目。在 IDE 里编译您的项目。 3.1.10 下载 回到 ingWizard （图 3.10），右键点击您的项目，从弹出的快捷菜单中选择 Download to Flash 就可以打开下载工具（图 3.11）。 Figure 3.11: Download to Flash 除了串口号，下载工具的所有设置都已就绪。设置串口口，然后点击 Start。 下载完成之后，用 LightBlue、INGdemo （图 3.12）或者其它 app 检查是否可以找到一个名为 “Hello, 世界”的设备。注意，这个设备目前可能无法在系统设置的蓝牙菜单里看到。 Figure 3.12: Hello, 世界 3.2 iBeacon 在本教程中，让我们创建一个iBeacon。iBeacon是由Apple11 开发的协议，并在2013年的苹果全球开发者大会上发布。Beacons是一类低功耗蓝牙(BLE)设备，可以将其标识符广播到附近的便携式电子设备。这项技术使智能手机、平板电脑和其他设备在接近iBeacon设备时能够执行相应的操作。 首先，从app Store下载一个iBeacon扫描应用程序。在本教程中，我们将使用一个名为 Locate 的应用程序。 Locate 有一个预配置的近距离UUID列表，其中包括一个全0 Null UUID。我们将使用这个Null UUID12。 3.2.1 建立广播数据 iBeacon广告包中有两个项目。 Flags 值固定为0x06，即设置了两位，不支持LE General Discoverable Mode &amp; BR/EDR。 Manufacturer Specific Data 本项目内容如表 3.1所示 Table 3.1: iBeacon厂商特定数据 Size in Bytes Name Value Notes 2 Company ID 0x004C Company ID of Apple, Inc 2 Beacon Type 0x1502 Value defined by Apple 16 Proximity UUID User defined value 2 Major Group ID 2 Minor ID within a group 1 Measured Power in dBm Measured by an iPhone 5s at a 1 meter distance 为了制作一个iBeacon设备，我们可以遵循[Hello World]示例中的相同步骤，我们只有在个别情况下需要根据规范配置广播包。 在广播数据编辑器中，添加 0x01 - «Flags» 和 0xFF - «Manufacturer Specific Data» .单击 0x01 - «Flags» ，检查 LE General Discoverable Mode 和 BR/EDR Not Supported 。单击0xFF - «Manufacturer Specific Data» ，然后点击 Edit as 按钮，会有一个菜单弹出并选择 iBeacon ... (Figure 3.13) 来打开iBeacon厂商特定数据编辑器 (Figure 3.14). Figure 3.13: 编辑iBeacon广播数据 Figure 3.14: 编辑iBeacon厂商特定数据 信号功率可以设置为任何合理值(如-50dBm)，稍后我们将在 Locate 应用程序的帮助下对其进行校准。 3.2.2 尝试应用 让我们在 Choose Project Type 页面上选择GNU Arm Embedded Toolchain作为我们的开发环境，向导会让一切准备就绪 (Figure 3.15). Figure 3.15: GNU Arm工具链iBeacon已就绪 单击项目以打开控制台，输入 make13来构建它。回到 ingWizard ，按照相同的步骤将其下载。现在，我们可以在 Locate 中找到新创建的iBeacon设备。 (Figure 3.16) Figure 3.16: iBeacon本地locate APP界面 点击我们的设备，我们就可以实时校准信号功率或检查距离，如图 3.17所示。 Figure 3.17: iBeacon 在locate APP中的详细信息 一旦信号功率校准，我们可以在 ingWizard 中右键单击我们的项目，并选择 Edit Data -&gt; Advertising 菜单项，以用我们所熟悉的编辑器来编辑其广播数据。更新广播数据后，重新构建项目，检查距离是否更准确。 根据规范，接近beacons必须使用一 个不可连接的无定向广播PDU，使用固定的100ms广播间隔。在本教程中，我们不会去修改代码，所以广播参数也不会被修改。为了使这些参数完全符合规范，请参考相应的主机GAP APIs。 3.3 温度计 在本教程中，我们将制作一个 重要 的BLE设备，一个温度计。蓝牙SIG已经定义了一个称为健康温度计的GATT服务14。这个SDK包含一个名为 INGdemo 的参考APP，它可以安装到 Android 或 iOS 设备上。使用 INGdemo ，我们可以查看蓝牙设备的广播数据，如果设备中有健康体温计功能， INGdemo 可以连接设备并读取温度。 在本教程中，您将了解如何: 广播所支持的服务 配置GATT配置文件 响应GATT特性的读请求 3.3.1 建立广播数据 同样，我们遵循与[Hello World]示例中相同的步骤，并在 Peripheral Setup 页面上声明温度计服务并创建GATT配置文件。在广播数据中添加以下三项: Flags 值固定为0x06，即设置了两位，不支持LE General Discoverable Mode &amp; BR/EDR。 Complete List of 16-bit Service Class UUIDs 添加一个如图3.18.所示的 0x1809 - Health Thermometer 服务。 Complete Local Name 让我们将设备命名为“AccurateOne”。 Figure 3.18: 温度计广播数据 3.3.2 建立GATT配置文件 返回 Peripheral Setup 页面，单击 Setup ATT database ... 打开GATT配置编辑器。添加两个服务，General Access (0x1800) 和Health Thermometer (0x1809)。 删除General Access service的所有非必选特性。对于Health Thermometer service保留两个特性，即温度测量和温度类型，删除其他两个。 接下来，编辑每个特性的值: Device Name of General Access: 右键单击特征，选择 Edit String Value ... 菜单，并设置值为“AccurateOne”。 Appearance of General Access: 右键单击特性，选择 Help ，编辑器将在Bluetooth SIG网站上打开相应的文档。找到普通温度计的值(0x0300)，然后单击 Edit 按钮，并在数据字段中输入 0x00, 0x03 。 Temperature Measurement of Health Thermometer 请查看蓝牙SIG网站文档。点击 Edit 按钮并在data字段中输入5个0(0, 0, 0, 0, 0)。这里的第一个字节包含标志，表明之后的度量单位是一个以摄氏度为单位的 FLOAT 值。检查 read 和 dynamic 属性(Figure 3.19)。 FLOAT 类型为IEEE-11073 32位浮点。最基本的是，它有一个24位的尾数和一个8位的指数(最重要的字节)，以 10 为基数。 Temperature Type of Health Thermometer 请查看Bluetooth SIG网站文档。通过单击 Edit 按钮将其设置为任何有效值。 Figure 3.19: 编辑温度测量 3.3.3 代码编写 项目创建完成后，在IDE中打开 profile.c ，由 ingWizard 自动生成温度测量特征处理函数 att_read_callback 。 static uint16_t att_read_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t offset, uint8_t * buffer, uint16_t buffer_size) { switch (att_handle) { case HANDLE_TEMPERATURE_MEASUREMENT: if (buffer) { // add your code return buffer_size; } else return 1; // TODO: return required buffer size default: return 0; } } 当APP读取一个具有 dynamic 特点的特性， att_read_callback 会被调用两次或更多:一次用于查询所需的缓冲区大小， 一次用于读取数据。如果数据很大， att_read_callback 可能会被调用更多次，每次读取由 offset 指定的部分数据。 如上所述，定义一种温度测量类型: typedef __packed struct gatt_temperature_meas { uint8 flags; sint32 mantissa:24; sint32 exponent:8; } gatt_temperature_meas_t; static gatt_temperature_meas_t temperature_meas = {0}; 现在，我们可以完善上面的 case HANDLE_TEMPERATURE_MEASUREMENT 语句: case HANDLE_TEMPERATURE_MEASUREMENT: if (buffer) { // simulate an &quot;accurate&quot; thermometer temperature_meas.mantissa = rand() % 100; // output data memcpy(buffer, ((uint8 *)&amp;temperature_meas) + offset, buffer_size); return buffer_size; } else return sizeof(gatt_temperature_meas_t); 构建并下载项目，然后在 INGdemo app中连接到“AccurateOne”设备。检查每次按下 Refresh 按钮时温度是否随机变化 (Figure 3.20). Figure 3.20: 刷新温度测量 温度计(服务器)可以使用通知或指示过程来通知(不需要确认)或指示(需要确认)一个特征值，参见[带通知的温度计]。在本例中，“AccurateOne”不使用这两个过程，而是被动地发送其测量结果。 3.3.4 通知 3.4 FOTA温度计 在本教程中，我们将在我们的温度计中添加无线固件升级（FOTA）功能。此SDK提供了一个可开箱即用的FOTA设计参考。要使FOTA工作，至少需要涉及三个部分，一个设备、一个APP和一个HTTP服务器。 INGdemo 应用已经有了，所以在本教程中，我们将重点关注设备和HTTP服务器。 3.4.1 FOTA设备 按照与前面温度计示例相同的步骤创建一个新项目，命名为“ota”。 当编辑广告数据时，我们可以通过单击在编辑器中的 Open File… 按钮，来导入在前面例子中创建的数据。广播数据存储在 $(ProjectPath)/data/advertising.adv .让我们将设备命名为“clickty Click”。 当编辑GATT协议数据库时，我们可以通过单击在编辑器中的打开文件 Open File… 按钮来导入在前面例子中创建的数据。GATT协议的数据存储在 $(ProjectPath)/data/gatt.profile .中。在 Add Service 按钮的下拉菜单中选择 INGChips Service ，添加“INGChips FOTA Service”，接下来，编辑该服务的特征值: FOTA Version: FOTA Version确定了我们项目的完整版本号。如flash downloader所示，整个项目由两个二进制文件组成，一个来自SDK 软件包，称为平台二进制文件；另一个来自我们的项目，称为APP二进制文件。FOTA版本包含两个子版本，它们分别对应一个二进制文件。每个子版本包含三个字段: Major: A 16-bit field. Minor: A 8-bit field. Patch: Another 8-bit field. 每个软件包都有自己的版本(同平台二进制文件版本)，使用相同的编号方案，可以在 SDK 页面的 Environment Options 对话框中找到(使用菜单项 Tools -&gt; Environment Options 打开此对话框)。假设平台版本为1.0.1，我们想要的APP版本为1.0.0，那么我们将该特征值设为(Fig 3.21): 0x0001, 0, 1 // platform version 0x0001, 0, 0, // app version FOTA Control 这是升级期间的控制点。将其值设置为 0 (即 OTA_STATUS_DISABLED )，这是FOTA的初始状态。 Figure 3.21: FOTA版本设置 单击 OK 关闭 GATT 协议编辑器。(注意:不要点击 Save ，除非你想改变已经在编辑器中打开的 $(ProjectPath)/data/gatt.profile 。) 回到项目向导，按下 Next 继续下一页的 Firmare Over-The-Air 。在这页上，我们勾选 FOTA 。注意，与FOTA相关的特征句柄是通过检查GATT协议自动生成的。然后在项目向导上完成其余步骤。 打开我们新的项目“ota”，从上一个例子复制代码来使我们的温度计在 INGdemo APP中可以响应 Refresh 。 接下来，让我们制作一个新版本。 3.4.2 创建一个新版本 我们“ota”的新版本命名为“Barba Trick”，APP版本号将升级到 2.0.0 。这些数据分别保存在广播数据和协议数据中，右键单击项目并使用编辑器更新它。数据升级以后，使用 Save As ... 将数据保存在相同路径下的另一个文件中。例如，更新广播数据并将其保存到 $(ProjectPath)/data/advertising_2.adv 。并更新GATT配置文件到 $(ProjectPath)/data/gatt_2.profile 。 用一个宏 V2 来控制实际用到的广播数据和协议数据： const static uint8_t adv_data[] = { #ifndef V2 #include &quot;../data/advertising.adv&quot; #else #include &quot;../data/advertising_2.adv&quot; #endif }; ...... const static uint8_t profile_data[] = { #ifndef V2 #include &quot;../data/gatt.profile&quot; #else #include &quot;../data/gatt_2.profile&quot; #endif }; 用定义的 V2 宏重新编译项目，将 ota.bin 和 platform.bin (在 SDK_DIR/sdk/bundles/typical 中)复制到一个空路径下，如ota_app_v2 。 在 ota_app_v2 创建一个名为 manifest.json 的文件，包含以下数据: { &quot;platform&quot;: { &quot;version&quot;: [1,0,1], &quot;name&quot;: &quot;platform.bin&quot;, &quot;address&quot;: 16384 }, &quot;app&quot;: { &quot;version&quot;: [2,0,0], &quot;name&quot;: &quot;ota.bin&quot;, &quot;address&quot;: 163840 }, &quot;entry&quot;: 16384, &quot;bins&quot;:[] } 这些地址可以在 Environment Options . entry 中找到。地址值固定为 0x4000 ，即 16384 。注意 json 不识别常规的 0xabcd 十六进制文字。 INGdemo 可以下载其他 bin 指定的二进制文件到设备。在本例中，我们没有这样的二进制文件，所以这个字段作为空数组保留。 然后为这个更新创建一个 readme 文件，其中包含一些关于本次更新的信息。 现在FOTA包已经准备好了。为整个 ota_app_v2 路径制作一个 ota_app_v2.zip 的ZIP压缩包。注意，不应该将 ota_app_v2 设置为 ota_app_v2.zip 中的子目录。表 3.2 给出了压缩文件中的文件清单。 Table 3.2: FOTA包文件清单 File Name Notes readme Some information about this update manifest.json Meta information platform.bin Platform binary ota.bin App binary 回到IDE，在没有定义宏 V2 的情况下重新构建项目，然后下载该项目到开发板。 3.4.3 FOTA服务器 INGdemo APP需要一个FOTA服务器URL，定义在 class Thermometer.FOTA_SERVERr 。将 ota_app_v2.zip 移动到HTTP服务器的文档目录，并创建一个 latest.json 文件，它包含最新版本的信息。内容是: { &quot;app&quot;: [2,0,0], &quot;platform&quot;: [1,0,1], &quot;package&quot;: &quot;ota_app_v2.zip&quot; } 确保这两个文件可以通过 (FOTA_SERVER + latest.json) 和 (FOTA_SERVER + ota_app_v2.zip) 访问. 3.4.4 尝试应用 在 INGdemo 中连接“Clickety Click”，点击 Update (Figure 3.22). 由于 platform.bin 是最新的，所以只需要升级 app.bin 就可以了，整个升级过程在很短的时间内完成。回到主页，再次扫描并检查我们的新版本是否起作用，有了一个名为“Barba Trick”的设备。连接到“Barba Trick”，可以看到现在固件是最新的。 Figure 3.22: “Clickety Click”升级可用 本教程给出了一个实现FOTA的例子。用户可以自由设计新的FOTA解决方案，从版本定义到FOTA服务和特性。也可以为FOTA开发一个专用的第二APP。 安全性 是必须要考虑的。 3.5 iBeacon扫描设备 我们已经知道如何配置iBeacon设备。在本教程中，我们将创建一个iBeacon扫描器。 扫描器在蓝牙微距网络中起着核心作用。和之前一样，我们在 ingWizard 中创建一个名为“iscanner”的新项目 (Fig 3.23). 在 Role of Your Device 页面，选择Central。中心设备会一直扫描其他设备然后这些设备执行其相应的动作，我们的新项目向导自动添加代码开始扫描。 Figure 3.23: 创建IAR Embedded Workbench的“iscanner” 在IDE中打开这个新项目，并找到函数 user_packet_handler 。我们可以看到有一个名为 HCI_SUBEVENT_LE_EXTENDED_ADVERTISING_REPORT 的事件: case HCI_SUBEVENT_LE_EXTENDED_ADVERTISING_REPORT: { const le_ext_adv_report_t *report = decode_hci_le_meta_event(packet, le_meta_event_ext_adv_report_t)-&gt;reports; // ... } break; 每次接收到这个事件时，我们可以检查广播报告是否包含 0xFF - «Manufacturer Specific Data»，以及它是否是一个iBeacon包。有了制作iBeacon设备的知识，就可以直接用 C 语言定义一个iBeacon数据包的类型。 typedef __packed struct ibeacon_adv { uint16_t apple_id; uint16_t id; uint8_t uuid[16]; uint16_t major; uint16_t minor; int8_t ref_power; } ibeacon_adv_t; #define APPLE_COMPANY_ID 0x004C #define IBEACON_ID 0x1502 __packed 是一个扩展关键字，用于指定数据类型使用第一种数据对齐方式。幸运的是， ARM 和 IAR 编译器都支持它。或者可以使用 #pragma pack 指令: #pragma pack (push, 1) typedef struct ibeacon_adv { ... } ibeacon_adv_t; #pragma pack (pop) 在继续之前，让我们创建一个将UUID转换为字符串的辅助函数。 const char *format_uuid(char *buffer, uint8_t *uuid) { sprintf(buffer, &quot;{%02X%02X%02X%02X-%02X%02X-%02X%02X-&quot; &quot;%02X%02X-%02X%02X%02X%02X%02X%02X}&quot;, uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7], uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]); return buffer; } 3.5.1 估算距离 接收到的信号强度指示(RSSI)与广播数据一起播报。一般来说，点源辐射出的电磁波强度与信号源距离的平方成反比。著名的自由空间损失方程为: \\[ Loss = 32.45 + 20log(d) + 20log(f) \\] 其中 \\(d\\) 的单位是km, \\(f\\) 的单位是MHz, \\(Loss\\) 的单位是dB。通过比较RSSI和1米距离下的测量功率(ref_power)，我们可以利用自由空间损失方程大致估计出扫描仪和信标之间的距离: double estimate_distance(int8_t ref_power, int8_t rssi) { return pow(10, (ref_power - rssi) / 20.0); } 现在，我们用不到20行代码就可以实现一个功能完整的iBeancon扫描器: uint8_t length; ibeacon_adv_t *p_ibeacon; char str_buffer[80]; const le_ext_adv_report_t *report; ...... case HCI_SUBEVENT_LE_EXTENDED_ADVERTISING_REPORT: report = decode_hci_le_meta_event(packet, le_meta_event_ext_adv_report_t)-&gt;reports; p_ibeacon = (ibeacon_adv_t *)ad_data_from_type(report-&gt;data_len, (uint8_t *)report-&gt;data, 0xff, &amp;length); if ((length != sizeof(ibeacon_adv_t)) || (p_ibeacon-&gt;apple_id != APPLE_COMPANY_ID) || (p_ibeacon-&gt;id != IBEACON_ID)) break; printf(&quot;%s %04X,%04X, %.1fm\\n&quot;, format_uuid(str_buffer, p_ibeacon-&gt;uuid), p_ibeacon-&gt;major, p_ibeacon-&gt;minor, estimate_distance(p_ibeacon-&gt;ref_power, report-&gt;rssi)); break; 使用 Locate 应用程序发送iBeacon信号，并查看我们的设备是否能找到它 (Figure 3.24). 最后，由于RSSI值是波动的，可以在RSSI上增加一个低通滤波器使估算值更加稳定。 Figure 3.24: iBeacon扫描结果 需要注意该APP的二进制文件的大小会急剧增加。这主要是因为Cortex-M3没有硬件浮点单元，浮点操作都是由库函数执行的。使用浮点运算前请 仔细考虑一下 。 3.5.2 并发广播&amp;扫描 作为一个练习，我们可以合并这个iBeacon项目，并检查我们的设备是否可以在发送iBeacon信号的同时继续扫描其他iBeacon设备。 蓝牙无线电采用TDD (Time Division Duplex)拓扑结构，该结构要求同一时刻的数据发送在一个方向上进行，数据接收在另一个方向上进行，设备不能 接收到自己的iBeacon信号。 3.6 通知&amp;指示 服务器可以使用通知或指示过程来通知(不需要确认)或指示(需要确认)一个特征值。现在，让我们将通知和指示功能添加到我们在之前教程中创建的温度计中。 我们分别使用 att_server_notify 和 att_server_indicate 来通知或指示一个特征值。这两个函数只允许在 ATT 模块的 ATT_EVENT_CAN_SEND_NOW 事件中调用，这个事件是由 att_server_request_can_send_now_event 请求的。这些 API 接口必须在蓝牙协议栈 (Host) 任务中调用。 自动获取的通知和指示可以由定时器或中断触发，例如蓝牙任务栈之外的源。提供有一种基于RTOS消息的任务间通信机制来调用这些蓝牙协议栈API接口。 3.6.1 任务间通信 使用 btstack_push_user_msg 发送消息到蓝牙协议栈: uint32_t btstack_push_user_msg(uint32_t msg_id, void *data, const uint16_t len); 这个消息将被传递到你的 user_packet_handler 下的事件ID BTSTACK_EVENT_USER_MSG : static void user_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) { uint8_t event = hci_event_packet_get_type(packet); btstack_user_msg_t *p_user_msg; if (packet_type != HCI_EVENT_PACKET) return; switch (event) { // ...... case BTSTACK_EVENT_USER_MSG: p_user_msg = hci_event_packet_get_user_msg(packet); user_msg_handler(p_user_msg-&gt;msg_id, p_user_msg-&gt;data, p_user_msg-&gt;len); break; // ...... } } 在这里，我们将用户消息的处理传递给另一个叫 user_msg_handler 的函数。注意 user_msg_handler 是在蓝牙协议栈任务的上下文中运行的，现在我们可以调用那些蓝牙栈APIs了。 事件 BTSTACK_EVENT_USER_MSG 被广播到所有 HCI 事件回调函数。 3.6.2 定时器 现在让我们让温度计“AccurateOne”每秒钟更新一次它的值。首先，在初始化时创建一个定时器，例如在 app_main 或 setup_profile 中。 TimerHandle_t app_timer = 0; uint32_t setup_profile(void *data, void *user_data) { app_timer = xTimerCreate(&quot;app&quot;, pdMS_TO_TICKS(1000), pdTRUE, NULL, app_timer_callback); // ... } 定时器回调函数可以被定义为： #define USER_MSG_ID_REQUEST_SEND 1 static void app_timer_callback(TimerHandle_t xTimer) { if (temperture_notify_enable | temperture_indicate_enable) btstack_push_user_msg(USER_MSG_ID_REQUEST_SEND, NULL, 0); } 当我们在 HCI_EVENT_LE_META 中得到 HCI_SUBEVENT_LE_ENHANCED_CONNECTION_COMPLETE 时，定时器开始计时，并在我们得到 HCI_EVENT_DISCONNECTION_COMPLETE 时定时器停止。 这里的 temperture_notify_enable 和 temperture_indicate_enable 是两个初始化为 0s 的标志，并在 att_write_callback 中设置为 1 : static int att_write_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size) { switch (att_handle) { case HANDLE_TEMPERATURE_MEASUREMENT + 1: handle_send = connection_handle; switch (*(uint16_t *)buffer) { case GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_INDICATION: temperture_indicate_enable = 1; break; case GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_NOTIFICATION: temperture_notify_enable = 1; break; } return 0; // ... } } 在这里，我们将 connection_handle 存储到一个全局变量 handle_send ，并在之后会使用该变量。最后一段代码是在 user_msg_handler 中处理消息 USER_MSG_ID_REQUEST_SEND : static void user_msg_handler(uint32_t msg_id, void *data, uint16_t size) { switch (msg_id) { case USER_MSG_ID_REQUEST_SEND: att_server_request_can_send_now_event(handle_send); break; } } 并在 ATT_EVENT_CAN_SEND_NOW中报告温度值： ... case ATT_EVENT_CAN_SEND_NOW: temperature_meas.mantissa = rand() % 100; if (temperture_notify_enable) { att_server_notify(handle_send, HANDLE_TEMPERATURE_MEASUREMENT, (uint8_t*)&amp;temperature_meas, sizeof(temperature_meas)); } if (temperture_indicate_enable) { att_server_indicate(handle_send, HANDLE_TEMPERATURE_MEASUREMENT, (uint8_t*)&amp;temperature_meas, sizeof(temperature_meas)); } break; ... 尝试重新构建并下载项目，并检查 INGdemo 中显示的温度值是否每秒变化一次。 有一个完整功能的温度计示例，即thermoota，它支持FOTA，通知和指示。 3.7 吞吐量 BLE 5.0介绍了一种新的采样率为2M的非编码PHY。 3.7.1 理论峰值吞吐量 数据物理通道PDU的最大有效载荷长度为251字节。采用2M PHY，传输时间为1048 μs。一个空的数据物理通道PDU的传输时间为44 μs。 为了实现一个方向上的最大吞吐量，该方向上所有pdu的长度应该为251字节，而另一个方向上所有pdu的长度应该为空。所以，251个字节总的传输时间为： \\[ 1048 + 44 + 150 * 2 = 1392 (\\mu s) \\] 因此，链路层提供的理论峰值吞吐量为： \\[ 251 * 8 / 1392 * 1000000 \\approx 1442.528 (kbps) \\] 对于一个运行在GATT之上的应用程序，I2CAP和ATT都有它们自己的开销。通常，GATT的最大有效负载为(251 - 7 =)244字节。因此，GATT可以提供的理论上的峰值吞吐量为： \\[ 244 * 8 / 1392 * 1000000 \\approx 1402.298 (kbps) \\] 3.7.2 测试吞吐量 在SDK中有一对用于吞吐量测试的示例 (Figure ). Figure 3.25: 吞吐量测试示例 3.7.2.1 对 INGdemo 进行测试 下载 peripheral_throughput. 使用 INGdemo 连接到 ING Tpt , 打开吞吐量测试页面。在这个页面上，我们可以测试从主到从、从到主或同时在两个方向上的吞吐量。 图中 显示，使用支持2M PHY的普通Android手机，我们可以实现1M+ bps的空中传输吞吐量。 Figure 3.26: Android手机上的吞吐量 3.7.2.2 对我们的APP进行测试 示例 central_throughput 演示了BLE中心设备的一般工作过程: 扫描并连接到在其广播中声明了吞吐量服务的设备; 发现吞吐量服务; 发现服务的特性; 发现特性描述。 INGChips Throughput Service 有两个特点。 通用输出 通过这一特性，外围设备向中心设备发送数据。 这个特性有一个 Client Characteristic Configuration 描述符。 通用输入 通过这个特性，中心设备向外围设备发送数据。 下载 central_throughput 到另一块板。这个应用程序有一个UART命令行接口给到主机。连接到主机，输入“?”以查看所支持的命令。这个APP自动连接到 peripheral_throughput 。输入命令 start s-&gt;m 或 start m-&gt;s 开始测试从外设到中心设备的吞吐量，或从中心设备到外设的。 Figure 3.27: 指令接口 图中 显示，使用两块板，我们在空中实现了1.2M+ bps的稳定数据传输。 Figure 3.28: 板间吞吐量 这个吞吐量是在空中测试的，比理论峰值略低，但真实性更高。 3.8 双角色 &amp; BLE网关 在本教程中，我们将创建一个BLE网关，它从几个外设收集数据并将数据报告给一个中心设备。在收集数据时，这个网关是一个中心设备，而报告数据时，它是一个外设，也就是说，我们的APP能够扮演双角色。 具体而言，我们的网关只支持从温度计收集数据。我们称之为 smart_meter 。 Figure 3.29: Smart Meter架构 smart_meter 使用一个通用型基于字符串的输出服务将数据报告到中心设备，比如运行在智能手机上的 INGdemo 。它还拥有可以连接到主机的UART控制接口。 检查示例 peripheral_console 以了解如何进行字符串输入和输出。 我们同样提供了完整功能的 smart_meter app作为示例。在创建您自己的示例时，请参考此示例。 现在，让我们创建这个BLE网关。 3.8.1 用 ingWizard 创建一个外设APP 使用GUI编辑器编辑广播数据，命名我们的应用程序为“ING Smart Meter”。 使用GUI编辑器编辑GATT配置文件。将 INGChips Console Service 添加到GATT配置文件 (Figure ). Figure 3.30: Smart Meter GATT配置文件 3.8.2 定义温度计数据 温度计由它的设备地址和id来识别。每个温度计使用由 conn_handle 来显示自己的连接状态。 typedef struct slave_info { uint8_t id; bd_addr_t addr; uint16_t conn_handle; gatt_client_service_t service_thermo; gatt_client_characteristic_t temp_char; gatt_client_characteristic_descriptor_t temp_desc; gatt_client_notification_t temp_notify; } slave_info_t; 设定了4个温度计。 3.8.3 扫描温度计 调用两个GAP API接口开始扫描。一旦找到一个设备，会检查它的设备地址是否是温度计。如果是，停止扫描并调用 gap_ext_create_connection 进行连接。 连接建立后，如果有温度计未连接，则重新开始扫描。 3.8.4 发现服务 连接建立后，调用 gatt_client API接口来发现它的服务。 这些API接口遵循类似Android和IOS的逻辑。 3.8.5 数据处理 预定温度计的 Temperature Measurement 特性。当接收到一个新的测量值时，将该值转换为一个字符串并将其报告给主机。如果我们的应用程序已经连接到一个中心设备，通过GATT特性将该信息转发给它。 3.8.6 鲁棒性 为了让我们的应用更稳健: 如果与温度计断开连接，则开始扫描; 如果与中心设备断开连接，则开始广播。 3.8.7 准备温度计 我们可以将示例 thermo_ota 用做温度计。但是我们需要为每一个温度计配置不同的地址。 我们可以写一个简单的脚本为下载程序自动生成这些地址: procedure OnStartBin(const BatchCounter, BinIndex: Integer; var Data: TBytes; var Abort: Boolean); begin if BinIndex &lt;&gt; 6 then Exit; Data[0] := BatchCounter; end; 有关下载脚本的更多信息，请参见 脚本与量产. 3.8.8 测试 在主机上输入 start 命令来启动我们的应用程序(开始扫描并广播)。使用 INGdemo 连接到名为“ING Smart Meter”的设备，检查温度测量结果。 关闭和打开一个或多个温度计，我们的应用程序应该能够重新连接到它们。 3.9 Hello, Nim 要使用 Nim 开发应用程序，需要 Nim 和 Gnu 工具链 。 Nim 编译器将 Nim 源代码翻译成 C 源代码，然后调用 Gnu工具链 将翻译后的 C 源代码与SDK进行编译链接，如图所示。 . Figure 3.31: 建立一个Nim应用程序 推荐使用 Visual Studio Code 编辑和构建 Nim 代码。让我们使用 Nim 制作一个简单的应用程序。 3.9.1 创建一个 Nim APP 在 Develpment Tool 页面，选择 Nim + Gnu Toolchain 。选择 By Code 生成广告和ATT数据库 (Figure ). Figure 3.32: 通过代码生成数据 ingWizard 也支持为 Nim 应用程序创建这些数据。在本教程中，我们将展示轻松地在 Nim 中使用元程序创建这些数据。 3.9.2 创建广播数据 使用 Nim 模块 btdatabuilder ，我们可以轻松创建广播和GATT配置文件。 例1:创建一个名为“Hello, Nim”的设备 let advData = ToArray([Flags({LEGeneralDiscoverableMode, BR_EDR_NotSupported}), LocalName(&quot;Hello, Nim&quot;)]) 例2:创建iBeacon let advData = ToArray([Flags({LEGeneralDiscoverableMode, BR_EDR_NotSupported}), iBeacon(&quot;{E9052F1E-9D67-4A6E-B2D7-459D132D6A94}&quot;, 0, 0, -50)]) 3.9.3 创建配置数据 defineProfile([Service(SIG_UUID_SERVICE_GENERIC_ACCESS), Characteristic(SIG_UUID_CHARACT_GAP_DEVICE_NAME, ATT_PROPERTY_READ, &quot;Hello, Nim&quot;), Characteristic(SIG_UUID_CHARACT_GAP_APPEARANCE, ATT_PROPERTY_READ, [0u8, 0]), Service(SIG_UUID_SERVICE_BATTERY_SERVICE), Characteristic(SIG_UUID_CHARACT_BATTERY_LEVEL, ATT_PROPERTY_READ, [20u8], &quot;HANDLE_BATTERY_LEVEL&quot;)], &quot;profileData&quot;) 上述代码编译完成后，ATT数据库存储在 profileData 中，电池电量特性由常量 HANDLE_BATTERY_LEVEL 标识，电池电量值在ATT基础(即 profileData )中的偏移量(以字节为单位)由常量 HANDLE_BATTERY_LEVEL_OFFSET 标识。 我们可以通过宏 defineProfile 像使用普通变量一样使用这些生成的变量和常量。例如，让我们创建一个任务来随机更新电池电量: proc updateBatteryLevel(unused: pointer) {.noconv.} = while true: vTaskDelay(pdMS_TO_TICKS(1000)) profileData[HANDLE_BATTERY_LEVEL_OFFSET] = rand_level() ... discard xTaskCreate(updateBatteryLevel, &quot;b&quot;, configMINIMAL_STACK_SIZE, nil, configMAX_PRIORITIES - 1, nil) 在 Nim 中至少有三种方法可以生成伪随机数，使用 C 语言stdlib库提供的PRNG，使用 Nim 提供的PRNG，或者创建我们自己的PRNG。 使用 C 的PRNG # It&#39;s easy to import C functions and use them proc rand(): cint {. importc: &quot;rand&quot;, header: &quot;stdlib.h&quot;.} proc rand_level(): uint8 = cast[uint8](rand() mod 101) 使用 Nim 的PRNG import random proc rand_level(): uint8 = cast[uint8](rand(0..100)) 创建一个简易的PRNG proc rand_level(): uint8= var last {.global.} = 0u16 last = (last * 173 + 31) and 0x7fffu16 return cast[uint8](last mod 101) 正如我们所看到的，这三种方法在 Nim 上使用都很简单。 platform_hrng可用于初始化PRNG。 3.9.4 使用 Nim 的好处 Nim 和 C 一样强大，因为SDK为 Nim 提供了所有绑定在 C 语言上的API接口 。采用 Nim 有很多好处，比如它支持元编程，而且是强类型的。 元编程 使用元编程，我们可以在编译时创建广播和ATT数据库，这显然在运行时开销为 0 。 强类型 Nim 比 C 属于更强的类型，这有助于使代码更安全。 https://developer.apple.com/ibeacon/ Note that UUID is not allowed to be all 0s in final products. Makefile follows the syntax of GNU make. https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.health_thermometer.xml "],["core-tools.html", "4 核心工具 4.1 向导 4.2 下载器 4.3 Trace 工具", " 4 核心工具 SDK 核心工具在整个 BLE 开发过程中扮演重要角色。 4.1 向导 向导（ingWizard） 是整个开发周期中的推荐入口。我们用这个工具创建、打开项目，编辑项目数据，迁移项目版本等。 创建项目 ingWizard 的新项目向导辅助我们建立新项目。在向导里，可以选择喜欢的 IDE，蓝牙角色，编辑广播、配置数据， 使能 FOTA、日志，等等。 项目创建后，向导同时会生成以下只供 ingWizard 使用的文件——不要删除这些文件，否则 ingWizard 将无法正常工作： $(ProjectName).ingw 这个文件的文件名与与项目相同，但是扩展名为 .ingw。它包含关于项目和 SDK 的关键信息。 如果没有这些信息，就无法进行版本迁移。 广播数据编辑器（Advertising Data Editor） 这个编辑器帮助我们生成广播数据。它也可用从主菜单 Tools -&gt; Advertising Data Editor ... 打开。 GATT 配置编辑器（GATT Profile Editor 或者 GATT/ATT Database Editor) 这个编辑器帮助我们生成 GATT 配置数据。它也可从主菜单 Tools -&gt; Profile Database Editor ... 打开。 这个编辑器支持三种类型的服务：SIG 定义的服务，INGChips 定义的服务， 以及用户自定义的服务。用户自定义服务需要事先定义（见后文）然后才能添加。 管理自定义服务 这个编辑器可以通过主菜单 Tools -&gt; Manage Custom GATT Services ... 打开。 我们可以添加、删除、编辑自定义服务。 自定义服务和特征的名字都以安装时指定的公司名称作为前辍。公司名称可以通过 Environment Options 修改。 迁移 当更新了 SDK 版本后，platform 占用的 Flash 和 RAM 可能发生变化，项目的设置也就需要相应更新。 这个过程可以通过在项目上点击右键，然后选择 Check &amp; Fix Settings ... 自动完成。 在使用迁移功能之前 务必 先对项目做备份：将项目提交到版本管理系统或者直接备份所有文件。 4.2 下载器 4.2.1 介绍 下载器可以将最多 6 个映像文件（二进制文件）通过 UART 烧录到芯片。 它需要芯片内的引导程序（Bootloader）的配合。Bootloader 可以通过以下途径进入 Flash 下载状态： 使能 Boot 引脚（这是最常用的情况），或者 将 Flash 里的入口地址设为非法值（仅适用于 ING918xx）。 当芯片上电时，Bootloader 会检查上述各个条件，只要有一条满足，就会进入下载状态，并发送握手信息。 用户可以下载任意文件，尽管典型情况下，这些文件都是由 IDE 工具生成。 程序映像文件的加载地址必须与 Flash 烧写单位对齐： 对于 ING918xx，烧写单位为页 映像文件的加载地址必须与页边界对齐。每页 \\(8192\\) (0x2000) 字节。Flash 起始地址为 0x4000， 所以加载地址应该满足 0x4000 + X * 0x2000, 这里 X 为自然数。 对于 ING916xx，烧写单位为扇区 映像文件的加载地址必须与扇区边界对齐。每个扇区 \\(4096\\) (0x1000) 字节。Flash 起始地址为 0x02000000， 所以加载地址应该满足 0x02000000 + X * 0x1000, 这里 X 为自然数。 如果加载地址有误，下载器会报告错误信息。 说明：当从 ingWizard 里启动下载器时，地址应该都已正确配置。 点击 Setup UART ... 配置 UART 参数（图 4.1）。 用户需要将 Port Number 设置成 Windows 设备管理器显示的串口号，例如，如果使用 “COM9” 就将 Port Number 设置为 COM9，或者直接写 9。 波特率可以设置成比默认值 115200 更大的数值，比如 256000、512000、750000、921600 等， 来获得更高的下载速率。 工具支持的最高波特率为 921600。受限于内部 Flash 的自身特性， 将波特率设为比 512000 更高的数值并不会带来下载速率的进一步提升。其它 UART 参数保持不变。 Figure 4.1: Configurate UART 整个下载过程包含多个步骤：下载、验证、设置启动地址、启动程序。这些步骤可通过点击 Options 进行设置（图 4.2）。 对于 ING918xx，启动地址（入口地址） 0x4000 等于 platform 的加载地址。 Figure 4.2: Downloader Options 如果启用了 “Verify Download” 功能， 数据下载之后会从 Flash 回读并与原始数据对比以验证下载是否正确。由于下载时数据已经过 CRC 验证，一般情况下， “Verify Download” 并不需要启用。 如果在特定位置持续出现下载错误，那么我们可用启用验证功能以便检查 Flash 是否出现异常。当验证失败时， 下载器会把回读的数据保存到文件里以便进一步分析。 当启用了批量（“Batch”）模式时，下载器会持续等待 Bootloader 的握手信号， 一旦收到握手信号就会开始下载；下载完成后，下载器再次进入等待状态。如果未启用 “Batch” 模式， 下载完成后下载器就不会再次等待握手信号。 点击 Start 开始下载，更确切地说是开始等待握手信号。Bootloader 只发送一次握手信号， 如果芯片已经上电，Bootloader 已经发送过了握手信号，这种情况下，我们可以点击 Force 跳过等待过程，直接开始下载。 4.2.2 脚本与量产 下载器支持脚本，可以应用于量产。在下载脚本里可以捕捉到两个事件： OnStartRun 这个事件处理函数在每轮下载开始时都会调用； OnStartBin 这个事件处理函数在每个二进制文件开始下载时都会调用。在这个函数里，可以即时修改待下载的数据。 当启用了 “Batch” 时，下载器会维护一个计数器，每次下载完成，该计数器加 1。这个计数器即图 4.2 中的 Counter.Current。还有一个名为 Counter.Limit 的变量： 在 “Batch” 模式下，当要开始新的一轮下载时，会检查 Counter.Current， 如果超过了限制，“Batch” 模式自动停止。 例如 Counter.Current 和 Counter.Limit 分别为 10 和 13，那么 “Batch” 模式将一共执行 4 轮 下载，每一轮的 Counter.Current 等于 10、11、12 和 13。“Batch” 停止后， Counter.Current 等于 14. 下载器使用的脚本语言为 RemObjects Pascal Script15， 与 C 比较类似，易于开发。下面是一个简单但是实用的例子，把下载计数器写入二进制文件的固定位置： // 我们可以使用常数 const BD_ADDR_ADDR = $1; // BatchCounter 就是 Counter.Current procedure OnStartRun(const BatchCounter: Integer; var Abort: Boolean); begin // 使用 Print 输出日志、调试信息 Print(&#39;OnStartRun %d&#39;, [BatchCounter]); // 把 Abort 赋值为 True 可以中止下载 // Abort := True; end; procedure OnStartBin(const BatchCounter, BinIndex: Integer; var Data: TBytes; var Abort: Boolean); begin // 注意 BinIndex 从 1 开始计数（而不是 0），与图形界面一致 if BinIndex &lt;&gt; 2 then Exit; // 我们在数据下载到 Flash 之前修改它 Data[BD_ADDR_ADDR + 0] := BatchCounter and $FF; Data[BD_ADDR_ADDR + 1] := (BatchCounter shr 8) and $FF; Data[BD_ADDR_ADDR + 2] := (BatchCounter shr 8) and $FF; end; 4.2.3 Flash 读保护（适用于 ING918xx） 为防止对 Flash 内的数据和程序的非法访问，918xx 设计了一种读保护机制。 读保护一旦启用，JTAG/SWD 就下载器都无法访问 Flash。 要使芯片重新启用 JTAG/SWD 调试、下载功能，需要一个经过 解锁 过程。解锁 时， Flash 里的数据被全部擦除。 当 app 已准备就绪，并且认为需要保护 Flash 里的数据和程序不被非法访问，可如图 4.2 所示启用读保护（“Read Protection”）功能。 启用 Unlock Before Download 选项可以为已经启用了读保护的设备重新下载程序。由于 解锁 时，Flash 里的数据被全部擦除，不要忘记重新下载 platform。 所有的配置参数都保存在一个 ini 文件内。 4.2.4 Python 版本 SDK 同时提供了一个 Python 版本的下载器（icsdw.py）。它是开源的，可以与其它工具集成。 本工具是用 Python 3 开发，使用 PySerial16 包访问串口。 这个包可以通过运行命令 “pip install pyserial” 安装。 Python 版下载器与图形界面版（GUI）下载器使用相同的 ini 文件，只有一处例外：脚本。 GUI 版工具将 RemObjects Pascal 保存在 “options” 里 “script” 域，而 Python 版在 这个域里保存的是一个用户模块的路径。这个路径可以是绝对路径，也可以是相对路径（相对于 ini 文件）。 在用户模块里，与 GUI 版本类似，可以定义两个事件回调函数， on_start_run 和 on_start_bin。下面的例子演示了如何将批量计数器写入第 2 号二进制文件的固定地址： # 返回 abort_flag def on_start_run(batch_counter: int): return False # 返回 abort_flag, new_data def on_start_bin(batch_counter: int, bin_index: int, data: bytes): if bin_index != 2: return False, data ba = bytearray(data) addr = batch_counter.to_bytes(4, &#39;little&#39;) ba[1:5] = addr return False, bytes(ba) 4.3 Trace 工具 Trace 工具（ingTracer）是 调试与跟踪 里提到的 Trace 数据的可视化工具. 为了限制屏幕上的数据，ingTracer 将数据划分为若干帧。每一帧的长度为 5 秒。 为了使呈现的数据更具有连续性，当选择了一帧时，除了当前帧， 其前后各一帧也会显示出来。 Figure 4.3: ingTracer 主界面 Graph 将所有数据图形化显示。点击 Graph 里的一项， 会在 Message Decoder 和 Message Hex Viewer 显示详细的解码信息。Graph 支持一些 CAD 操作， 如缩放、平移、测量等。选择菜单 Help -&gt; About 查看详细信息。 （图 4.3） Figure 4.4: MSC Generated by ingTracer 为辅助分析 app 及高层协议栈问题，ingTrace 可为每一个连接生成 MSC （消息序列图）。 Graph 窗口侧重事件之间的定时关系，而 MSC 则侧重流程，更便于分析协议层面的问题。点击 MSC 里的 [+] 可以解码消息 （图 4.4）。 https://github.com/remobjects/pascalscript https://pypi.org/project/pyserial/ "],["dive-into-sdk.html", "5 深入 SDK 5.1 内存管理 5.2 多任务 5.3 中断管理 5.4 功耗管理（适用于 ING918xx） 5.5 CMSIS API 5.6 调试与跟踪", " 5 深入 SDK 本章介绍关于高效使用 SDK 的一些关键问题。 5.1 内存管理 有以下三种主要的内存管理方法： 全局的静态分配 在栈上的动态分配和释放 在堆上的动态分配和释放 RAM 由 platform 和 app 共享使用。ingWizard 创建的新项目 RAM 的位置、大小会自动得以配置。不建议开发者修改此设置。 5.1.1 全局分配 对于在 app 整个生命周期都存在的变量，这是推荐的分配方式。全局变量地址固定，用调试器可以方便地检查其中的数据。 5.1.2 使用栈 对于仅在有限范围内——比如一个函数内部——存在的变量，我们可以在栈上分配它们。 必须注意：栈的大小是有限的，如果分配的空间过多，栈会溢出。 app_main 函数及中断服务程序与 platform 的 main 使用同一个全局栈。 对于 RTOS 软件包，这个栈由 platform 定义，其大小为 1024 字节。如果大小不合适，可利用 platform_install_isr_stack 做替换。 对于 “NoOS” 软件包，这个栈由 app 定义。 蓝牙协议栈的各种回调函数与协议栈使用同一个栈，其大小为 1024 字节，一般情况下， 进入回调函数时大致还有一半空间空闲。 开发者可以创建新的 RTOS 任务。这时，栈的大小需要仔细核对。 用工具检查函数所需要的最大栈空间（栈的深度）。 5.1.3 使用堆 总体而言，不太建议在嵌入式应用里使用堆管理内存。这种方法至少存在以下不足： 空间开销 对于每块空间，为了存储额外的信息，若干字节被浪费。 时间开销 分配、释放内存块时需要消耗时间。 碎片 基于以上考虑，ingWizard 创建项目时在默认情况下，堆大小设置为 0，完全禁用了 malloc 和 free。 如果确实需要使用堆，可以在创建项目时，把堆大小修改为合适的数值。 在使用 malloc 和 free 之前，请查看以下建议： 使用全局变量 使用内存池17 这可能是一种适用于多数场景的方案。 使用 RTOS 的堆内存接口，如 pvPortMalloc 和 pvPortFree 注意，这个堆由 platform 和 FreeRTOS 共用，留给 app 的空间可能不多。标准的 malloc &amp; free 在 ingWizard 的堆设置里可配置为由 pvPortMalloc &amp; pvPortFree 实现，此时，libc 里的堆分配器不会链接到程序里， malloc &amp; free 完全依赖 pvPortMalloc &amp; pvPortFree 实现。 5.2 多任务 建议先阅读《Mastering the FreeRTOS Real Time Kernel》。 几点建议： 不要在中断服务程序里做过多处理，应该尽快延续到任务里， 蓝牙协议栈的回调函数在协议栈任务的上下文里运行，所以也不要做过多处理， 调用蓝牙协议栈 API （除了 btstack_push_user_msg 本身）之前先利用消息传递函数 btstack_push_user_msg 与协议栈同步（参见 任务间通信） 5.3 中断管理 Apps 通过 platform API platform_set_irq_callback 创建经典的中断服务程序。 Apps 可以使用下列 API 修改中断配置或者状态： NVIC_SetPriority 注意，对于 RTOS 软件包，中断优先级最高为 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 2， 也就是说，优先级参数必须大于或者等于该值，以表示 更低 或者 相等 的优先级。 NVIC_EnableIRQ NVIC_DisableIRQ NVIC_ClearPendingIRQ 等等…… 5.4 功耗管理（适用于 ING918xx） 在大多数情况下，platform 负责自动管理系统的省电功能，尽量降低功能。只有一个例外， 深睡眠。 在深睡眠模式下，芯片内除低功耗管理及 RTC 时钟以外的所有部件都会掉电或者进入其它最省电状态。 由于 platform 无法知晓 app 用到了哪些外设、如何配置这些外设， 所以，app 需要参与从深睡眠退出时的唤醒流程。 Platform 会询问 app 当前是否允许进入深睡眠，如果不允许，则进入其它相对不激进的省电模式。 为了使用深睡眠，需要定义两个回调函数，参见 platform_set_evt_callback。 为了方便开发和调试，提供 platform_config API 控制是否开启省电功能。 除了上面的自动省电机制，app 还可以主动将整个芯片系统关闭一段时间然后重启。关闭状态下芯片功耗降至最低， 在关闭状态下，可以维持一段内存里的数据不丢失，代价是需要增加一点功耗。参见 platform_shutdown。如果仅有很少量的数据需要保持： 对于 ING918xx 系列 如果不多于 4 个比特，SDK 提供了一对 API 可供使用platform_write_persistent_reg 和 platform_read_persistent_reg。 5.5 CMSIS API SDK 尝试对一些 CMSIS API 做了封装以便开发。当直接使用 CMSIS API 时务必小心，因为可能会影响系统的运行。 以下操作严格禁止： 修改中断向量表相关的寄存器 修改表 6.1 和表 6.2 中未列出的中断的配置 5.6 调试与跟踪 除了在线调试外，SDK 提供以下两种辅助调试的方法： printf printf 是检查程序行为最方便的方法。ingWizard 能够为 printf 生成支撑代码. 跟踪（Trace） 内部状态和 HCI 接口消息可通过 Trace 记录下来。ingWizard 也能够为 Trace 生成支撑代码。Trace 包含几种预先定义的数据类型，可以编程选择记录哪些数据类型。使用 ingTracer 查看 Trace 数据。 Table 5.1: printf 和 Trace 的对比 方法 优点 缺点 printf 通用 慢 Trace 二进制数据，速度快 数据类型为预先定义 printf 和 trace 都可以配置成从 UART 口或者 SEGGER RTT18 输出。 表 5.2 对比了两种传输方式。 Table 5.2: UART 的 SEGGER RTT 的对比 传输方式 优点 缺点 UART 通用，使用简单 慢，占用更多的 CPU 时间 SEGGER RTT 速度快 需要 J-Link 等工具，难以抓取上电阶段的数据 5.6.1 有关 SEGGER RTT 的使用提示 使用 J-LINK RTT Viewer 实时查看 printf 输出 使用 J-LINK RTT Logger 将 trace 记录到文件 这个工具会询问有关 RTT 的设置：设备名称（Device name）为 “CORTEX-M3”； 目标接口（Target interface）为 “SWD”； RTT 控制块（RTT Control Block）的地址即名为 _SEGGER_RTT 的变量的地址，可从 .map 文件中找到； RTT 通道号为 0。 以下是一个示例： ------------------------------------------------------------ Device name. Default: CORTEX-M3 &gt; Target interface. &gt; SWD Interface speed [kHz]. Default: 4000 kHz &gt; RTT Control Block address. Default: auto-detection &gt; 0x2000xxxx RTT Channel name or index. Default: channel 1 &gt; 0 Output file. Default: RTT_&lt;ChannelName&gt;_&lt;Time&gt;.log &gt; ------------------------------------------------------------ Connected to: J-Link Lite .......... S/N: ...... Searching for RTT Control Block...OK. 1 up-channels found. RTT Channel description: Index: 0 Name: Terminal Size: 500 bytes. Output file: .....log Getting RTT data from target. Press any key to quit. 或者，这个工具可以从命令行启动，通过参数设定 _SEGGER_RTT 的地址范围，工具会自动搜索实际地址。例如： JLinkRTTLogger.exe -If SWD -Device CORTEX-M3 -Speed 4000 -RTTSearchRanges &quot;0x20005000 0x8000&quot; -RTTChannel 0 file_name 对于 ING916xx，将上面的 CORTEX-M3 替换为 CORTEX-M4。 5.6.2 内存转储 我们致力于提供高质量的 platform 软件包。如果在 platform 二进制文件内发生断言（assertion）错误， 建议转储全部内存，记录各寄存器的值，然后联系我们获得进一步支持。 内存分为两段（见表 5.3）。 Table 5.3: 内存区域 区域 起始地址 大小 （字节） #1 0x20000000 0x10000 (对于 128kB RAM 的芯片型号) 0x08000 (对于 64kB RAM 的芯片型号) #2 0x400A0000 0x10000 (对于 128kB RAM 的芯片型号) 0x08000 (对于 64kB RAM 的芯片型号) 内存可通过调试器转储： Keil μVision 在调试状态下，打开命令窗口用 save 命令保存每个区域。例如： save sysm.hex 0x20000000,0x2000FFFF save share.hex 0x400A0000,0x400AFFFF J-Link Commander 连接到设备后，使用 regs 查看所有寄存器的当前值，使用 savebin 将每个区域保存到文件。例如： savebin sysm.bin 0x20000000 0x10000 savebin share.bin 0x400A0000 0x10000 IAR Embedded Workbench 在调试状态下，打开内存窗口，打开快捷菜单，用 “Memory Save …” 保存数据。 Rowley Crossworks for ARM &amp; SEGGER Embedded Studio for ARM 在调试状态下，打开内存窗口，对于每个区域： 填写起始地址和大小； 打开快捷菜单，用 “Memory Save …” 保存数据。 GDB (GNU Arm Embedded Toolchain 及 Nim) 在 GDB 调试模式下，使用 dump 命令保存每个区域。 内存也可以使用一小段专门的代码导出。例如在 PLATFORM_CB_EVT_ASSERTION 事件的回调里，将整个内存数据通过 UART 导出。 https://en.wikipedia.org/wiki/Memory_pool https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/ "],["api-ref.html", "6 Platform API 参考 6.1 platform_32k_rc_auto_tune 6.2 platform_32k_rc_tune 6.3 platform_config 6.4 platform_get_heap_status 6.5 platform_get_us_time 6.6 platform_get_version 6.7 platform_hrng 6.8 platform_install_isr_stack 6.9 platform_printf 6.10 platform_raise_assertion 6.11 platform_rand 6.12 platform_read_info 6.13 platform_read_persistent_reg 6.14 platform_reset 6.15 platform_set_evt_callback 6.16 platform_set_irq_callback 6.17 platform_shutdown 6.18 platform_switch_app 6.19 platform_write_persistent_reg 6.20 sysSetPublicDeviceAddr", " 6 Platform API 参考 6.1 platform_32k_rc_auto_tune 自动调谐内部的 32k RC 时钟，得到调谐参数。 6.1.1 原型 uint16_t platform_32k_rc_auto_tune(void); 6.1.2 参数表 无。 6.1.3 返回值 16 比特调谐参数。 6.1.4 备注 本操作需要花费 ~250ms。建议只调用一次本函数，记录调谐参数以备使用。 6.1.5 示例 uint16_t value = platform_32k_rc_auto_tune(); 6.2 platform_32k_rc_tune 使用给定参数调谐内部的 32k RC 时钟。 6.2.1 原型 void platform_32k_rc_tune(uint16_t value); 6.2.2 参数表 uint16_t value 调谐参数 (从 platform_32k_rc_auto_tune 得到) 6.2.3 返回值 无。 6.2.4 备注 void. 6.2.5 示例 platform_32k_rc_tune(value); 6.3 platform_config 配置平台功能。 6.3.1 原型 void platform_config(const platform_cfg_item_t item, const uint32_t flag); 6.3.2 参数表 const platform_cfg_item_t item 指定要配置的项。可以是下列值： PLATFORM_CFG_LOG_HCI: HCI 消息的 printf 打印。默认值：关闭。 PLATFORM_CFG_POWER_SAVING: 省电功能。默认值：关闭。 PLATFORM_CFG_TRACE_MASK: Trace 数据项的比特图。默认值：0。 typedef enum { PLATFORM_TRACE_ID_EVENT = 0, PLATFORM_TRACE_ID_HCI_CMD = 1, PLATFORM_TRACE_ID_HCI_EVENT = 2, PLATFORM_TRACE_ID_HCI_ACL = 3, PLATFORM_TRACE_ID_LLCP = 4 } platform_trace_item_t; PLATFORM_CFG_RC32K_EN: 使能/禁用内部 32k RC 时钟。默认值：使能。 PLATFORM_CFG_OSC32K_EN: 使能/禁用外部 32k 晶体。默认值：使能。 PLATFORM_CFG_32K_CLK: 32k 时钟源选择。参数为 platform_32k_clk_src_t 类型。默认值：PLATFORM_32K_RC typedef enum { PLATFORM_32K_OSC, // 外部 32k 晶体 PLATFORM_32K_RC // 内部 32k RC 时钟 } platform_32k_clk_src_t; 当修改本配置时，RC32K 和 OSC32K 必须同时处理使能、运行状态： 对于 OSC32K，等待直到 OSC32K 的状态变为 OK； 对于 RC32K，使能后等待 100us。 提示：在关闭不用的时钟前再等待 100us。 PLATFORM_CFG_32K_CLK_ACC: 声明 32k 时钟的精度（ppm）。 PLATFORM_CFG_32K_CALI_PERIOD: 32k 时钟的校准间隔（秒）。默认值：3600 * 2 (2 小时)。 PLATFORM_CFG_DEEP_SLEEP_TIME_REDUCTION: 睡眠时间预留量（深睡眠模式）（微秒）。默认值：~550us。 PLATFORM_CFG_SLEEP_TIME_REDUCTION: 睡眠时间预留量（其它睡眠模式）（微秒）。默认值： ~450us. PLATFORM_CFG_LL_DBG_FLAGS: 链路层标志位，是 ll_cfg_flag_t 中各比特的组合。 typedef enum { LL_FLAG_DISABLE_CTE_PREPROCESSING = 1, // 关闭 CTE 预处理 LL_FLAG_LEGACY_ONLY_INITIATING = 4, // 仅使用 legacy 广播发起连接 LL_FLAG_LEGACY_ONLY_SCANNING = 8, // 仅扫描 legacy 广播 } ll_cfg_flag_t; PLATFORM_CFG_LL_LEGACY_ADV_INTERVAL: 链路层 legacy 广播内部间隔（微秒），其中高 16 比特用于高频度广播 （high duty cycle），低 16 比特用于正常频度广播（normal duty cycle）。高频度广播的默认值：1250， 正常频度的默认值：1500。 const uint32_t flag 对于可以使能、禁用的配置，用下面的值进行控制： PLATFORM_CFG_ENABLE PLATFORM_CFG_DISABLE 6.3.3 返回值 无。 6.3.4 备注 无。 6.3.5 示例 // 使能 HCI 打印 platform_config(PLATFORM_CFG_LOG_HCI, PLATFORM_CFG_ENABLE); 6.4 platform_get_heap_status 得到堆当前的状态信息，如剩余空间等。 6.4.1 原型 void platform_get_heap_status(platform_heap_status_t *status); 6.4.2 参数表 platform_heap_status_t *status 堆的状态。 6.4.3 返回值 无。 6.4.4 备注 堆的状态定义如下： typedef struct { uint32_t bytes_free; // 剩余空间 uint32_t bytes_minimum_ever_free; // 自启动以来剩余空间的最小值 } platform_heap_status_t; 6.4.5 示例 platform_heap_status_t status; platform_get_heap_status(&amp;status); 6.5 platform_get_us_time 读取内部计时器的时间。该计时器从 BLE 初始化之后开始计时。 6.5.1 原型 int64_t platform_get_us_time(void); 6.5.2 参数表 无。 6.5.3 返回值 内部计时器的微秒计数值。 6.5.4 备注 关机后该计时器会归零，而 RTC 计时器则不会。 6.5.5 示例 platform_get_us_time(); 6.6 platform_get_version 得到 platform 的版本号。 6.6.1 原型 const platform_ver_t *platform_get_version(void); 6.6.2 参数表 无。 6.6.3 返回值 指向 platform_ver_t 的指针。 6.6.4 备注 Platform 版本号包含 3 个部分，major，minor 和 patch： typedef struct platform_ver { unsigned short major; char minor; char patch; } platform_ver_t; 6.6.5 示例 const platform_ver_t *ver = platform_get_version(); printf(&quot;Platform version: %d.%d.%d\\n&quot;, ver-&gt;major, ver-&gt;minor, ver-&gt;patch); 6.7 platform_hrng 使用硬件真随机数发生器产生任意长度的随机数。 6.7.1 原型 void platform_hrng(uint8_t *bytes, const uint32_t len); 6.7.2 参数表 uint8_t *bytes 随机数输出。 const uint32_t len 要产生的字节数。 6.7.3 返回值 无。 6.7.4 备注 产生一定长度的随机数所需要的时间是不确定的。 6.7.5 示例 uint32_t strong_random; platform_hrng(&amp;strong_random, sizeof(strong_random)); 6.8 platform_install_isr_stack 为中断服务程序安装新的栈。 6.8.1 原型 void platform_install_isr_stack(void *top); 6.8.2 参数表 void *top 新栈的栈顶，必须为 4 字节对齐。 6.8.3 返回值 无。 6.8.4 备注 当 app 需要使用比默认 ISR 栈更大的栈时，可以使用这个 API 安装一个新的栈，替换掉旧的。 这个函数只允许在 app_main 里调用。新栈在 app_main 函数返回后启用。 6.8.5 示例 uint32_t new_stack[2048]; ... platform_install_isr_stack(new_stack + sizeof(new_stack) / sizeof(new_stack[0])); 6.9 platform_printf Platform 内部的 printf 函数。 6.9.1 原型 void platform_printf(const char *format, ...); 6.9.2 参数表 const char *format 格式字符串。 ... 变长参数。 6.9.3 返回值 无。 6.9.4 备注 使用这个函数既有优点也有缺点： 优点： 这个函数位于 platform 内部，可以节省 app 程序空间 缺点： 输出被定向到 PLATFORM_CB_EVT_PUTC 事件，所以必须为该事件设立回调。 6.9.5 示例 platform_printf(&quot;Hello world&quot;); 6.10 platform_raise_assertion 抛出软件断言。 6.10.1 原型 void platform_raise_assertion(const char *file_name, int line_no); 6.10.2 参数表 const char *file_name 断言发生的文件名。 int line_no 断言发生的代码行。 6.10.3 返回值 无。 6.10.4 备注 无。 6.10.5 示例 if (NULL == ptr) platform_raise_assertion(__FILE__, __LINE__); 6.11 platform_rand 使用 platform 内的伪随机数发生器（PRNG）生成伪随机整数。 6.11.1 原型 int platform_rand(void); 6.11.2 参数表 无。 6.11.3 返回值 一个在 0 和 RAND_MAX 之间均匀分布的随机数。 6.11.4 备注 上电时用硬件随机数发生数发生器为 PRNG 生成了种子。 6.11.5 示例 printf(&quot;rand: %d\\n&quot;, platform_rand()); 6.12 platform_read_info 读取 platform 信息。 6.12.1 原型 uint32_t platform_read_info(const platform_info_item_t item); 6.12.2 参数表 const platform_info_item_t item 信息项： typedef enum { PLATFORM_INFO_OSC32K_STATUS, // 外部 32k 晶体时钟的状态 // 0: 不工作；非 0: 正常工作 } platform_info_item_t; 6.12.3 返回值 信息项的值。 6.12.4 备注 无。 6.12.5 示例 platform_read_info(PLATFORM_INFO_OSC32K_STATUS); 6.13 platform_read_persistent_reg 读取持久化寄存器的值。参考 platform_write_persistent_reg。 6.13.1 原型 uint32_t platform_read_persistent_reg(void); 6.13.2 参数表 无。 6.13.3 返回值 用 platform_write_persistent_reg 写入的 4 个比特。 6.13.4 备注 无。 6.13.5 示例 platform_read_persistent_reg(); 6.14 platform_reset 复位整个系统（SoC）。 6.14.1 原型 void platform_reset(void); 6.14.2 参数表 无。 6.14.3 返回值 无。 6.14.4 备注 在这个函数之后的代码不会被执行。 6.14.5 示例 if (out-of-memory) platform_reset(); 6.15 platform_set_evt_callback 为 platform 事件设置回调函数。 6.15.1 原型 void platform_set_evt_callback(platform_evt_callback_type_t type, f_platform_evt_cb f, void *user_data); 6.15.2 参数表 platform_evt_callback_type_t type 事件的类型。可以是下列值： PLATFORM_CB_EVT_PUTC: ASCII 字符输出事件 当 platform 要输出字符串日志时会触发该事件。传递到回调函数的参数 void *data 是从 char * 转换得来。 用 ingWizard 创建新项目时，如果在 Common Function 页面选择了 Print to UART， 会自动生成相关代码。 PLATFORM_CB_EVT_PROFILE_INIT: BLE GATT profile 初始化事件 当 Host 初始化时会触发该事件要求 app 初始化 GATT profile。 用 ingWizard 创建新项目时，会自动生成相关代码。 PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP: 深睡眠唤醒事件 深睡眠中唤醒时触发该事件。在深睡眠时，外部接口（如 UART,，I2C 等）都已掉电，所以当唤醒时， 可能需要再次初始化。 用 ingWizard 创建新项目时，如果在 Common Function 页面选择了 Deep Sleep， 会自动生成相关代码。 PLATFORM_CB_EVT_QUERY_DEEP_SLEEP_ALLOWED: 深睡眠许可查询事件 当 platform 准备进入深睡眠时，会触发该事件询问 app 当前是否允许进入深睡眠。 事件回调函数可通过返回 0 拒绝，返回非 0 允许。 用 ingWizard 创建新项目时，如果在 Common Function 页面选择了 Deep Sleep， 会自动生成相关代码。 PLATFORM_CB_EVT_HARD_FAULT: Hard fault 事件 Hard fault 发生时触发该事件。传入回调函数的 void *data 参数是从 hard_fault_info_t * 转换得来。 如果未定义该回调，当事件发生时，CPU 进入死循环。 PLATFORM_CB_EVT_ASSERTION: Software assertion fails 软件断言失败时触发该事件。传入回调函数的 void *data 参数是从 assertion_info_t * 转换得来。 如果未定义该回调，当事件发生时，CPU 进入死循环。 PLATFORM_CB_EVT_LLE_INIT: 链路层引擎初始化完成事件 每当链路层引擎初始化完成时触发该事件。 PLATFORM_CB_EVT_HEAP_OOM: 堆空间用完事件 在堆上分配内存失败时触发该事件。 如果未定义该回调，当事件发生时，CPU 进入死循环。 PLATFORM_CB_EVT_TRACE: Trace 输出事件 当有 trace 数据项要输出时，触发该事件。 Apps 可以为该事件设置回调函数以保存或者输出 trace 数据。传人回调函数的 void *data 参数是从 platform_trace_evt_t * 转换得来（参见 调试与跟踪）。 typedef struct { const void *data1; const void *data2; uint16_t len1; uint16_t len2; } platform_evt_trace_t; 一个 trace 数据项由 data1 和 data2 组成。说明： len1 或者 len2 可能为 0，但不会同时为 0； 如果回调函数发现无法存储或者输出长度为 len1 + len2 的数据，那么应该同时丢弃 data1 和 data2 以防 trace 数据结构混乱。 f_platform_evt_cb f 注册到事件 type 的回调函数。f_platform_evt_cb 的类型为： typedef uint32_t (*f_platform_evt_cb)(void *data, void *user_data); void *user_data 这个参数将原封不动地作为 user_data 传递给回调函数。 6.15.3 返回值 无。 6.15.4 备注 并不要求给所有事件都设置回调函数。 如果未给 PLATFORM_CB_EVT_PUTC 事件设置回调，所有用平台 printf 日志都会丢弃。 如果未给PLATFORM_CB_EVT_PROFILE_INIT 事件设置回调，BLE profile 为空。 如果未给 PLATFORM_CB_EVT_ON_DEEP_SLEEP_WAKEUP 事件设置回调，从深睡眠唤醒时 app 无法获得通知。 如果未给 PLATFORM_CB_EVT_QUERY_DEEP_SLEEP_ALLOWED 事件设置回调，深睡眠模式为 禁用 状态。 6.15.5 示例 uint32_t cb_putc(char *c, void *dummy) { // TODO: output char c to UART return 0; } ...... platform_set_evt_callback(PLATFORM_CB_EVT_PUTC, (f_platform_evt_cb)cb_putc, NULL); 6.16 platform_set_irq_callback 为中断请求设置回调函数。 开发者不需要定义 IRQ 处理函数，而是通过设置回调实现。两种芯片系列的中断请求总结于表 6.1 和表 6.2。 Table 6.1: ING918xx IRQ 总结 外设类型 数量 备注 RTC 1 Real Time Clock TIMER 3 Timer GPIO 1 General Purpose Input/Output SPI 2 Serial Peripheral Interface UART 2 Universal Asynchronous Receiver-Transmitter I2C 2 Inter-Integrated Circuit Table 6.2: ING916xx IRQ 总结 外设类型 数量 备注 RTC 1 Real Time Clock GPIO 2 General Purpose Input/Output TIMER 3 Timer WDT 1 Watch dog PDM 1 Pulse Density Modulation APBSPI 1 Serial Peripheral Interface on APB QSPI 1 Quad serial peripheral interface I2S 1 Inter-IC Sound UART 2 Universal Asynchronous Receiver-Transmitter I2C 2 Inter-Integrated Circuit DMA 1 Direct Memory Access KEYSCAN 1 Key Scanner PWM 1 Pulse Width Modulation IR INT 1 Infrared Interrupt IR WAKEUP 1 Infrared Wake-up Interrupt USB 1 Universal Serial Bus 6.16.1 原型 void platform_set_irq_callback(platform_irq_callback_type_t type, f_platform_irq_cb f, void *user_data); 6.16.2 参数表 platform_irq_callback_type_t type 中断类型。 对于 ING918xx，中断类型如下： PLATFORM_CB_IRQ_RTC, PLATFORM_CB_IRQ_TIMER0, PLATFORM_CB_IRQ_TIMER1, PLATFORM_CB_IRQ_TIMER2, PLATFORM_CB_IRQ_GPIO, PLATFORM_CB_IRQ_SPI0, PLATFORM_CB_IRQ_SPI1, PLATFORM_CB_IRQ_UART0, PLATFORM_CB_IRQ_UART1, PLATFORM_CB_IRQ_I2C0, PLATFORM_CB_IRQ_I2C1 对于 ING916xx，中断类型如下： PLATFORM_CB_IRQ_RTC, PLATFORM_CB_IRQ_GPIO0, PLATFORM_CB_IRQ_GPIO1, PLATFORM_CB_IRQ_TIMER0, PLATFORM_CB_IRQ_TIMER1, PLATFORM_CB_IRQ_TIMER2, PLATFORM_CB_IRQ_WDT, PLATFORM_CB_IRQ_PDM, PLATFORM_CB_IRQ_APBSPI, PLATFORM_CB_IRQ_QSPI, PLATFORM_CB_IRQ_SADC, PLATFORM_CB_IRQ_I2S, PLATFORM_CB_IRQ_UART0, PLATFORM_CB_IRQ_UART1, PLATFORM_CB_IRQ_I2C0, PLATFORM_CB_IRQ_I2C1, PLATFORM_CB_IRQ_DMA, PLATFORM_CB_IRQ_KEYSCAN, PLATFORM_CB_IRQ_PWM, PLATFORM_CB_IRQ_IR_INT, PLATFORM_CB_IRQ_IR_WAKEUP, PLATFORM_CB_IRQ_IR_USB, f_platform_irq_cb f 注册到中断 type 的回调函数。 f_platform_irq_cb 的类型为： typedef uint32_t (*f_platform_irq_cb)(void *user_data); void *user_data 这个参数将原封不动地作为 user_data 传递给回调函数。 6.16.3 返回值 无。 6.16.4 备注 当为中断配置了回调函数后，对应的 IRQ 自动使能。 6.16.5 示例 uint32_t cb_irq_uart0(void *dummy) { // TODO: add UART0 IRQ handling code return 0; } ...... platform_set_irq_callback(PLATFORM_CB_IRQ_UART0, cb_irq_uart0, NULL); 6.17 platform_shutdown 将整个系统（SoC）置于关机状态，并在一段指定时间后重新启动。可选地， 可以指定保持一段内存，重启之后，app 可继续使用其中的数据。 需要注意这个函数不会返回，除非无法进入关机状态。可能导致无法进入关机状态的原因有： 外部唤醒信号有效； 输入参数有误； 内部设备正忙。 6.17.1 原型 void platform_shutdown(const uint32_t duration_cycles, const void *p_retention_data, const uint32_t data_size); 6.17.2 参数表 const uint32_t duration_cycles 关机状态的持续时间（以 32k 时钟周期数表示），超时后重启。 最小时间为 825 个周期（大约 25.18ms）。如果该参数为 0，则系统将一直保持关机状态，直到出现外部唤醒信号。 const void *p_retention_data 指向需要保持的内存数据的地址。只有 SYSTEM 内存区域允许保持（ING918xx）。 当 data_size 为 0 时，该参考可以为 NULL。 data_size 需要保持的内存数据的长度。如果不需要保存数据，将此参数设为 0。 6.17.3 返回值 无。 6.17.4 备注 无。 6.17.5 示例 // 关闭系统，1s 之后重启 platform_shutdown(32768, NULL, 0); 6.18 platform_switch_app 切换到辅 app。 6.18.1 原型 void platform_switch_app(const uint32_t app_addr); 6.18.2 参数表 const uint32_t app_addr 辅 app 的入口地址。 6.18.3 返回值 无。 6.18.4 备注 本函数之后的代码不会被执行。 6.18.5 示例 platform_switch_app(0x80000); 6.19 platform_write_persistent_reg 将值写入持久化寄存器。这个值在省电、关机、辅app切换等过程或者状态下都保持不变。 6.19.1 原型 void platform_write_persistent_reg(const uint8_t value); 6.19.2 参数表 const uint8_t value 值。 6.19.3 返回值 无。 6.19.4 备注 只会保存 4 个比特。 6.19.5 示例 platform_write_persistent_reg(1); 6.20 sysSetPublicDeviceAddr 设置设备的公共地址（public address）. BLE 设备的公共地址是 48 比特的唯一标识（EUI-48），遵照 IEEE 802-2014 standard19 创建。 INGCHIPS 918xx/916xx 不 具备公共地址。 本函数 仅 用于调试和测试，绝不可 用于最终产品。 6.20.1 原型 void sysSetPublicDeviceAddr(const unsigned char *addr); 6.20.2 参数表 const unsigned char *addr 新的公共地址。 6.20.3 返回值 无。 6.20.4 备注 为了避免产生问题，本函数应该先于任何 GAP 函数调用。建议在 app_main 或者 PLATFORM_CB_EVT_PROFILE_INIT 事件的回调里使用。 6.20.5 示例 const unsigned char pub_addr[] = {1,2,3,4,5,6}; sysSetPublicDeviceAddr(pub_addr); http://standards.ieee.org/findstds/standard/802-2014.html "],["revision-history.html", "7 版本历史", " 7 版本历史 版本 信息 日期 1.0 Initial release 2020-07-28 1.1 Add Python downloader 2020-10-10 1.2 Update API descriptions 2020-07-05 1.2.1 Update memory dump section 2020-08-02 1.2.2 Fix typos, other minor updates 2020-09-08 1.2.3 Fix order of versions in “Device With FOTA” and typo 2020-09-09 1.2.4 Fix outdated information in tutorials 2020-10-20 1.2.5 Update for “NoOS” bundles 2020-11-15 1.2.6 Add ING9186xx 2022-01-10 "]]
